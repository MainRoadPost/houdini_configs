#line 1 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
#line 15 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
_Pragma("opname principledshader1");
_Pragma("oplabel \"Local Vop Code\"");
_Pragma("opmininputs 0");
_Pragma("opmaxinputs 0");
_Pragma("label	surface_textureFilter	Filter");
_Pragma("choice	surface_textureFilter	\"box\"	\"Box\"");
_Pragma("choice	surface_textureFilter	\"gauss\"	\"Gaussian\"");
_Pragma("choice	surface_textureFilter	\"bartlett\"	\"Bartlett/Triangular\"");
_Pragma("choice	surface_textureFilter	\"sinc\"	\"Sinc Sharpening\"");
_Pragma("choice	surface_textureFilter	\"hanning\"	\"Hanning\"");
_Pragma("choice	surface_textureFilter	\"blackman\"	\"Blackman\"");
_Pragma("choice	surface_textureFilter	\"catrom\"	\"Catmull-Rom\"");
_Pragma("choice	surface_textureFilter	\"mitchell\"	\"Mitchell\"");
_Pragma("label	surface_textureFilterWidth	\"Filter Width\"");
_Pragma("range	surface_textureFilterWidth	0	5");
_Pragma("label	uv	\"UV Coordinates\"");
_Pragma("hint	uv	hidden");
_Pragma("hint	uv	vector");
_Pragma("label	difflabel	Diffuse");
_Pragma("label	refllabel	Reflection");
_Pragma("label	coatlabel	\"Coat Reflection\"");
_Pragma("label	anisodir	\"Anisotropy Direction\"");
_Pragma("range	anisodir	0	1");
_Pragma("label	emitcolor	\"Emission Color\"");
_Pragma("hint	emitcolor	color");
_Pragma("label	emitcolor_useTexture	\"Use Texture\"");
_Pragma("hint	emitcolor_useTexture	toggle");
_Pragma("label	emitcolor_texture	Texture");
_Pragma("hint	emitcolor_texture	image");
_Pragma("hidewhen	emitcolor_texture	{ emitcolor_useTexture == 0 }");
_Pragma("label	emitcolor_textureWrap	Wrap");
_Pragma("hidewhen	emitcolor_textureWrap	{ emitcolor_useTexture == 0 }");
_Pragma("choice	emitcolor_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	emitcolor_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	emitcolor_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	emitcolor_textureIntensity	\"Tint Intensity\"");
_Pragma("range	emitcolor_textureIntensity	0	2");
_Pragma("hidewhen	emitcolor_textureIntensity	{ emitcolor_useTexture == 0 }");
_Pragma("label	emitillum	\"Emission Illuminates Objects\"");
_Pragma("hint	emitillum	toggle");
_Pragma("label	emitint	\"Emission Intensity\"");
_Pragma("range	emitint	0	10");
_Pragma("label	anisodir_monoChannel	Channel");
_Pragma("hint	anisodir_monoChannel	joinnext");
_Pragma("range	anisodir_monoChannel	0	10");
_Pragma("disablewhen	anisodir_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	anisodir_monoChannel	{ anisodir_useTexture == 0 }");
_Pragma("choice	anisodir_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	anisodir_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	anisodir_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	anisodir_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	anisodir_useTexture	\"Use Texture\"");
_Pragma("hint	anisodir_useTexture	toggle");
_Pragma("callback	anisodir_useTexture	'python -c \\'hou.phm().toggle_anisodir_texture(hou.pwd())\\''");
_Pragma("disablewhen	anisodir_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	anisodir_texture	Texture");
_Pragma("hint	anisodir_texture	image");
_Pragma("disablewhen	anisodir_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	anisodir_texture	{ anisodir_useTexture == 0 }");
_Pragma("label	anisodir_textureWrap	Wrap");
_Pragma("hint	anisodir_textureWrap	joinnext");
_Pragma("disablewhen	anisodir_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	anisodir_textureWrap	{ anisodir_useTexture == 0 }");
_Pragma("choice	anisodir_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	anisodir_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	anisodir_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	anisodir_textureFilter	\"Filter Type\"");
_Pragma("hidewhen	anisodir_textureFilter	{ anisodir_useTexture == 0 }");
_Pragma("choice	anisodir_textureFilter	\"box\"	\"Box\"");
_Pragma("choice	anisodir_textureFilter	\"gauss\"	\"Gaussian\"");
_Pragma("choice	anisodir_textureFilter	\"bartlett\"	\"Bartlett/Triangular\"");
_Pragma("choice	anisodir_textureFilter	\"sinc\"	\"Sinc Sharpening\"");
_Pragma("choice	anisodir_textureFilter	\"hanning\"	\"Hanning\"");
_Pragma("choice	anisodir_textureFilter	\"blackman\"	\"Blackman\"");
_Pragma("choice	anisodir_textureFilter	\"catrom\"	\"Catmull-Rom\"");
_Pragma("choice	anisodir_textureFilter	\"mitchell\"	\"Mitchell\"");
_Pragma("choice	anisodir_textureFilter	\"point\"	\"Point (No Filter)\"");
_Pragma("label	baseBumpAndNormal_type	\"Texture Type\"");
_Pragma("disablewhen	baseBumpAndNormal_type	{ baseBumpAndNormal_enable == 0 }");
_Pragma("choice	baseBumpAndNormal_type	\"bump\"	\"Bump\"");
_Pragma("choice	baseBumpAndNormal_type	\"normal\"	\"Normal\"");
_Pragma("label	baseBump_colorSpace	\"Texture Color Space\"");
_Pragma("disablewhen	baseBump_colorSpace	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_colorSpace	{ baseBumpAndNormal_type != bump }");
_Pragma("choice	baseBump_colorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	baseBump_colorSpace	\"linear\"	\"Linear\"");
_Pragma("label	baseNormal_vectorSpace	\"Vector Space\"");
_Pragma("disablewhen	baseNormal_vectorSpace	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_vectorSpace	{ baseBumpAndNormal_type != normal }");
_Pragma("choice	baseNormal_vectorSpace	\"uvtangent\"	\"UV Tangent Space\"");
_Pragma("choice	baseNormal_vectorSpace	\"object\"	\"Object Space\"");
_Pragma("choice	baseNormal_vectorSpace	\"world\"	\"World Space\"");
_Pragma("label	baseBump_wrap	Wrap");
_Pragma("hint	baseBump_wrap	joinnext");
_Pragma("disablewhen	baseBump_wrap	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_wrap	{ baseBumpAndNormal_type != bump }");
_Pragma("choice	baseBump_wrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	baseBump_wrap	\"streak\"	\"Streak\"");
_Pragma("choice	baseBump_wrap	\"decal\"	\"Decal\"");
_Pragma("label	baseBump_filter	Filter");
_Pragma("hint	baseBump_filter	joinnext");
_Pragma("disablewhen	baseBump_filter	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_filter	{ baseBumpAndNormal_type != bump }");
_Pragma("choice	baseBump_filter	\"box\"	\"Box\"");
_Pragma("choice	baseBump_filter	\"gauss\"	\"Gaussian\"");
_Pragma("choice	baseBump_filter	\"bartlett\"	\"Bartlett/Triangular\"");
_Pragma("choice	baseBump_filter	\"sinc\"	\"Sinc Sharpening\"");
_Pragma("choice	baseBump_filter	\"hanning\"	\"Hanning\"");
_Pragma("choice	baseBump_filter	\"blackman\"	\"Blackman\"");
_Pragma("choice	baseBump_filter	\"catrom\"	\"Catmull-Rom\"");
_Pragma("choice	baseBump_filter	\"mitchell\"	\"Mitchell\"");
_Pragma("label	baseBump_filterWidth	\"Filter Width\"");
_Pragma("range	baseBump_filterWidth	0	2");
_Pragma("disablewhen	baseBump_filterWidth	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_filterWidth	{ baseBumpAndNormal_type != bump }");
_Pragma("label	baseBump_channel	Channel");
_Pragma("range	baseBump_channel	0	10");
_Pragma("disablewhen	baseBump_channel	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_channel	{ baseBumpAndNormal_type != bump }");
_Pragma("choice	baseBump_channel	\"0\"	\"Luminance\"");
_Pragma("choice	baseBump_channel	\"1\"	\"Red\"");
_Pragma("choice	baseBump_channel	\"2\"	\"Green\"");
_Pragma("choice	baseBump_channel	\"3\"	\"Blue\"");
_Pragma("label	baseBump_imagePlane	\"Image Plane\"");
_Pragma("disablewhen	baseBump_imagePlane	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_imagePlane	{ baseBumpAndNormal_type != bump }");
_Pragma("label	baseNormal_space	\"Normal Space\"");
_Pragma("range	baseNormal_space	0	10");
_Pragma("disablewhen	baseNormal_space	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_space	{ baseBumpAndNormal_type != normal }");
_Pragma("choice	baseNormal_space	\"0\"	\"0 to 1\"");
_Pragma("choice	baseNormal_space	\"1\"	\"-1 to 1\"");
_Pragma("label	baseNormal_flipX	\"Flip X\"");
_Pragma("hint	baseNormal_flipX	toggle");
_Pragma("disablewhen	baseNormal_flipX	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_flipX	{ baseBumpAndNormal_type != normal }");
_Pragma("label	baseNormal_flipY	\"Flip Y\"");
_Pragma("hint	baseNormal_flipY	toggle");
_Pragma("disablewhen	baseNormal_flipY	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_flipY	{ baseBumpAndNormal_type != normal }");
_Pragma("label	basecolor_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	basecolor_textureColorSpace	{ diff_enable == 0 }");
_Pragma("hidewhen	basecolor_textureColorSpace	{ basecolor_useTexture == 0 }");
_Pragma("choice	basecolor_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	basecolor_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	metallic_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	metallic_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	metallic_textureColorSpace	{ metallic_useTexture == 0 }");
_Pragma("choice	metallic_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	metallic_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	reflecttint_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	reflecttint_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	reflecttint_textureColorSpace	{ reflecttint_useTexture == 0 }");
_Pragma("choice	reflecttint_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	reflecttint_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	rough_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	rough_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	rough_textureColorSpace	{ rough_useTexture == 0 }");
_Pragma("choice	rough_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	rough_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	aniso_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	aniso_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	aniso_textureColorSpace	{ aniso_useTexture == 0 }");
_Pragma("choice	aniso_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	aniso_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	sss_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	sss_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	sss_textureColorSpace	{ sss_useTexture == 0 }");
_Pragma("choice	sss_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	sss_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	sheentint_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	sheentint_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	sheentint_textureColorSpace	{ sheentint_useTexture == 0 }");
_Pragma("choice	sheentint_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	sheentint_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	coatrough_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	coatrough_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	coatrough_textureColorSpace	{ coatrough_useTexture == 0 }");
_Pragma("choice	coatrough_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	coatrough_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	sheen_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	sheen_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	sheen_textureColorSpace	{ sheen_useTexture == 0 }");
_Pragma("choice	sheen_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	sheen_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	coat_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	coat_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	coat_textureColorSpace	{ coat_useTexture == 0 }");
_Pragma("choice	coat_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	coat_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	emitcolor_textureColorSpace	\"Source Color Space\"");
_Pragma("hidewhen	emitcolor_textureColorSpace	{ emitcolor_useTexture == 0 }");
_Pragma("choice	emitcolor_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	emitcolor_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	Cd	\"Attribute Color\"");
_Pragma("hint	Cd	color");
_Pragma("hint	Cd	invisible");
_Pragma("label	Alpha	\"Attribute Alpha\"");
_Pragma("hint	Alpha	invisible");
_Pragma("range	Alpha	0	1");
_Pragma("label	basecolor	\"Base Color\"");
_Pragma("hint	basecolor	color");
_Pragma("disablewhen	basecolor	{ basecolor_useBaseColor == 0 } { diff_enable == 0 }");
_Pragma("label	basecolor_usePointColor	\"Use Point Color\"");
_Pragma("hint	basecolor_usePointColor	toggle");
_Pragma("disablewhen	basecolor_usePointColor	{ diff_enable == 0 }");
_Pragma("label	basecolor_useTexture	\"Use Texture\"");
_Pragma("hint	basecolor_useTexture	toggle");
_Pragma("disablewhen	basecolor_useTexture	{ diff_enable == 0 }");
_Pragma("label	basecolor_texture	Texture");
_Pragma("hint	basecolor_texture	image");
_Pragma("disablewhen	basecolor_texture	{ diff_enable == 0 }");
_Pragma("hidewhen	basecolor_texture	{ basecolor_useTexture == 0 }");
_Pragma("label	basecolor_textureWrap	Wrap");
_Pragma("disablewhen	basecolor_textureWrap	{ diff_enable == 0 }");
_Pragma("hidewhen	basecolor_textureWrap	{ basecolor_useTexture == 0 }");
_Pragma("choice	basecolor_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	basecolor_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	basecolor_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	basecolor_textureIntensity	\"Tint Intensity\"");
_Pragma("range	basecolor_textureIntensity	0	2");
_Pragma("disablewhen	basecolor_textureIntensity	{ diff_enable == 0 }");
_Pragma("hidewhen	basecolor_textureIntensity	{ basecolor_useTexture == 0 }");
_Pragma("label	metallic_monoChannel	Channel");
_Pragma("hint	metallic_monoChannel	joinnext");
_Pragma("range	metallic_monoChannel	0	10");
_Pragma("disablewhen	metallic_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	metallic_monoChannel	{ metallic_useTexture == 0 }");
_Pragma("choice	metallic_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	metallic_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	metallic_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	metallic_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	metallic_useTexture	\"Use Texture\"");
_Pragma("hint	metallic_useTexture	toggle");
_Pragma("disablewhen	metallic_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	metallic_texture	Texture");
_Pragma("hint	metallic_texture	image");
_Pragma("disablewhen	metallic_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	metallic_texture	{ metallic_useTexture == 0 }");
_Pragma("label	metallic_textureWrap	Wrap");
_Pragma("hint	metallic_textureWrap	joinnext");
_Pragma("disablewhen	metallic_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	metallic_textureWrap	{ metallic_useTexture == 0 }");
_Pragma("choice	metallic_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	metallic_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	metallic_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	basecolor_usePackedColor	\"Use Packed Color\"");
_Pragma("hint	basecolor_usePackedColor	toggle");
_Pragma("disablewhen	basecolor_usePackedColor	{ diff_enable == 0 }");
_Pragma("label	baseBumpAndNormal_enable	Enable");
_Pragma("hint	baseBumpAndNormal_enable	toggle");
_Pragma("label	separateCoatNormals	\"Separate Coat Normals\"");
_Pragma("hint	separateCoatNormals	toggle");
_Pragma("label	metallic	Metallic");
_Pragma("range	metallic	0	1");
_Pragma("hidewhen	metallic	{ useBaseColor == 0 }");
_Pragma("label	reflecttint_monoChannel	Channel");
_Pragma("hint	reflecttint_monoChannel	joinnext");
_Pragma("range	reflecttint_monoChannel	0	10");
_Pragma("disablewhen	reflecttint_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	reflecttint_monoChannel	{ reflecttint_useTexture == 0 }");
_Pragma("choice	reflecttint_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	reflecttint_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	reflecttint_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	reflecttint_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	reflecttint_useTexture	\"Use Texture\"");
_Pragma("hint	reflecttint_useTexture	toggle");
_Pragma("disablewhen	reflecttint_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	reflecttint_texture	Texture");
_Pragma("hint	reflecttint_texture	image");
_Pragma("disablewhen	reflecttint_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	reflecttint_texture	{ reflecttint_useTexture == 0 }");
_Pragma("label	reflecttint_textureWrap	Wrap");
_Pragma("hint	reflecttint_textureWrap	joinnext");
_Pragma("disablewhen	reflecttint_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	reflecttint_textureWrap	{ reflecttint_useTexture == 0 }");
_Pragma("choice	reflecttint_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	reflecttint_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	reflecttint_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	reflecttint	\"Reflect Tint\"");
_Pragma("range	reflecttint	0	1");
_Pragma("hidewhen	reflecttint	{ useBaseColor == 0 }");
_Pragma("label	rough_monoChannel	Channel");
_Pragma("hint	rough_monoChannel	joinnext");
_Pragma("range	rough_monoChannel	0	10");
_Pragma("disablewhen	rough_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	rough_monoChannel	{ rough_useTexture == 0 }");
_Pragma("choice	rough_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	rough_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	rough_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	rough_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	rough_useTexture	\"Use Texture\"");
_Pragma("hint	rough_useTexture	toggle");
_Pragma("disablewhen	rough_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	rough_texture	Texture");
_Pragma("hint	rough_texture	image");
_Pragma("disablewhen	rough_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	rough_texture	{ rough_useTexture == 0 }");
_Pragma("label	rough_textureWrap	Wrap");
_Pragma("hint	rough_textureWrap	joinnext");
_Pragma("disablewhen	rough_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	rough_textureWrap	{ rough_useTexture == 0 }");
_Pragma("choice	rough_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	rough_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	rough_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	rough	Roughness");
_Pragma("range	rough	0	1");
_Pragma("hidewhen	rough	{ useBaseColor == 0 }");
_Pragma("label	aniso_monoChannel	Channel");
_Pragma("hint	aniso_monoChannel	joinnext");
_Pragma("range	aniso_monoChannel	0	10");
_Pragma("disablewhen	aniso_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	aniso_monoChannel	{ aniso_useTexture == 0 }");
_Pragma("choice	aniso_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	aniso_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	aniso_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	aniso_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	aniso_useTexture	\"Use Texture\"");
_Pragma("hint	aniso_useTexture	toggle");
_Pragma("disablewhen	aniso_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	aniso_texture	Texture");
_Pragma("hint	aniso_texture	image");
_Pragma("disablewhen	aniso_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	aniso_texture	{ aniso_useTexture == 0 }");
_Pragma("label	aniso_textureWrap	Wrap");
_Pragma("hint	aniso_textureWrap	joinnext");
_Pragma("disablewhen	aniso_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	aniso_textureWrap	{ aniso_useTexture == 0 }");
_Pragma("choice	aniso_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	aniso_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	aniso_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	aniso	Anisotropy");
_Pragma("range	aniso	0	1");
_Pragma("hidewhen	aniso	{ useBaseColor == 0 }");
_Pragma("label	sss_monoChannel	Channel");
_Pragma("hint	sss_monoChannel	joinnext");
_Pragma("range	sss_monoChannel	0	10");
_Pragma("disablewhen	sss_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sss_monoChannel	{ sss_useTexture == 0 }");
_Pragma("choice	sss_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	sss_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	sss_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	sss_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	sss_useTexture	\"Use Texture\"");
_Pragma("hint	sss_useTexture	toggle");
_Pragma("disablewhen	sss_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	sss_texture	Texture");
_Pragma("hint	sss_texture	image");
_Pragma("disablewhen	sss_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sss_texture	{ sss_useTexture == 0 }");
_Pragma("label	sss_textureWrap	Wrap");
_Pragma("hint	sss_textureWrap	joinnext");
_Pragma("disablewhen	sss_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sss_textureWrap	{ sss_useTexture == 0 }");
_Pragma("choice	sss_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	sss_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	sss_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	sss	Subsurface");
_Pragma("range	sss	0	1");
_Pragma("hidewhen	sss	{ useBaseColor == 0 }");
_Pragma("label	sheen_monoChannel	Channel");
_Pragma("hint	sheen_monoChannel	joinnext");
_Pragma("range	sheen_monoChannel	0	10");
_Pragma("disablewhen	sheen_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sheen_monoChannel	{ sheen_useTexture == 0 }");
_Pragma("choice	sheen_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	sheen_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	sheen_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	sheen_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	sheen_useTexture	\"Use Texture\"");
_Pragma("hint	sheen_useTexture	toggle");
_Pragma("disablewhen	sheen_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	sheen_texture	Texture");
_Pragma("hint	sheen_texture	image");
_Pragma("disablewhen	sheen_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sheen_texture	{ sheen_useTexture == 0 }");
_Pragma("label	sheen_textureWrap	Wrap");
_Pragma("hint	sheen_textureWrap	joinnext");
_Pragma("disablewhen	sheen_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sheen_textureWrap	{ sheen_useTexture == 0 }");
_Pragma("choice	sheen_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	sheen_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	sheen_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	sheen	Sheen");
_Pragma("range	sheen	0	1");
_Pragma("hidewhen	sheen	{ useBaseColor == 0 }");
_Pragma("label	sheentint_monoChannel	Channel");
_Pragma("hint	sheentint_monoChannel	joinnext");
_Pragma("range	sheentint_monoChannel	0	10");
_Pragma("disablewhen	sheentint_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sheentint_monoChannel	{ sheentint_useTexture == 0 }");
_Pragma("choice	sheentint_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	sheentint_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	sheentint_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	sheentint_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	sheentint_useTexture	\"Use Texture\"");
_Pragma("hint	sheentint_useTexture	toggle");
_Pragma("disablewhen	sheentint_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	sheentint_texture	Map");
_Pragma("hint	sheentint_texture	image");
_Pragma("disablewhen	sheentint_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sheentint_texture	{ sheentint_useTexture == 0 }");
_Pragma("label	sheentint_textureWrap	Wrap");
_Pragma("hint	sheentint_textureWrap	joinnext");
_Pragma("disablewhen	sheentint_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sheentint_textureWrap	{ sheentint_useTexture == 0 }");
_Pragma("choice	sheentint_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	sheentint_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	sheentint_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	sheentint	\"Sheen Tint\"");
_Pragma("range	sheentint	0	1");
_Pragma("hidewhen	sheentint	{ useBaseColor == 0 }");
_Pragma("label	coat_monoChannel	Channel");
_Pragma("hint	coat_monoChannel	joinnext");
_Pragma("range	coat_monoChannel	0	10");
_Pragma("disablewhen	coat_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	coat_monoChannel	{ coat_useTexture == 0 }");
_Pragma("choice	coat_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	coat_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	coat_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	coat_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	coat_useTexture	\"Use Texture\"");
_Pragma("hint	coat_useTexture	toggle");
_Pragma("disablewhen	coat_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	coat_texture	Texture");
_Pragma("hint	coat_texture	image");
_Pragma("disablewhen	coat_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	coat_texture	{ coat_useTexture == 0 }");
_Pragma("label	coat_textureWrap	Wrap");
_Pragma("hint	coat_textureWrap	joinnext");
_Pragma("disablewhen	coat_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	coat_textureWrap	{ coat_useTexture == 0 }");
_Pragma("choice	coat_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	coat_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	coat_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	coat	Coat");
_Pragma("range	coat	0	1");
_Pragma("hidewhen	coat	{ useBaseColor == 0 }");
_Pragma("label	coatrough_monoChannel	Channel");
_Pragma("hint	coatrough_monoChannel	joinnext");
_Pragma("range	coatrough_monoChannel	0	10");
_Pragma("disablewhen	coatrough_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	coatrough_monoChannel	{ coatrough_useTexture == 0 }");
_Pragma("choice	coatrough_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	coatrough_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	coatrough_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	coatrough_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	coatrough_useTexture	\"Use Texture\"");
_Pragma("hint	coatrough_useTexture	toggle");
_Pragma("disablewhen	coatrough_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	coatrough_texture	Texture");
_Pragma("hint	coatrough_texture	image");
_Pragma("disablewhen	coatrough_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	coatrough_texture	{ coatrough_useTexture == 0 }");
_Pragma("label	coatrough_textureWrap	Wrap");
_Pragma("hint	coatrough_textureWrap	joinnext");
_Pragma("disablewhen	coatrough_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	coatrough_textureWrap	{ coatrough_useTexture == 0 }");
_Pragma("choice	coatrough_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	coatrough_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	coatrough_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	coatrough	\"Coat Roughness\"");
_Pragma("range	coatrough	0	1");
_Pragma("hidewhen	coatrough	{ useBaseColor == 0 }");
_Pragma("label	baseBump_bumpTexture	\"Texture Path\"");
_Pragma("hint	baseBump_bumpTexture	image");
_Pragma("disablewhen	baseBump_bumpTexture	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_bumpTexture	{ baseBumpAndNormal_type != bump }");
_Pragma("label	baseBump_bumpScale	\"Effect Scale\"");
_Pragma("range	baseBump_bumpScale	0	0.5");
_Pragma("disablewhen	baseBump_bumpScale	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseBump_bumpScale	{ baseBumpAndNormal_type != bump }");
_Pragma("label	baseNormal_colorspace	\"Texture Color Space\"");
_Pragma("disablewhen	baseNormal_colorspace	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_colorspace	{ baseBumpAndNormal_type != normal }");
_Pragma("choice	baseNormal_colorspace	\"auto\"	\"Automatic\"");
_Pragma("choice	baseNormal_colorspace	\"linear\"	\"Linear\"");
_Pragma("label	baseNormal_wrap	Wrap");
_Pragma("hint	baseNormal_wrap	joinnext");
_Pragma("disablewhen	baseNormal_wrap	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_wrap	{ baseBumpAndNormal_type != normal }");
_Pragma("choice	baseNormal_wrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	baseNormal_wrap	\"streak\"	\"Streak\"");
_Pragma("choice	baseNormal_wrap	\"decal\"	\"Decal\"");
_Pragma("label	baseNormal_filter	Filter");
_Pragma("hint	baseNormal_filter	joinnext");
_Pragma("disablewhen	baseNormal_filter	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_filter	{ baseBumpAndNormal_type != normal }");
_Pragma("choice	baseNormal_filter	\"box\"	\"Box\"");
_Pragma("choice	baseNormal_filter	\"gauss\"	\"Gaussian\"");
_Pragma("choice	baseNormal_filter	\"bartlett\"	\"Bartlett/Triangular\"");
_Pragma("choice	baseNormal_filter	\"sinc\"	\"Sinc Sharpening\"");
_Pragma("choice	baseNormal_filter	\"hanning\"	\"Hanning\"");
_Pragma("choice	baseNormal_filter	\"blackman\"	\"Blackman\"");
_Pragma("choice	baseNormal_filter	\"catrom\"	\"Catmull-Rom\"");
_Pragma("choice	baseNormal_filter	\"mitchell\"	\"Mitchell\"");
_Pragma("label	baseNormal_filterWidth	\"Filter Width\"");
_Pragma("range	baseNormal_filterWidth	0	2");
_Pragma("disablewhen	baseNormal_filterWidth	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_filterWidth	{ baseBumpAndNormal_type != normal }");
_Pragma("label	baseNormal_channel	Channel");
_Pragma("range	baseNormal_channel	0	10");
_Pragma("disablewhen	baseNormal_channel	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_channel	{ baseBumpAndNormal_type != normal }");
_Pragma("choice	baseNormal_channel	\"0\"	\"Luminance\"");
_Pragma("choice	baseNormal_channel	\"1\"	\"Red\"");
_Pragma("choice	baseNormal_channel	\"2\"	\"Green\"");
_Pragma("choice	baseNormal_channel	\"3\"	\"Blue\"");
_Pragma("label	baseNormal_imagePlane	\"Image Plane\"");
_Pragma("disablewhen	baseNormal_imagePlane	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_imagePlane	{ baseBumpAndNormal_type != normal }");
_Pragma("label	baseNormal_texture	\"Texture Path\"");
_Pragma("hint	baseNormal_texture	image");
_Pragma("disablewhen	baseNormal_texture	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_texture	{ baseBumpAndNormal_type != normal }");
_Pragma("label	baseNormal_scale	\"Effect Scale\"");
_Pragma("range	baseNormal_scale	0	1");
_Pragma("disablewhen	baseNormal_scale	{ baseBumpAndNormal_enable == 0 }");
_Pragma("hidewhen	baseNormal_scale	{ baseBumpAndNormal_type != normal }");
_Pragma("label	uvtrans	Translate");
_Pragma("label	uvrot	Rotate");
_Pragma("range	uvrot	0	1");
_Pragma("label	uvscale	Scale");
_Pragma("label	coatBumpAndNormal_type	\"Texture Type\"");
_Pragma("disablewhen	coatBumpAndNormal_type	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("choice	coatBumpAndNormal_type	\"bump\"	\"Bump\"");
_Pragma("choice	coatBumpAndNormal_type	\"normal\"	\"Normal\"");
_Pragma("label	coatBump_colorSpace	\"Texture Color Space\"");
_Pragma("disablewhen	coatBump_colorSpace	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_colorSpace	{ coatBumpAndNormal_type != bump }");
_Pragma("choice	coatBump_colorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	coatBump_colorSpace	\"linear\"	\"Linear\"");
_Pragma("label	coatNormal_vectorSpace	\"Vector Space\"");
_Pragma("disablewhen	coatNormal_vectorSpace	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_vectorSpace	{ coatBumpAndNormal_type != normal }");
_Pragma("choice	coatNormal_vectorSpace	\"uvtangent\"	\"UV Tangent Space\"");
_Pragma("choice	coatNormal_vectorSpace	\"object\"	\"Object Space\"");
_Pragma("choice	coatNormal_vectorSpace	\"world\"	\"World Space\"");
_Pragma("label	coatBump_wrap	Wrap");
_Pragma("hint	coatBump_wrap	joinnext");
_Pragma("disablewhen	coatBump_wrap	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_wrap	{ coatBumpAndNormal_type != bump }");
_Pragma("choice	coatBump_wrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	coatBump_wrap	\"streak\"	\"Streak\"");
_Pragma("choice	coatBump_wrap	\"decal\"	\"Decal\"");
_Pragma("label	coatBump_filter	Filter");
_Pragma("hint	coatBump_filter	joinnext");
_Pragma("disablewhen	coatBump_filter	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_filter	{ coatBumpAndNormal_type != bump }");
_Pragma("choice	coatBump_filter	\"box\"	\"Box\"");
_Pragma("choice	coatBump_filter	\"gauss\"	\"Gaussian\"");
_Pragma("choice	coatBump_filter	\"bartlett\"	\"Bartlett/Triangular\"");
_Pragma("choice	coatBump_filter	\"sinc\"	\"Sinc Sharpening\"");
_Pragma("choice	coatBump_filter	\"hanning\"	\"Hanning\"");
_Pragma("choice	coatBump_filter	\"blackman\"	\"Blackman\"");
_Pragma("choice	coatBump_filter	\"catrom\"	\"Catmull-Rom\"");
_Pragma("choice	coatBump_filter	\"mitchell\"	\"Mitchell\"");
_Pragma("label	coatBump_filterWidth	\"Filter Width\"");
_Pragma("range	coatBump_filterWidth	0	2");
_Pragma("disablewhen	coatBump_filterWidth	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_filterWidth	{ coatBumpAndNormal_type != bump }");
_Pragma("label	coatBump_channel	Channel");
_Pragma("range	coatBump_channel	0	10");
_Pragma("disablewhen	coatBump_channel	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_channel	{ coatBumpAndNormal_type != bump }");
_Pragma("choice	coatBump_channel	\"0\"	\"Luminance\"");
_Pragma("choice	coatBump_channel	\"1\"	\"Red\"");
_Pragma("choice	coatBump_channel	\"2\"	\"Green\"");
_Pragma("choice	coatBump_channel	\"3\"	\"Blue\"");
_Pragma("label	coatBump_imagePlane	\"Image Plane\"");
_Pragma("disablewhen	coatBump_imagePlane	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_imagePlane	{ coatBumpAndNormal_type != bump }");
_Pragma("label	coatNormal_space	\"Normal Space\"");
_Pragma("range	coatNormal_space	0	10");
_Pragma("disablewhen	coatNormal_space	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_space	{ coatBumpAndNormal_type != normal }");
_Pragma("choice	coatNormal_space	\"0\"	\"0 to 1\"");
_Pragma("choice	coatNormal_space	\"1\"	\"-1 to 1\"");
_Pragma("label	coatNormal_flipX	\"Flip X\"");
_Pragma("hint	coatNormal_flipX	toggle");
_Pragma("disablewhen	coatNormal_flipX	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_flipX	{ coatBumpAndNormal_type != normal }");
_Pragma("label	coatNormal_flipY	\"Flip Y\"");
_Pragma("hint	coatNormal_flipY	toggle");
_Pragma("disablewhen	coatNormal_flipY	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_flipY	{ coatBumpAndNormal_type != normal }");
_Pragma("label	coatBumpAndNormal_enable	Enable");
_Pragma("hint	coatBumpAndNormal_enable	toggle");
_Pragma("disablewhen	coatBumpAndNormal_enable	{ separateCoatNormals == 0 }");
_Pragma("label	coatBump_bumpTexture	\"Texture Path\"");
_Pragma("hint	coatBump_bumpTexture	image");
_Pragma("disablewhen	coatBump_bumpTexture	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_bumpTexture	{ coatBumpAndNormal_type != bump }");
_Pragma("label	coatBump_bumpScale	\"Effect Scale\"");
_Pragma("range	coatBump_bumpScale	0	0.5");
_Pragma("disablewhen	coatBump_bumpScale	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatBump_bumpScale	{ coatBumpAndNormal_type != bump }");
_Pragma("label	coatNormal_colorspace	\"Texture Color Space\"");
_Pragma("disablewhen	coatNormal_colorspace	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_colorspace	{ coatBumpAndNormal_type != normal }");
_Pragma("choice	coatNormal_colorspace	\"auto\"	\"Automatic\"");
_Pragma("choice	coatNormal_colorspace	\"linear\"	\"Linear\"");
_Pragma("label	coatNormal_wrap	Wrap");
_Pragma("hint	coatNormal_wrap	joinnext");
_Pragma("disablewhen	coatNormal_wrap	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_wrap	{ coatBumpAndNormal_type != normal }");
_Pragma("choice	coatNormal_wrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	coatNormal_wrap	\"streak\"	\"Streak\"");
_Pragma("choice	coatNormal_wrap	\"decal\"	\"Decal\"");
_Pragma("label	coatNormal_filter	Filter");
_Pragma("hint	coatNormal_filter	joinnext");
_Pragma("disablewhen	coatNormal_filter	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_filter	{ coatBumpAndNormal_type != normal }");
_Pragma("choice	coatNormal_filter	\"box\"	\"Box\"");
_Pragma("choice	coatNormal_filter	\"gauss\"	\"Gaussian\"");
_Pragma("choice	coatNormal_filter	\"bartlett\"	\"Bartlett/Triangular\"");
_Pragma("choice	coatNormal_filter	\"sinc\"	\"Sinc Sharpening\"");
_Pragma("choice	coatNormal_filter	\"hanning\"	\"Hanning\"");
_Pragma("choice	coatNormal_filter	\"blackman\"	\"Blackman\"");
_Pragma("choice	coatNormal_filter	\"catrom\"	\"Catmull-Rom\"");
_Pragma("choice	coatNormal_filter	\"mitchell\"	\"Mitchell\"");
_Pragma("label	coatNormal_filterWidth	\"Filter Width\"");
_Pragma("range	coatNormal_filterWidth	0	2");
_Pragma("disablewhen	coatNormal_filterWidth	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_filterWidth	{ coatBumpAndNormal_type != normal }");
_Pragma("label	coatNormal_channel	Channel");
_Pragma("range	coatNormal_channel	0	10");
_Pragma("disablewhen	coatNormal_channel	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_channel	{ coatBumpAndNormal_type != normal }");
_Pragma("choice	coatNormal_channel	\"0\"	\"Luminance\"");
_Pragma("choice	coatNormal_channel	\"1\"	\"Red\"");
_Pragma("choice	coatNormal_channel	\"2\"	\"Green\"");
_Pragma("choice	coatNormal_channel	\"3\"	\"Blue\"");
_Pragma("label	coatNormal_imagePlane	\"Image Plane\"");
_Pragma("disablewhen	coatNormal_imagePlane	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_imagePlane	{ coatBumpAndNormal_type != normal }");
_Pragma("label	coatNormal_texture	\"Texture Path\"");
_Pragma("hint	coatNormal_texture	image");
_Pragma("disablewhen	coatNormal_texture	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_texture	{ coatBumpAndNormal_type != normal }");
_Pragma("label	coatNormal_scale	\"Effect Scale\"");
_Pragma("range	coatNormal_scale	0	1");
_Pragma("disablewhen	coatNormal_scale	{ coatBumpAndNormal_enable == 0 } { separateCoatNormals == 0 }");
_Pragma("hidewhen	coatNormal_scale	{ coatBumpAndNormal_type != normal }");
_Pragma("label	sssdist_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	sssdist_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	sssdist_textureColorSpace	{ sssdist_useTexture == 0 }");
_Pragma("choice	sssdist_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	sssdist_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	sssdist_monoChannel	Channel");
_Pragma("hint	sssdist_monoChannel	joinnext");
_Pragma("range	sssdist_monoChannel	0	10");
_Pragma("disablewhen	sssdist_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sssdist_monoChannel	{ sssdist_useTexture == 0 }");
_Pragma("choice	sssdist_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	sssdist_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	sssdist_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	sssdist_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	sssdist_useTexture	\"Use Texture\"");
_Pragma("hint	sssdist_useTexture	toggle");
_Pragma("disablewhen	sssdist_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	sssdist_texture	Texture");
_Pragma("hint	sssdist_texture	image");
_Pragma("disablewhen	sssdist_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sssdist_texture	{ sssdist_useTexture == 0 }");
_Pragma("label	sssdist_textureWrap	Wrap");
_Pragma("hint	sssdist_textureWrap	joinnext");
_Pragma("disablewhen	sssdist_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	sssdist_textureWrap	{ sssdist_useTexture == 0 }");
_Pragma("choice	sssdist_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	sssdist_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	sssdist_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	sssdist	\"Subsurface Distance\"");
_Pragma("range	sssdist	0	1");
_Pragma("hidewhen	sssdist	{ useBaseColor == 0 }");
_Pragma("label	ssscolor_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	ssscolor_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	ssscolor_textureColorSpace	{ ssscolor_useTexture == 0 }");
_Pragma("choice	ssscolor_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	ssscolor_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	ssscolor_useTexture	\"Use Texture\"");
_Pragma("hint	ssscolor_useTexture	toggle");
_Pragma("disablewhen	ssscolor_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	ssscolor_texture	Texture");
_Pragma("hint	ssscolor_texture	image");
_Pragma("disablewhen	ssscolor_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	ssscolor_texture	{ ssscolor_useTexture == 0 }");
_Pragma("label	ssscolor_textureWrap	Wrap");
_Pragma("hint	ssscolor_textureWrap	joinnext");
_Pragma("disablewhen	ssscolor_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	ssscolor_textureWrap	{ ssscolor_useTexture == 0 }");
_Pragma("choice	ssscolor_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	ssscolor_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	ssscolor_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	ssscolor	\"Subsurface Color\"");
_Pragma("hint	ssscolor	color");
_Pragma("hidewhen	ssscolor	{ useBaseColor == 0 }");
_Pragma("label	ssslabel	Subsurface");
_Pragma("label	layer	\"\"");
_Pragma("hint	layer	invisible");
#line 732 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
_Pragma("label	Oc	\"\"");
_Pragma("hint	Oc	invisible");
_Pragma("label	Cv	\"\"");
_Pragma("hint	Cv	invisible");
_Pragma("label	Th	\"\"");
_Pragma("hint	Th	invisible");
_Pragma("label	Ab	\"\"");
_Pragma("hint	Ab	invisible");
_Pragma("label	Cu	\"\"");
_Pragma("hint	Cu	invisible");
_Pragma("label	Vd	\"\"");
_Pragma("hint	Vd	invisible");
_Pragma("label	Nt	\"\"");
_Pragma("hint	Nt	invisible");
_Pragma("label	Ds	\"\"");
_Pragma("hint	Ds	invisible");
_Pragma("label	Vdt	\"\"");
_Pragma("hint	Vdt	invisible");


_Pragma("label	direct	\"\"");
_Pragma("hint	direct	invisible");
_Pragma("label	indirect	\"\"");
_Pragma("hint	indirect	invisible");
_Pragma("label	Ce	\"\"");
_Pragma("hint	Ce	invisible");
_Pragma("label	direct_emission	\"\"");
_Pragma("hint	direct_emission	invisible");
_Pragma("label	all_emission	\"\"");
_Pragma("hint	all_emission	invisible");
_Pragma("label	all	\"\"");
_Pragma("hint	all	invisible");
_Pragma("label	indirect_emission	\"\"");
_Pragma("hint	indirect_emission	invisible");
_Pragma("label	direct_comp	\"\"");
_Pragma("hint	direct_comp	invisible");
_Pragma("label	indirect_comp	\"\"");
_Pragma("hint	indirect_comp	invisible");
_Pragma("label	all_comp	\"\"");
_Pragma("hint	all_comp	invisible");
_Pragma("label	direct_noshadow	\"\"");
_Pragma("hint	direct_noshadow	invisible");
_Pragma("label	direct_shadow	\"\"");
_Pragma("hint	direct_shadow	invisible");
_Pragma("label	indirect_noshadow	\"\"");
_Pragma("hint	indirect_noshadow	invisible");
_Pragma("label	indirect_shadow	\"\"");
_Pragma("hint	indirect_shadow	invisible");
_Pragma("label	level	\"\"");
_Pragma("hint	level	invisible");
_Pragma("range	level	0	1");
_Pragma("label	diffuselevel	\"\"");
_Pragma("hint	diffuselevel	invisible");
_Pragma("range	diffuselevel	0	1");
_Pragma("label	specularlevel	\"\"");
_Pragma("hint	specularlevel	invisible");
_Pragma("range	specularlevel	0	1");
_Pragma("label	volumelevel	\"\"");
_Pragma("hint	volumelevel	invisible");
_Pragma("range	volumelevel	0	1");
_Pragma("label	direct_samples	\"\"");
_Pragma("hint	direct_samples	invisible");
_Pragma("range	direct_samples	0	1");
_Pragma("label	indirect_samples	\"\"");
_Pragma("hint	indirect_samples	invisible");
_Pragma("range	indirect_samples	0	1");
_Pragma("label	nlights	\"\"");
_Pragma("hint	nlights	invisible");
_Pragma("range	nlights	0	1");
_Pragma("label	direct_noshadow_comp	\"\"");
_Pragma("hint	direct_noshadow_comp	invisible");
_Pragma("label	indirect_noshadow_comp	\"\"");
_Pragma("hint	indirect_noshadow_comp	invisible");
_Pragma("label	nddispersion	\"\"");
_Pragma("hint	nddispersion	invisible");
_Pragma("range	nddispersion	0	1");
_Pragma("label	ndpriority	\"\"");
_Pragma("hint	ndpriority	invisible");
_Pragma("range	ndpriority	0	1");
_Pragma("label	ndior	\"\"");
_Pragma("hint	ndior	invisible");
_Pragma("range	ndior	0	1");
_Pragma("label	absorption	\"\"");
_Pragma("hint	absorption	invisible");
_Pragma("label	reflect_textureColorSpace	\"Source Color Space\"");
_Pragma("disablewhen	reflect_textureColorSpace	{ refl_enable == 0 }");
_Pragma("hidewhen	reflect_textureColorSpace	{ reflect_useTexture == 0 }");
_Pragma("choice	reflect_textureColorSpace	\"auto\"	\"Automatic\"");
_Pragma("choice	reflect_textureColorSpace	\"linear\"	\"Linear\"");
_Pragma("label	reflect_monoChannel	Channel");
_Pragma("hint	reflect_monoChannel	joinnext");
_Pragma("range	reflect_monoChannel	0	10");
_Pragma("disablewhen	reflect_monoChannel	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	reflect_monoChannel	{ reflect_useTexture == 0 }");
_Pragma("choice	reflect_monoChannel	\"0\"	\"Luminance\"");
_Pragma("choice	reflect_monoChannel	\"1\"	\"Red\"");
_Pragma("choice	reflect_monoChannel	\"2\"	\"Green\"");
_Pragma("choice	reflect_monoChannel	\"3\"	\"Blue\"");
_Pragma("label	reflect_useTexture	\"Use Texture\"");
_Pragma("hint	reflect_useTexture	toggle");
_Pragma("disablewhen	reflect_useTexture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("label	reflect_texture	Texture");
_Pragma("hint	reflect_texture	image");
_Pragma("disablewhen	reflect_texture	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	reflect_texture	{ reflect_useTexture == 0 }");
_Pragma("label	reflect_textureWrap	Wrap");
_Pragma("hint	reflect_textureWrap	joinnext");
_Pragma("disablewhen	reflect_textureWrap	{ refl_enable == 0 } { refl_lights == 0 refl_objs == 0 }");
_Pragma("hidewhen	reflect_textureWrap	{ reflect_useTexture == 0 }");
_Pragma("choice	reflect_textureWrap	\"repeat\"	\"Repeat\"");
_Pragma("choice	reflect_textureWrap	\"streak\"	\"Streak\"");
_Pragma("choice	reflect_textureWrap	\"decal\"	\"Decal\"");
_Pragma("label	reflect	Reflectivity");
_Pragma("range	reflect	0	1");
_Pragma("hidewhen	reflect	{ useBaseColor == 0 }");

_Pragma("label	baseN	\"\"");
_Pragma("hint	baseN	direction");
_Pragma("hint	baseN	invisible");
_Pragma("label	coatN	\"\"");
_Pragma("hint	coatN	direction");
_Pragma("hint	coatN	invisible");
_Pragma("label	coatlightcull	\"Coat Light Cull\"");
_Pragma("range	coatlightcull	0	1");

_Pragma("label	top_layer_ior	\"Top Layer IOR\"");
_Pragma("range	top_layer_ior	0	2");
_Pragma("parmhelp	top_layer_ior	'If index of refraction is 1, there is no top layer'");





#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 22 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
struct ShaderExports
{
    string	names_f[];
    float	values_f[];
    string	names_v[];
    vector	values_v[];
    string	names_v4[];
    vector4	values_v4[];
}

struct ShaderLayer
{
    bsdf	    F;
    vector	    Of;
    vector	    Ce;
    vector	    P;
    vector	    N;
    float	    layeralpha;
    float	    thickness;
    vector	    absorption;
    float	    masks[];
    ShaderExports   exports;
}

void init_layerexports(export ShaderExports exports)
{
    exports.names_f = {};
    exports.values_f = {};
    exports.names_v = {};
    exports.values_v = {};
    exports.names_v4 = {};
    exports.values_v4 = {};
}

void init_layer(export ShaderLayer layer)
{
    layer.F = bsdf();
    layer.Of = {1,1,1};
    layer.Ce = {0,0,0};
    layer.P = P;
    layer.N = normalize(N);
    layer.layeralpha = 1.0;
    layer.masks = {};
    init_layerexports(layer.exports);
}
#line 135 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
void comp_export_arrays_aoverb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a+(1-Aa)*Ba*val_b); } } void comp_export_arrays_ainsideb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba); } } void comp_export_arrays_aoutsideb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba)); } } void comp_export_arrays_aatopb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba + Ba*val_b*(1-Aa)); } } void comp_export_arrays_axorb(const string names_a[]; const float vals_a[]; const float Aa; const string names_b[]; const float vals_b[]; const float Ba; string out_names[]; float out_values[]) { float val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba) + Ba*val_b*(1-Aa)); } }
void comp_export_arrays_aoverb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a+(1-Aa)*Ba*val_b); } } void comp_export_arrays_ainsideb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba); } } void comp_export_arrays_aoutsideb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba)); } } void comp_export_arrays_aatopb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba + Ba*val_b*(1-Aa)); } } void comp_export_arrays_axorb(const string names_a[]; const vector vals_a[]; const float Aa; const string names_b[]; const vector vals_b[]; const float Ba; string out_names[]; vector out_values[]) { vector val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba) + Ba*val_b*(1-Aa)); } }
void comp_export_arrays_aoverb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a+(1-Aa)*Ba*val_b); } } void comp_export_arrays_ainsideb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba); } } void comp_export_arrays_aoutsideb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba)); } } void comp_export_arrays_aatopb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*Ba + Ba*val_b*(1-Aa)); } } void comp_export_arrays_axorb(const string names_a[]; const vector4 vals_a[]; const float Aa; const string names_b[]; const vector4 vals_b[]; const float Ba; string out_names[]; vector4 out_values[]) { vector4 val_a, val_b; int done_in_b[]; foreach(int index_a; string name_a; names_a) { int index_b = index_a; if (names_b[index_b] != name_a) index_b = find(names_b, name_a); int found = index_b >= 0; val_b = select(found, vals_b[index_b], 0.0); append(out_names, name_a); append(out_values, Aa*vals_a[index_a]+(1-Aa)*Ba*val_b); done_in_b[index_b] = found; } foreach(int index_b; string name_b; names_b) { if(done_in_b[index_b]) continue; val_a = 0.0; val_b = vals_b[index_b]; append(out_names, name_b); append(out_values, Aa*val_a*(1-Ba) + Ba*val_b*(1-Aa)); } }
#line 160 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
void composite_exports_aoverb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_aoverb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_aoverb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_aoverb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_ainsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_ainsideb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_ainsideb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_ainsideb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_aoutsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_aoutsideb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_aoutsideb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_aoutsideb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_aatopb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_aatopb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_aatopb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_aatopb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
void composite_exports_axorb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba; ShaderLayer out) { out.exports.names_f = {}; out.exports.values_f = {}; out.exports.names_v = {}; out.exports.values_v = {}; out.exports.names_v4 = {}; out.exports.values_v4 = {}; comp_export_arrays_axorb(A.exports.names_f, A.exports.values_f, Aa, B.exports.names_f, B.exports.values_f, Ba, out.exports.names_f, out.exports.values_f); comp_export_arrays_axorb(A.exports.names_v, A.exports.values_v, Aa, B.exports.names_v, B.exports.values_v, Ba, out.exports.names_v, out.exports.values_v); comp_export_arrays_axorb(A.exports.names_v4, A.exports.values_v4, Aa, B.exports.names_v4, B.exports.values_v4, Ba, out.exports.names_v4, out.exports.values_v4); }
#line 200 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
ShaderLayer composite_aoverb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F+(1-Aa)*Ba*B.F; C.Of = Aa*A.Of+(1-Aa)*Ba*B.Of; C.Ce = Aa*A.Ce+(1-Aa)*Ba*B.Ce; C.P = Aa*A.P+(1-Aa)*Ba*B.P; C.N = normalize(Aa*A.N+(1-Aa)*Ba*B.N); C.layeralpha = Aa+(1-Aa)*Ba; composite_exports_aoverb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a+(1-Aa)*Ba*mask_b; } return C; } ShaderLayer composite_aoverb(const ShaderLayer A; const ShaderLayer B) { return composite_aoverb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_ainsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*Ba; C.Of = Aa*A.Of*Ba; C.Ce = Aa*A.Ce*Ba; C.P = Aa*A.P*Ba; C.N = normalize(Aa*A.N*Ba); C.layeralpha = Aa*Ba; composite_exports_ainsideb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*Ba; } return C; } ShaderLayer composite_ainsideb(const ShaderLayer A; const ShaderLayer B) { return composite_ainsideb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_aoutsideb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*(1-Ba); C.Of = Aa*A.Of*(1-Ba); C.Ce = Aa*A.Ce*(1-Ba); C.P = Aa*A.P*(1-Ba); C.N = normalize(Aa*A.N*(1-Ba)); C.layeralpha = Aa*(1-Ba); composite_exports_aoutsideb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*(1-Ba); } return C; } ShaderLayer composite_aoutsideb(const ShaderLayer A; const ShaderLayer B) { return composite_aoutsideb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_aatopb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*Ba + Ba*B.F*(1-Aa); C.Of = Aa*A.Of*Ba + Ba*B.Of*(1-Aa); C.Ce = Aa*A.Ce*Ba + Ba*B.Ce*(1-Aa); C.P = Aa*A.P*Ba + Ba*B.P*(1-Aa); C.N = normalize(Aa*A.N*Ba + Ba*B.N*(1-Aa)); C.layeralpha = Ba; composite_exports_aatopb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*Ba + Ba*mask_b*(1-Aa); } return C; } ShaderLayer composite_aatopb(const ShaderLayer A; const ShaderLayer B) { return composite_aatopb(A, A.layeralpha, B, B.layeralpha); }
ShaderLayer composite_axorb(const ShaderLayer A; const float Aa; const ShaderLayer B; const float Ba) { ShaderLayer C; C.masks = {}; C.F = Aa*A.F*(1-Ba) + Ba*B.F*(1-Aa); C.Of = Aa*A.Of*(1-Ba) + Ba*B.Of*(1-Aa); C.Ce = Aa*A.Ce*(1-Ba) + Ba*B.Ce*(1-Aa); C.P = Aa*A.P*(1-Ba) + Ba*B.P*(1-Aa); C.N = normalize(Aa*A.N*(1-Ba) + Ba*B.N*(1-Aa)); C.layeralpha = Aa+Ba-2*(Aa*Ba); composite_exports_axorb(A, Aa, B, Ba, C); int nummasks_a = len(A.masks); int nummasks_b = len(B.masks); int maxmasks = max(nummasks_a, nummasks_b); for(int i=0; i<maxmasks; i++) { float mask_a = select(i<nummasks_a, A.masks[i], 0.0); float mask_b = select(i<nummasks_b, B.masks[i], 0.0); C.masks[i] = Aa*mask_a*(1-Ba) + Ba*mask_b*(1-Aa); } return C; } ShaderLayer composite_axorb(const ShaderLayer A; const ShaderLayer B) { return composite_axorb(A, A.layeralpha, B, B.layeralpha); }
#line 216 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
void set_layer_export(ShaderLayer layer; string name; float value) { int index = find(layer.exports.names_f, name); if(index < 0) index = len(layer.exports.names_f); layer.exports.names_f[index] = name; layer.exports.values_f[index] = value; }
void set_layer_export(ShaderLayer layer; string name; vector value) { int index = find(layer.exports.names_v, name); if(index < 0) index = len(layer.exports.names_v); layer.exports.names_v[index] = name; layer.exports.values_v[index] = value; }
void set_layer_export(ShaderLayer layer; string name; vector4 value) { int index = find(layer.exports.names_v4, name); if(index < 0) index = len(layer.exports.names_v4); layer.exports.names_v4[index] = name; layer.exports.values_v4[index] = value; }
#line 865 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 867 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 45 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shading.h"
#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 22 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shading.h"
#line 36 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shading.h"
vector
shading_computeEnvAngleScale(vector dir; vector axis; float anglescale)
{
    vector	ndir;

    if (anglescale != 1)
    {
	float	zangle = acos(dir.z);
	vector	raxis;
	matrix3	rmat;

	raxis = normalize(cross(axis, dir));
	if (anglescale > 0)
	{
	    zangle /= anglescale;
	    zangle = clamp(zangle, 0.0, 3.1415926);
	}
	else
	    zangle = 3.1415926;

	rmat = ident();
	rotate(rmat, zangle, raxis);

	ndir = axis * rmat;
    }
    else
	ndir = dir;

    return ndir;
}


vector fresnelcond_nmin(vector r)
{
    return (1-r)/(1+r);
}

vector fresnelcond_nmax(vector r)
{
    return (1+sqrt(r))/(1-sqrt(r));
}

vector fresnelcond_eta(vector r, g)
{
    return fresnelcond_nmin(r)*g + (1-g)*fresnelcond_nmax(r);
}

vector fresnelcond_kappa2(vector r, n)
{
    vector nr = (n+1)*(n+1)*r-(n-1)*(n-1);
    return nr/(1-r);
}

vector fresnelcond_reflectivity(vector n, k)
{
    return ((n-1)*(n-1)+k*k)/((n+1)*(n+1)+k*k);
}

vector fresnelcond_edgetint(vector n, r)
{
    return (fresnelcond_nmax(r)-n)/(fresnelcond_nmax(r)-fresnelcond_nmin(r));
}


vector fresnelcond_artistic(vector nI, nN, r, g)
{
    float dotNI = clamp(dot(nN, -nI), 0, 0.999);

    vector n = fresnelcond_eta(r, g);
    vector k2 = fresnelcond_kappa2(r, n);

    vector rs_num = n*n + k2 - 2*n*dotNI + dotNI*dotNI;
    vector rs_den = n*n + k2 + 2*n*dotNI + dotNI*dotNI;
    vector rs = rs_num/rs_den;

    vector rp_num = (n*n + k2)*dotNI*dotNI - 2*n*dotNI + 1;
    vector rp_den = (n*n + k2)*dotNI*dotNI + 2*n*dotNI + 1;
    vector rp = rp_num/rp_den;

    return 0.5*(rs+rp);
}




vector fresnelcond_physical(vector nI, nN, eta, kappa)
{
    float dotNI = clamp(dot(nN, -nI), 0, 0.999);

    vector tmp = (eta*eta + kappa*kappa) * dotNI*dotNI;
    vector Rparl2 = (tmp - (2.0f * eta * dotNI) + 1) /
                    (tmp + (2.0f * eta * dotNI) + 1);
    vector tmp_f = eta*eta + kappa*kappa;
    vector Rperp2 = (tmp_f - (2.0f * eta * dotNI) + dotNI*dotNI) /
                    (tmp_f + (2.0f * eta * dotNI) + dotNI*dotNI);
    return 0.5 * (Rparl2 + Rperp2);
}

void thinfresnel(const vector nI, nN; const float eta; export float kr, kt)
{
    float kr1, kt1;
    vector R1, T1;
    fresnel(nI, nN, eta, kr1, kt1, R1, T1);

    float kr2, kt2;
    vector R2, T2;
    fresnel(T1, nN, eta, kr2, kt2);

    float tmp = 1.0/(1 - kr2*kr2);
    kr = kr1 + (kt1*kr2*kt2) * tmp;
    kt = kt1*kt2*tmp;
}

void thinfresnel(const vector nI, nN; const float eta; export float kr, kt; export vector R, T)
{
    thinfresnel(nI, nN, eta, kr, kt);

    R = reflect(nI, nN);
    T = nI;
}


float
dirtmask_dome(vector P;
	 vector nN;
	 int inSID;
	 int	samples;
	 float  maxdist;
	 vector biasdir;
	 float  bias;
	 string scope)
{
    int hit, found;
    float dist;
    vector localdir, dir, hitP, hitN;

    vector u = normalize(set(nN.z, nN.z, -nN.x-nN.y));
    vector v = normalize(cross(nN, u));
    matrix3 space = set(u, v, nN);

    float _maxdist;
    vector _biasdir = biasdir;
    _biasdir = ntransform("space:world", "space:current", _biasdir);
    _biasdir = normalize(select(bias >= 0, -_biasdir, _biasdir));
    float _bias = abs(bias);

    int hits = 0;
    vector2 sample;

    float raybias;
    found = renderstate("renderer:raybias", raybias);
    raybias = select(found, raybias, 1e-3);

    string rengine;
    renderstate("renderer:renderengine", rengine);
    int israytrace = rengine == "raytrace" || rengine == "pbrraytrace";
    int sid = israytrace ? inSID : newsampler();

    for(int i=0; i<samples; i++)
    {
	if (israytrace)
	    nextsample(sid, sample.x, sample.y, "mode", "nextpixel");
	else
	    nextsample(sid, sample.x, sample.y, "mode", "qstrat");

	float phi = 2.0*3.1415926*sample.x;
	float theta = asin(sqrt(sample.y));

	localdir.x = cos(theta) * sin(phi);
	localdir.y = cos(theta) * cos(phi);
	localdir.z = sin(theta);
	dir = localdir * space;

	float dotbias = dot(dir, _biasdir);
	float dotNB = dot(nN, _biasdir);
	_biasdir = _biasdir - clamp(dotNB, -1, 0) * nN;
	dir += _bias * clamp(dotbias, 0, 1) * _biasdir;
	dir *= fit(dotbias, -2, 1, 1.0/(1.0+_bias), 1);

	vector testNg = select(dot(nN, Ng) > 0.0, Ng, -Ng);
	if (dot(dir, testNg) < 1e-5)
		continue;

	dist = rayhittest(P, maxdist * dir, hitP, hitN, raybias, "scope", scope);
	hit = dist >= 0.0;

	hits += hit;
    }

    return (float)hits/samples;
}

float
dirtmask_fan(vector P;
	 vector nN;
	 int inSID;
	 float  sensitivity;
	 int	samples;
	 float  maxdist;
	 vector biasdir;
	 float  bias;
	 string scope)
 {
    int hit, found;
    float dist;
    vector localdir, dir, hitP, hitN;

    vector u = normalize(set(nN.z, nN.z, -nN.x-nN.y));
    vector v = normalize(cross(nN, u));
    matrix3 space = set(u, v, nN);

    float max_dirt = 0.0;

    vector2 sample;
    float _maxdist;
    vector _biasdir = normalize(select(bias >= 0, -biasdir, biasdir));
    _biasdir = ntransform("space:world", "space:current", _biasdir);
    float _bias = abs(bias);

    float raybias;
    found = renderstate("renderer:raybias", raybias);
    raybias = select(found, raybias, 1e-3);

    string rengine;
    renderstate("renderer:renderengine", rengine);
    int israytrace = rengine == "raytrace" || rengine == "pbrraytrace";
    int sid = israytrace ? inSID : newsampler();

    for(int i=0; i<samples; i++)
    {
	if (israytrace)
	    nextsample(sid, sample.x, sample.y, "mode", "nextpixel");
	else
	    nextsample(sid, sample.x, sample.y, "mode", "qstrat");

	float phi = 2.0 * 3.1415926 * sample.x;
	float theta = 0.5*3.1415926*sensitivity;

	localdir.x = cos(phi);
	localdir.y = sin(phi);
	localdir.z = 0;

	dir = localdir * space;

	float dotNB = dot(nN, _biasdir);
	_biasdir = _biasdir - dotNB * nN;
	float dotbias = dot(dir, normalize(_biasdir));
	dir += _bias * clamp(dotbias, 0, 1) * _biasdir;
	dir *= fit(dotbias, -2, 1, 1.0/(1.0+_bias), 1);

	float len = length(dir);
	dir *= sin(theta);
	dir += fit01(sin(theta), 1, len) * cos(theta) * nN;

	dist = rayhittest(P, maxdist * dir, hitP, hitN, raybias, "scope", scope);

	hit = dist >= 0.0;

	float dirt = clamp(1.0 - dist / (maxdist * length(dir)), 0, 1);
	max_dirt = select(hit, max(dirt, max_dirt), max_dirt);
    }

    return max_dirt;
}
#line 46 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 97 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
float
vop_grandom(float u0, u1; float sigma)
{



    return cos(u0 * (3.1415926*2)) * sqrt(-2 * log(u1)) * sigma;
}
float
vop_grandom(int seed; float sigma)
{
    float	u0 = random(seed);
    float	u1 = random(seed*3929 + 48311);
    return vop_grandom(u0, u1, sigma);
}

float
vop_gnrandom(float sigma)
{
    float	u0 = nrandom();
    float	u1 = nrandom();
    return vop_grandom(u0, u1, sigma);
}

vector
vop_grandom(int seed; float sigma)
{


    float	x = float(vop_grandom(seed, sigma));
    float	y = float(vop_grandom(seed*17 + 97, sigma));
    float	z = float(vop_grandom(seed*29 + 383, sigma));
    return set(x, y, z);
}

vector
vop_gnrandom(float sigma)
{


    float	x = float(vop_gnrandom(sigma));
    float	y = float(vop_gnrandom(sigma));
    float	z = float(vop_gnrandom(sigma));
    return set(x, y, z);
}

void
vop_bindST(float news, ss; int isSConnected;
	   float newt, tt; int isTConnected)
{







    news = isSConnected ? ss : s;
    newt = isTConnected ? tt : t;




}

void
vop_bindS(float news, ss; int isSConnected)
{





    news = isSConnected ? ss : s;



}

void
vop_bindU(export float newu; const float u; int isUVConnected)
{





    newu = isUVConnected ? u : s;



}

void
vop_bindUV(export vector2 newuv; const vector2 uv; int isUVConnected)
{





    newuv = isUVConnected ? uv : set(s, t);



}

void
vop_bindUV(export vector newuv; const vector uv; int isUVConnected)
{





    newuv = isUVConnected ? uv : set(s, t, 0);



}




float
vop_bias(float base, bias)
{
    float val;
    if (base <= 0)
	val = 0;
    else if (base >= 1)
	val = 1;
    else
	val = bias / (((1.0 / base) - 2) * (1 - bias) + 1);
    return val;
}

float
vop_gain(float base, gain)
{
    float	val;
    if (base < 0.5)
	val = vop_bias(2*base, gain)*.5;
    else
	val = 1-vop_bias(2*(1-base), gain)*.5;
    return val;
}

vector
vop_colorLinearTransform(vector C;
                         string fromSpace;)
{
    vector Ct = C;

    if (fromSpace == "srgb")
    {
        for (int i = 0; i < 3; i++)
        {
            if (C[i] <= 0.04045) Ct[i] = C[i] / 12.92;
            else Ct[i] = pow((C[i] + 0.055) / 1.055, 2.4);
        }
    }

    else if (fromSpace == "linear")
    {
        for (int i = 0; i < 3; i++)
        {
            if (C[i] <= 0.0031308) Ct[i] = C[i] * 12.92;
            else Ct[i] = 1.055 * pow(C[i], 1.0/2.4) - 0.055;
        }
    }

    return Ct;
}

vector
vop_colormix(vector c1, c2; float bias; int adjust)
{
    vector	clr;
    if (adjust == 3)
	clr = cspline(bias, c1, c1, c2, c2);
    else if (adjust == 2)
	clr = lerp(c1, c2, float(smooth(0, 1, bias)));
    else if (adjust == 1)
	clr = lerp(c1, c2, float(clamp(bias, 0, 1)));
    else
	clr = lerp(c1, c2, bias);
    return clr;
}

void
vop_composite(string operation;
	      vector C; float Ca;
	      vector A; float Aa;
	      vector B; float Ba;
	     )
{
    if (operation == "AoverB")
    {
	C  = A  + (1-Aa)*B;
	Ca = Aa + (1-Aa)*Ba;
    }
    else if (operation == "AinsideB")
    {
	C  = A*Ba;
	Ca = Aa*Ba;
    }
    else if (operation == "AoutsideB")
    {
	C  = A*(1-Ba);
	Ca = Aa*(1-Ba);
    }
    else if (operation == "AatopB")
    {
	C  = A*Ba + B*(1-Aa);
	Ca = Ba;
    }
    else if (operation == "AxorB")
    {
	C  = A*(1-Ba) + B*(1-Aa);
	Ca = Aa + Ba - 2*(Aa*Ba);
    }
    else if (operation == "A")
    {
	C  = A;
	Ca = Aa;
    }
    else if (operation == "B")
    {
	C  = B;
	Ca = Ba;
    }
    else if (operation == "clear")
    {
	C = 0;
	Ca = 0;
    }
}

float
vop_ptlined(vector P1, P2, Q)
{
    return ptlined(P1, P2, Q);
}


float
vop_FilterWidth(float x)
{

    float du = Du(x);
    float dv = Dv(x);
    return max(sqrt(du*du + dv*dv), 1e-6);




}



float
vop_FilterAngle(vector dir)
{
    vector	du, dv;
    vector	a, b, c, d;
    vector	ac, bd;
    float	angle;

    du = 0.5*Du(dir);
    dv = 0.5*Dv(dir);

    a = dir-du-dv;
    b = dir+du-dv;
    c = dir+du+dv;
    d = dir-du+dv;

    ac = cross(a, c) / sqrt(length2(a)*length2(c));
    bd = cross(b, d) / sqrt(length2(b)*length2(d));
    angle = 0.5 * length(cross(ac, bd));

    return acos(1 - (0.5 / 3.1415926) * angle);
}

float
vop_Pulse(float edge0, edge1, x, fwidth; string filter)
{
    float	x0, x1;

    x0 = x  - fwidth*.5;
    x1 = x0 + fwidth;
    return max(0, (min(x1, edge1)-max(x0, edge0))/fwidth);
}

float
vop_FilteredSin(float x, fwidth)
{
    float	x0, x1;

    x0 = x - fwidth * .5;
    x1 = x + fwidth;
    return (-0.7071067)*lerp((cos(x1)-cos(x0))/fwidth, 0, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_FilteredSinD(float x)
{
    return vop_FilteredSin(x, vop_FilterWidth(x));
}

float
vop_FilteredCos(float x, fwidth)
{
    float	x0, x1;

    x0 = x - fwidth * .5;
    x1 = x + fwidth;
    return 0.7071067*lerp((sin(x1)-sin(x0))/fwidth, 0, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_FilteredCosD(float x)
{
    return vop_FilteredCos(x, vop_FilterWidth(x));
}

float
vop_PulseD(float edge0, edge1, x; string filter)
{
    return vop_Pulse(edge0, edge1, x, vop_FilterWidth(x), filter);
}

float
vop_PulseTrain(float edge0, x, fwidth)
{
    float	x0, x1;

    x0 = x  - fwidth*.5;
    x1 = x0 + fwidth;
    x0 = edge0*floor(x0) + min(edge0, frac(x0));
    x1 = edge0*floor(x1) + min(edge0, frac(x1));
    return lerp((x1-x0)/fwidth, edge0, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_PulseTrainD(float edge0, x)
{
    return vop_PulseTrain(edge0, x, vop_FilterWidth(x));
}

float
vop_RampTrain(float x, fwidth)
{
    float	x0, x1, f;
    x0 = x - fwidth*.5;
    x1 = x0 + fwidth;
    f = frac(x0); x0 = float(floor(x0)) + f*f;
    f = frac(x1); x1 = float(floor(x1)) + f*f;
    return .5*lerp((x1-x0)/fwidth, .5, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_RampTrainD(float x)
{
    return vop_RampTrain(x, vop_FilterWidth(x));
}

float
vop_IntegrateTent(float x)
{
    float	f;
    f = frac(x);
    if (f > .5) f = f*(2 - f) - .5;
    else	f = f*f;
    return .5*floor(x) + f;
}

float
vop_TentTrain(float x, fwidth)
{
    float	x0, x1;
    x0 = x - fwidth*.5;
    x1 = x0 + fwidth;
    x0 = vop_IntegrateTent(x0);
    x1 = vop_IntegrateTent(x1);
    return lerp((x1-x0)/fwidth, .5, clamp(fwidth*(1.0/8.0), 0, 1));;
}

float
vop_TentTrainD(float x)
{
    return vop_RampTrain(x, vop_FilterWidth(x));
}

float
vop_DotStamp(float px, py, fwidth; string filter)
{
    float	d;
    d = px*px + py*py;
    return filterstep(1,d-fwidth,d+fwidth,"filter",filter);
}

float
vop_BumpStamp(float px, py, fwidth; string filter)
{
    float d  = px*px + py*py;
    return 1-smooth(0.0, 1.0, d);
}

float
vop_RoundCosStamp(float px, py, fwidth; float hexness, sides, power;
		    string filter)
{
    float	ss, tt;
    float	x0, x1;

    ss = atan(py, px);
    tt = px*px + py*py + hexness*pow(abs(1-cos(ss*(sides))), power);
    x0 = tt - fwidth*.5;
    x1 = x0 + fwidth;
    return filterstep(1,x0,x1,"filter",filter);
}

float
vop_RoundSinStamp(float px, py, fwidth; float hexness, sides, power;
		    string filter)
{
    float	ss, tt;
    float	x0, x1;

    ss = atan(py, px) - 3.1415926;
    tt = px*px + py*py + hexness*pow(abs(1-sin(ss*(sides))), power);
    x0 = tt - fwidth*.5;
    x1 = x0 + fwidth;
    return filterstep(1,x0,x1,"filter",filter);
}


float
vop_RingStamp(float px, py, iradius, oradius, fwidth; string filter)
{
    float	d;
    d = px*px + py*py;
    return vop_Pulse(iradius, oradius, d, fwidth, filter);
}

float
vop_BoxStamp(float px, py, fu, fv; string filter)
{
    float	dx;
    dx  = vop_Pulse(-1, 1, px, fu, filter);
    dx *= vop_Pulse(-1, 1, py, fv, filter);
    return dx;
}
#line 563 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
int
vop_TileGen(float u, v; float fx, fy, ox, oy, stagger, jitter)
{
    int		row;

    v = v*fy - oy;
    row = floor(v);
    u = u*fx - ox - stagger*row + jitter*random(row);
    return floor(u) + row*1984;
}

int
vop_HexTileGen(float u, v; float fx, fy, ox, oy)
{
    float	left, right;
    int		row, col;

    v   = v*fy - oy;
    row = floor(v);
    v  = frac(v);

    u = u*fx + ox;
    if (row & 1)
	u += .5;

    col = floor(u);
    u = frac(u);

    if (v > .5)
    {
	right = v - .5;
	left  = 1.5 - v;
	if (u > left)
	{
	    if (!(row & 1)) col++;
	    row++;
	    v -= 1;
	    u = fit(u, left, 1, 0, .5);
	}
	else if (u < right)
	{
	    if (row & 1) col--;
	    row++;
	    v -= 1;
	    u = fit(u, 0, right, 0.5, 1);
	}
	else u = fit(u, right, left, 0, 1);
    }
    v = (v*2+1)/3;
    return row * 938 + col;
}
#line 628 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
float
vop_aaCell2D(float ss, tt, jx, jy, bwidth, bsoft, centerx, centery;
		float f1, f2; int seed)
{
    float	p2x, p2y, x0;
    float	blur;
    vector	vp1, vp2;

    vnoise(ss, tt, jx, jy, seed, f1, f2, centerx, centery, p2x, p2y);

    vp1 = set(centerx, centery, 0);
    vp2 = set(p2x, p2y, 0);
    x0 = (f2-f1)*(f1+f2) / max(distance(vp1, vp2), 1e-6);

    blur = max(vop_FilterWidth(ss), vop_FilterWidth(tt)) * (1 + bsoft);

    return filterstep(bwidth,x0-blur,x0+blur,"filter","gauss");
}








float
vop_StampPattern(int   layers;
		 float dotsize;
		 float dj;
		 float softness;
		 float px, jx;
		 float py, jy;
		 float aux, jaux;
		 string spottype;
		 string filter;
		 float	floatseed;
	 )
{
    float	fwidth;
    float	lrandom;
    float	cx, cy, loff, dsize;
    float	fx, fy;
    float	djx, djy;
    float	du, dv;
    float	result;
    float	irad, idot;
    vector	pp;
    int		i;

    du = vop_FilterWidth(px) * softness;
    dv = vop_FilterWidth(py) * softness;
    fwidth = max(du, dv);
    result = 0;
    loff = 0;
    for (i = 0; i < layers; i++, loff += .5)
    {
	lrandom = random(i);
	pp = set(floor(px+loff), floor(py+loff),
		    1000.0*lrandom+500) + {.5, .5, .5};
	floatseed = random(pp);

	pp = vector(random(pp)) - .5;
	dsize = dotsize * (1-dj*floatseed);
	idot = 1/dsize;

	djy  = idot*(1 - dsize);
	djx  = (2*clamp(jx, 0, 1)) * djy;
	djy *= (2*clamp(jy, 0, 1));

	cx = pp.x * djx;
	cy = pp.y * djy;
	fx = cx - 2*(frac(px+loff) - .5)*idot;
	fy = cy - 2*(frac(py+loff) - .5)*idot;

	if (spottype == "ring")
	{
	    irad = 1-clamp(aux + (pp.z - .5)*jaux, 0, 1);
	    result = vop_RingStamp(fx, fy, irad, 1, fwidth, filter);
	}
	else if (spottype == "box")
	{
	    result = vop_BoxStamp(fx, fy, du, dv, filter);
	}
	else if (spottype == "hex")
	{
	    result = 1-vop_RoundCosStamp(fx, fy, fwidth, aux, 6, jaux, filter);
	}
	else if (spottype == "star")
	{
	    result = 1-vop_RoundSinStamp(fx, fy, fwidth, aux, 5, jaux, filter);
	}
	else if (spottype == "bump")
	{
	    result = vop_BumpStamp(fx, fy, fwidth, filter);
	}
	else
	{
	    result = 1-vop_DotStamp(fx, fy, fwidth, filter);
	}
    }
    floatseed = (floatseed - 0.5)*32000;
    return result;
}

float
vop_RipplePattern(float x, y, decay, toff)
{
    float	d;

    d = sqrt(x*x + y*y);
    return sin(d-toff) * exp(d*(-decay));
}
#line 768 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
vector
vop_FlowNoiseGradVV(vector pos; float flow; float delta)
{
    vector	result;

    result.x = flownoise(set(pos.x+delta,pos.y,pos.z), flow)
	     - flownoise(set(pos.x-delta,pos.y,pos.z), flow);

    result.y = flownoise(set(pos.x,pos.y+delta,pos.z), flow)
	     - flownoise(set(pos.x,pos.y-delta,pos.z), flow);

    result.z = flownoise(set(pos.x,pos.y,pos.z+delta), flow)
	     - flownoise(set(pos.x,pos.y,pos.z-delta), flow);

    result /= delta * 2;

    return result;
}

vector4
vop_FlowNoiseGradPP(vector4 pos; float flow; float delta)
{
    vector4	result;

    result.x = flownoise(set(pos.x+delta,pos.y,pos.z,pos.w), flow)
	     - flownoise(set(pos.x-delta,pos.y,pos.z,pos.w), flow);

    result.y = flownoise(set(pos.x,pos.y+delta,pos.z,pos.w), flow)
	     - flownoise(set(pos.x,pos.y-delta,pos.z,pos.w), flow);

    result.z = flownoise(set(pos.x,pos.y,pos.z+delta,pos.w), flow)
	     - flownoise(set(pos.x,pos.y,pos.z-delta,pos.w), flow);

    result.w = flownoise(set(pos.x,pos.y,pos.z,pos.w+delta), flow)
	     - flownoise(set(pos.x,pos.y,pos.z,pos.w-delta), flow);

    result /= delta * 2;

    return result;
}

vector
vop_FlowNoiseGrad3V(vector pos; float flow; float delta)
{
    matrix3	result;
    vector	final;
    vector	dx, dy, dz;

    dx = flownoise(set(pos.x+delta,pos.y,pos.z), flow)
	 - flownoise(set(pos.x-delta,pos.y,pos.z), flow);

    dy = flownoise(set(pos.x,pos.y+delta,pos.z), flow)
	 - flownoise(set(pos.x,pos.y-delta,pos.z), flow);

    dz = flownoise(set(pos.x,pos.y,pos.z+delta), flow)
	 - flownoise(set(pos.x,pos.y,pos.z-delta), flow);

    result = set(dx.x, dx.y, dx.z,
	       dy.x, dy.y, dy.z,
	       dz.x, dz.y, dz.z);

    result /= delta * 2;




    final = 0.577735;
    final *= result;

    return final;
}

vector4
vop_FlowNoiseGrad4P(vector4 pos; float flow; float delta)
{
    matrix	result;
    vector4	final;
    vector	dx, dy, dz, dw;

    dx = flownoise(set(pos.x+delta,pos.y,pos.z,pos.w), flow)
	 - flownoise(set(pos.x-delta,pos.y,pos.z,pos.w), flow);

    dy = flownoise(set(pos.x,pos.y+delta,pos.z,pos.w), flow)
	 - flownoise(set(pos.x,pos.y-delta,pos.z,pos.w), flow);

    dz = flownoise(set(pos.x,pos.y,pos.z+delta,pos.w), flow)
	 - flownoise(set(pos.x,pos.y,pos.z-delta,pos.w), flow);

    dw = flownoise(set(pos.x,pos.y,pos.z,pos.w+delta), flow)
	 - flownoise(set(pos.x,pos.y,pos.z,pos.w-delta), flow);

    result = set(dx.x, dx.y, dx.z, 0,
	       dy.x, dy.y, dy.z, 0,
	       dz.x, dz.y, dz.z, 0,
	       dw.x, dw.y, dw.z, 0);

    result /= delta * 2;




    final = 0.5;
    final *= result;

    return final;
}

float
vop_fbmlength_float(float val)
{
    return val;
}

float
vop_fbmlength_vector(vector val)
{
    return length(val);
}

float
vop_fbmlength_vector4(vector4 val)
{
    return length(val);
}
#line 920 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
float
vop_fbmNoiseFF(float pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = vop_FilterWidth(pos);
    float	nval, pp = pos;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(float (xnoise(pp)) - 0.5); } else { nval += amp *(float (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(float (xnoise(pp)) - 0.5); } else { nval += blend*(float (noise(pp)) - 0.5); } }
    return nval;
}

float
vop_fbmNoiseFV(vector pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    float	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(float (xnoise(pp)) - 0.5); } else { nval += amp *(float (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(float (xnoise(pp)) - 0.5); } else { nval += blend*(float (noise(pp)) - 0.5); } }
    return nval;
}

float
vop_fbmNoiseFP(vector4 pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    float	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(float (xnoise(pp)) - 0.5); } else { nval += amp *(float (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(float (xnoise(pp)) - 0.5); } else { nval += blend*(float (noise(pp)) - 0.5); } }
    return nval;
}

vector
vop_fbmNoiseVF(float pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = vop_FilterWidth(pos);
    float	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(vector (xnoise(pp)) - 0.5); } else { nval += amp *(vector (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(vector (xnoise(pp)) - 0.5); } else { nval += blend*(vector (noise(pp)) - 0.5); } }
    return nval;
}

vector
vop_fbmNoiseVV(vector pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(vector (xnoise(pp)) - 0.5); } else { nval += amp *(vector (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(vector (xnoise(pp)) - 0.5); } else { nval += blend*(vector (noise(pp)) - 0.5); } }
    return nval;
}

vector
vop_fbmNoiseVP(vector4 pos; float rough; int maxoctaves; string noisetype)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend; int octaves; plimit = 2*blur; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { if (noisetype == "xnoise") { nval += amp *(vector (xnoise(pp)) - 0.5); } else { nval += amp *(vector (noise(pp)) - 0.5); } amp *= rough; scale *= 0.5; pp *= 2; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); if (noisetype == "xnoise") { nval += blend*(vector (xnoise(pp)) - 0.5); } else { nval += blend*(vector (noise(pp)) - 0.5); } }
    return nval;
}



float
vop_fbmFlowNoiseFV(vector pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    float	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; float namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (float(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_float(namount) * vop_FlowNoiseGradVV (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(float(flownoise(pp, flowv)) - 0.5); }
    return nval;
}

float
vop_fbmFlowNoiseFP(vector4 pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    float	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; float namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (float(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_float(namount) * vop_FlowNoiseGradPP (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(float(flownoise(pp, flowv)) - 0.5); }
    return nval;
}

vector
vop_fbmFlowNoiseVV(vector pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area(pos));
    vector	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; vector namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (vector(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_vector(namount) * vop_FlowNoiseGrad3V (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(vector(flownoise(pp, flowv)) - 0.5); }
    return nval;
}

vector
vop_fbmFlowNoiseVP(vector4 pos; float rough; int maxoctaves; float flow, flowrate, advect)
{
    float	blur = sqrt(area((vector)pos));
    vector4	pp = pos;
    vector	nval;
    float amp, scale, plimit, blend, M, flowv; int octaves; vector namount; plimit = 2*blur; M = advect; flowv = flow; nval = 0; octaves = 0; scale = 1; amp = 1; while (scale > plimit && octaves < maxoctaves) { namount = amp * (vector(flownoise(pp, flowv)) - 0.5); nval += namount; amp *= rough; flowv *= flowrate; scale *= 0.5; if (M != 0.0) { pp -= M * vop_fbmlength_vector(namount) * vop_FlowNoiseGrad4P (pp, flow, 0.01); } pp *= 2; M *= advect; octaves++; } if (scale > blur) { blend = amp * clamp(scale/blur - 1, 0, 1); nval += blend*(vector(flownoise(pp, flowv)) - 0.5); }
    return nval;
}
#line 1036 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
float
vop_dampenFbmFF(float pos, freq, offset; float lacun, amp; int maxoctaves)
{
    float pp = pos * freq + offset;
    float fw = vop_FilterWidth(pp);
    float aa = vop_FilterWidth(pos);
    float plimit = fw/lacun;
    float scale = 1;
    int   octave = 0;
    float fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); while (scale > aa) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); pp *= lacun; scale *= lacun; }
    fbm = amp * fit(fbm, -1.25, 1.25, 0, 1);
    return fbm;
}

float
vop_dampenFbmFV(vector pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector pp = pos * freq + offset;
    float  fw = sqrt(area(pp));
    float  aa = sqrt(area(pos));
    float  plimit = fw/lacun;
    float  scale = 1;
    int    octave = 0;
    float  fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); while (scale > aa) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); pp *= lacun; scale *= lacun; }
    fbm = amp * fit(fbm, -1.25, 1.25, 0, 1);
    return fbm;
}

float
vop_dampenFbmFP(vector4 pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector4 pp = pos * freq + offset;
    float   fw = sqrt(area((vector)pp));
    float   aa = sqrt(area((vector)pos));
    float   plimit = fw/lacun;
    float   scale = 1;
    int     octave = 0;
    float   fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); while (scale > aa) { fbm += scale * fit(noise(pp),0.3,0.7,-1.0,1.0); pp *= lacun; scale *= lacun; }
    fbm = amp * fit(fbm, -1.25, 1.25, 0, 1);
    return fbm;
}
#line 1096 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
vector
vop_dampenFbmVF(float pos, freq, offset; float lacun, amp; int maxoctaves)
{
    float  pp = pos * freq + offset;
    float  fw = vop_FilterWidth(pp);
    float  aa = vop_FilterWidth(pos);
    float  plimit = fw/lacun;
    float  scale = 1;
    int    octave = 0;
    vector fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); while (scale > aa) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); pp *= lacun; scale *= lacun; }
    fbm = amp * vector(fit(fbm,{-1.25,-1.25,-1.25},{1.25,1.25,1.25},{0,0,0},{1,1,1}));
    return fbm;
}

vector
vop_dampenFbmVV(vector pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector pp = pos * freq + offset;
    float  fw = sqrt(area(pp));
    float  aa = sqrt(area(pos));
    float  plimit = fw/lacun;
    float  scale = 1;
    int    octave = 0;
    vector fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); while (scale > aa) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); pp *= lacun; scale *= lacun; }
    fbm = amp * vector(fit(fbm,{-1.25,-1.25,-1.25},{1.25,1.25,1.25},{0,0,0},{1,1,1}));
    return fbm;
}

vector
vop_dampenFbmVP(vector4 pos, freq, offset; float lacun, amp; int maxoctaves)
{
    vector4	pp = pos * freq + offset;
    float fw = sqrt(area((vector)pp));
    float aa = sqrt(area((vector)pos));
    float plimit = fw/lacun;
    float scale = 1;
    int   octave = 0;
    vector	fbm = 0;
    while (scale > plimit && octave < maxoctaves) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); scale *= lacun; pp /= lacun; octave ++; } scale *= lacun; fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); while (scale > aa) { fbm += scale * vector(fit(vector(noise(pp)),{0.3,0.3,0.3},{0.7,0.7,0.7},{-1.0,-1.0,-1.0},{1.0,1.0,1.0})); pp *= lacun; scale *= lacun; }
    fbm = amp * vector(fit(fbm,{-1.25,-1.25,-1.25},{1.25,1.25,1.25},{0,0,0},{1,1,1}));
    return fbm;
}
#line 1167 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
float
vop_perlinNoiseVF(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    float nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((float(noise(pp))) + 0); nval = (float(pow(nval, atten)));
    return nval;
}

vector
vop_perlinNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(noise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(noise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

float
vop_correctperlinNoiseVF(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    float nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 0.5 * scale * ((float(noise(pp))) + -.5); nval = (float(pow(nval, atten)));
    return nval;
}

vector
vop_correctperlinNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 0.5 * scale * ((vector(noise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_correctperlinNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 0.5 * scale * ((vector(noise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

float
vop_simplexNoiseVF(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    float nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += .5 * scale * ((float(xnoise(pp))) + -.5); nval = (float(pow(nval, atten)));
    return nval;
}

vector
vop_simplexNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += .5 * scale * ((vector(xnoise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += .5 * scale * ((vector(xnoise(pp))) + -.5); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexCurlNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlxnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexCurlNoise2DVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlxnoise2d(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_simplexCurlNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlxnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinCurlNoiseVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinCurlNoise2DVV(vector pos; int turb; float amp, rough, atten)
{
    vector pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlnoise2d(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}

vector
vop_perlinCurlNoiseVP(vector4 pos; int turb; float amp, rough, atten)
{
    vector4 pp = pos;
    vector nval;
    float scale = amp; int i; nval = 0; for (i = 0; i < turb; i++, pp *= 2.0, scale *= rough) nval += 1 * scale * ((vector(curlnoise(pp))) + 0); nval = (vector(pow(nval, atten)));
    return nval;
}
#line 1364 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
vector
vop_curlNoiseVV(vector pos, freq, offset, nml;
		string type, geo;
		int turb, bounce;
	    	float amp, rough, atten, distance, radius, h)
{
    vector val = {0,0,0};

    if (type == "exact_pnoise")
    {
	return vop_perlinCurlNoiseVV(pos*freq-offset, turb, amp, rough*2, atten);
    }
    else if (type == "exact_xnoise")
    {
	return vop_simplexCurlNoiseVV(pos*freq-offset, turb, amp, rough*2, atten);
    }


    vector xDiff = pos;		xDiff.x += h;
    vector yDiff = pos;		yDiff.y += h;
    vector zDiff = pos;		zDiff.z += h;


    vector noisevec, xDiffNoise, yDiffNoise, zDiffNoise;
    if( type == "onoise" )
    {
	noisevec = onoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = onoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = onoise(yDiff*freq - offset, turb, rough, atten) * amp;
	zDiffNoise = onoise(zDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "snoise" )
    {
	noisevec = snoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = snoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = snoise(yDiff*freq - offset, turb, rough, atten) * amp;
	zDiffNoise = snoise(zDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "anoise" )
    {
	noisevec = anoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = anoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = anoise(yDiff*freq - offset, turb, rough, atten) * amp;
	zDiffNoise = anoise(zDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if (type == "xnoise" )
    {
	noisevec = vop_simplexNoiseVV(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_simplexNoiseVV(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_simplexNoiseVV(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_simplexNoiseVV(zDiff*freq - offset, turb, amp, rough, atten);
    }
    else
    {
	noisevec = vop_perlinNoiseVV(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_perlinNoiseVV(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_perlinNoiseVV(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_perlinNoiseVV(zDiff*freq - offset, turb, amp, rough, atten);
    }


    float dist, r, d; vector norm = normalize(nml); if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)pos) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; noisevec = (r * noisevec) + ((1-r) * dot(norm, noisevec) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)xDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)xDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; xDiffNoise = (r * xDiffNoise) + ((1-r) * dot(norm, xDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)yDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)yDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; yDiffNoise = (r * yDiffNoise) + ((1-r) * dot(norm, yDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)zDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)zDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; zDiffNoise = (r * zDiffNoise) + ((1-r) * dot(norm, zDiffNoise) * norm);; float dzdy = (yDiffNoise.z - noisevec.z); float dydz = (zDiffNoise.y - noisevec.y); float dxdz = (zDiffNoise.x - noisevec.x); float dzdx = (xDiffNoise.z - noisevec.z); float dydx = (xDiffNoise.y - noisevec.y); float dxdy = (yDiffNoise.x - noisevec.x); val.x = (dzdy - dydz)/h; val.y = (dxdz - dzdx)/h; val.z = (dydx - dxdy)/h; if( bounce ) { vector vn; if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); if( dist < 0 ) { norm = normalize( volumegradient(geo, 0, (vector)pos) ); d = dot(norm, val); if( d < 0 ) { vn = d * norm; val = val - 2*vn; } } } else if( distance < 0 ) { d = dot(norm, val); if( d < 0 ) { vn = d * nml; val = val - 2*vn; } } }

    return val;
}

vector
vop_curlNoiseVP(vector4 pos, freq, offset;
		vector nml;
		string type; string geo;
		int turb, bounce;
		float amp, rough, atten, distance, radius, h)
{
    vector val = {0,0,0};

    if (type == "exact_pnoise")
    {
	return vop_perlinCurlNoiseVP(pos*freq-offset, turb, amp, rough*2, atten);
    }
    else if (type == "exact_xnoise")
    {
	return vop_simplexCurlNoiseVP(pos*freq-offset, turb, amp, rough*2, atten);
    }


    vector4 xDiff = pos;	xDiff.x += h;
    vector4 yDiff = pos;	yDiff.y += h;
    vector4 zDiff = pos;	zDiff.z += h;

    vector noisevec, xDiffNoise, yDiffNoise, zDiffNoise;


    if (type == "xnoise")
    {
	noisevec = vop_simplexNoiseVP(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_simplexNoiseVP(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_simplexNoiseVP(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_simplexNoiseVP(zDiff*freq - offset, turb, amp, rough, atten);
    }
    else
    {
	noisevec = vop_perlinNoiseVP(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_perlinNoiseVP(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_perlinNoiseVP(yDiff*freq - offset, turb, amp, rough, atten);
	zDiffNoise = vop_perlinNoiseVP(zDiff*freq - offset, turb, amp, rough, atten);
    }


    float dist, r, d; vector norm = normalize(nml); if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)pos) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; noisevec = (r * noisevec) + ((1-r) * dot(norm, noisevec) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)xDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)xDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; xDiffNoise = (r * xDiffNoise) + ((1-r) * dot(norm, xDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)yDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)yDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; yDiffNoise = (r * yDiffNoise) + ((1-r) * dot(norm, yDiffNoise) * norm);; if( geo != "" ) { dist = volumesample(geo, 0, (vector)zDiff); r = abs( clamp(dist/radius, -1, 1) ); norm = normalize( volumegradient(geo, 0, (vector)zDiff) ); if( dist < 0 ) { norm = -norm; } } else { r = abs( clamp(distance/radius, -1, 1) ); } r = ( 15.0*r - 10.0*r*r*r + 3*r*r*r*r*r ) / 8.0; zDiffNoise = (r * zDiffNoise) + ((1-r) * dot(norm, zDiffNoise) * norm);; float dzdy = (yDiffNoise.z - noisevec.z); float dydz = (zDiffNoise.y - noisevec.y); float dxdz = (zDiffNoise.x - noisevec.x); float dzdx = (xDiffNoise.z - noisevec.z); float dydx = (xDiffNoise.y - noisevec.y); float dxdy = (yDiffNoise.x - noisevec.x); val.x = (dzdy - dydz)/h; val.y = (dxdz - dzdx)/h; val.z = (dydx - dxdy)/h; if( bounce ) { vector vn; if( geo != "" ) { dist = volumesample(geo, 0, (vector)pos); if( dist < 0 ) { norm = normalize( volumegradient(geo, 0, (vector)pos) ); d = dot(norm, val); if( d < 0 ) { vn = d * norm; val = val - 2*vn; } } } else if( distance < 0 ) { d = dot(norm, val); if( d < 0 ) { vn = d * nml; val = val - 2*vn; } } }

    return val;
}

vector
vop_curlNoise2DVV(vector pos, freq, offset;
		    string type, geo;
		    int turb;
		    float amp, rough, atten, distance, radius, h)
{
    vector val = {0,0,0};

    if (type == "exact_pnoise")
    {
	return vop_perlinCurlNoise2DVV(pos*freq-offset, turb, amp, rough*2, atten);
    }
    else if (type == "exact_xnoise")
    {
	return vop_simplexCurlNoise2DVV(pos*freq-offset, turb, amp, rough*2, atten);
    }


    vector xDiff = pos;		xDiff.x += h;
    vector yDiff = pos;		yDiff.y += h;


    float noise, xDiffNoise, yDiffNoise;
    if( type == "onoise" )
    {
	noise = onoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = onoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = onoise(yDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "snoise" )
    {
	noise = snoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = snoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = snoise(yDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if( type == "anoise" )
    {
	noise = anoise(pos*freq - offset, turb, rough, atten) * amp;
	xDiffNoise = anoise(xDiff*freq - offset, turb, rough, atten) * amp;
	yDiffNoise = anoise(yDiff*freq - offset, turb, rough, atten) * amp;
    }
    else if (type == "xnoise")
    {
	noise = vop_simplexNoiseVF(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_simplexNoiseVF(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_simplexNoiseVF(yDiff*freq - offset, turb, amp, rough, atten);
    }
    else
    {
	noise = vop_perlinNoiseVF(pos*freq - offset, turb, amp, rough, atten);
	xDiffNoise = vop_perlinNoiseVF(xDiff*freq - offset, turb, amp, rough, atten);
	yDiffNoise = vop_perlinNoiseVF(yDiff*freq - offset, turb, amp, rough, atten);
    }


    float r;
    if( geo != "" )
    {
	float dist = volumesample(geo, 0, pos);
	r = clamp(dist/radius, -1, 1);
    }
    else
    {
	r = clamp(distance/radius, -1, 1);
    }
    r = ( 15.0 * r - 10.0 * r*r*r + 3.0 * r*r*r*r*r ) / 8.0;
    noise = noise * r;
    xDiffNoise = xDiffNoise * r;
    yDiffNoise = yDiffNoise * r;


    val.x = (yDiffNoise - noise) / h;
    val.y = (noise - xDiffNoise) / h;

    return val;
}

void
vop_displaceAlongNormal(vector pp, nn; float amount, scale, sshear, tshear;
			    int	 for_poly, obj_space, bump_only;
			    vector dP, dN)
{

    if (obj_space)
    {
	float	nscale = length(nn);
	dN = normalize(ntransform("space:object", nn)) * nscale;
	dP = ptransform("space:object", pp);
    }
    else
    {
	dN = nn;
	dP = pp;
    }

    dP += (scale * amount)*dN;
    dP += (sshear * amount) * normalize(Du(dP));
    dP += (tshear * amount) * normalize(Dv(dP));

    if (obj_space)
    {
	dP = ptransform("space:object", "space:current", dP);
    }

    if (for_poly)
	 dN = computenormal(dP, nn, Ng);
    else dN = computenormal(dP);






    if (bump_only)
    {
	dP =  pp;
    }
}





void
vop_displaceAlongVector(vector pp, vec; string space; int mode;
                        float amount, scale, sshear, tshear;
			            vector dP, dN)
{
    dP = pp;
    dN = normalize(N);


    vector ng = Ng;
    vector oP = pp;
    vector oN = vec;
    if (space != "space:current" ) {

        oP = ptransform(space, pp);
        ng = ntransform(space, Ng);

        if ( mode == 0 )
            oN = amount * normalize(ntransform(space, 2*vec-1));
        else if ( mode == 1 )
            oN = ntransform(space, vec);
        else if ( mode == 2 )
            oN = amount * normalize(ntransform(space, N));
    }
    else {
        if ( mode == 0 )
            oN = amount * normalize(2*vec-1);
        else if ( mode == 1 )
            oN = vec;
        else if ( mode == 2 )
            oN = amount * normalize(N);
    }


    oP += scale * oN;
	oN = computenormal(oP, oN, ng);



    if (space != "space:current" ) {
        dP = ptransform(space,"space:current", oP);
        dN = normalize(ntransform(space,"space:current", oN));
    }
    else {
        dP = oP;
        dN = normalize(oN);
    }
}


vector
vop_setcomp(vector in; float fval; int part)
{
    vector out = in;
    setcomp(out, fval, part);
    return out;
}

matrix
vop_setmatcomp(matrix in; float fval; int row, col)
{
    matrix out = in;
    setcomp(out, fval, row, col);
    return out;
}
#line 1675 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
matrix vop_translate(matrix in; vector t) { matrix out = in; translate(out, t); return out; }
matrix vop_translate(matrix in; vector4 t) { matrix out = in; translate(out, t); return out; }
#line 1688 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
matrix vop_rotate(matrix in; float angle; vector axis) { matrix out = in; rotate(out, angle, axis); return out; }
matrix3 vop_rotate(matrix3 in; float angle; vector axis) { matrix3 out = in; rotate(out, angle, axis); return out; }
#line 1702 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
matrix vop_scale(matrix in; vector s) { matrix out = in; scale(out, s); return out; }
matrix3 vop_scale(matrix3 in; vector s) { matrix3 out = in; scale(out, s); return out; }


vector
vop_frompolar(float u, v; float radius)
{
    float	sv = sin(v);
    return set(sv*cos(u), sv*sin(u), cos(v))*radius;
}

vector
vop_topolarXYZ(float x, y, z)
{
    float r = sqrt(x*x+y*y+z*z);
    return set(
	    atan(y, x) % (2* 3.1415926),
	    acos(z/r),
	    r);
}

vector
vop_topolar(vector v)
{
    return vop_topolarXYZ(v.x, v.y, v.z);
}


void
vop_computeTangents(string tstyle;
		    vector nn, uv;
		    vector in_utan, in_vtan;
		    vector out_utan, out_vtan)
{
    if (tstyle == "geo")
    {
	out_utan = normalize(dPds);
	out_vtan = normalize(dPdt);
    }
    else if (tstyle == "world")
    {
	out_vtan = cross(set(0, 0, 1), nn);
	out_vtan = length2(out_vtan) < 1e-6 ? set(1, 0, 0) : normalize(out_vtan);
	out_utan = normalize(cross(nn, out_vtan));
    }
    else if (tstyle == "object")
    {
	out_vtan = cross(ow_vspace(set(0, 0, 1)), nn);
	out_vtan = length2(out_vtan) < 1e-6 ? set(1, 0, 0) : normalize(out_vtan);
	out_utan = normalize(cross(nn, out_vtan));
    }
    else if (tstyle == "uv")
    {
	out_utan = normalize((dPds * Dv(uv.y)) - (dPdt * Du(uv.y)));
	out_vtan = normalize(cross(nn, out_utan));
	out_utan = normalize(cross(nn, out_vtan));
    }
    else
    {
	out_utan = in_utan;
	out_vtan = in_vtan;
    }
}

void
vop_computeTangentsOld(vector out_tanu, out_tanv;
		       vector nn, uv;
		       vector in_tanu, in_tanv;
		       int tstyle)
{
    string	s_tstyle;
    if (tstyle == 0)
	s_tstyle = "world";
    else if (tstyle == 1)
	s_tstyle = "object";
    else if (tstyle == 2)
    s_tstyle = "uv";
    else
	s_tstyle = "inputs";
    vop_computeTangents(s_tstyle,
	    nn, uv, in_tanu, in_tanv, out_tanu, out_tanv);
}

vector
vop_anisotropic_eval(vector ll; vector nn; vector V;
		vector uv; vector in_tanu; vector in_tanv;
		float urough, vrough; int model; int tstyle)
{
    vector    H;
    vector    clr;
    vector    tanU, tanV;
    float     rz, cos_r, cos_i;

    float     nml_term;
    float     uval, vval, nval;
    float     exponent;

    cos_r = dot(nn, V);
    clr = 0;
    if (cos_r > 0.0)
    {
	vop_computeTangentsOld(tanU, tanV, nn, uv, in_tanu, in_tanv, tstyle);

	cos_i = dot(ll, nn);
	if (cos_i > 0.0)
	{
	    H = normalize(V + ll);
	    uval = dot(tanU, H);
	    vval = dot(tanV, H);
	    nval = dot(nn, H);

	    rz = 0;
	    if (nval > 0)
	    {
		if (model == 0)
		{

		    nml_term = 4.0 * 3.1415926 * urough*vrough;
		    uval /= urough;
		    vval /= vrough;
		    rz = cos_i*exp(-2.*(uval*uval + vval*vval) /
			    (1.0 + nval));
		    rz /= nml_term * sqrt(cos_i*cos_r);
		}
		else
		{

		    exponent = uval*uval/urough + vval*vval/vrough;
		    exponent /= 1.0 - nval*nval;

		    rz = pow(nval, exponent) / (4.0 * dot(V, H));
		}
	    }
	    clr = rz;
	}
    }
    return clr;
}



vector
vop_anisotropic(vector nn; vector V; vector uv; float urough, vrough;
		int model, tstyle)
{
    vector	ll;
    vector	lclr;
    vector	tanu = 0;
    vector	tanv = 0;

    lclr = 0;
    tanu = 0;
    tanv = 0;


    illuminance (P, nn, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	shadow(Cl);
	ll = normalize(L);
	lclr = vop_anisotropic_eval(
		ll, nn, V, uv, tanu, tanv, urough, vrough, model, tstyle);
	lclr *= Cl;
    }
    return lclr;
}

vector
vop_sheen(vector nn, ii; float eta, rough; int facefwd)
{
    vector	R, T;
    float	Kr, Kt, sheen;
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));
    vector	illum = 0;

    fresnel(ii, nn, eta, Kr, Kt, R, T);
    Kr = smooth(0.0, 0.5, Kr);
    illuminance (P, nn, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	vector nL = normalize(L);
	shadow(Cl);
	sheen = specularBRDF(nL, nf, -ii, rough);
	illum += Cl * dot(nL, nf) * (sheen + 0.2);
    }
    return Kr * illum;
}



bsdf
vop_sheen_bsdf(vector nn, ii; float eta, rough; int facefwd)
{
    float	Kr, Kt;
    vector	R, T;
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));
	bsdf    f;

    fresnel(ii, nn, eta, Kr, Kt, R, T);
    Kr = smooth(0.0, 0.5, Kr);
    f = Kr * ((bsdf(diffuse(nf)) * 0.2) +
	       bsdf(diffuse(nf)) * matchvex_specular(nf, 1.0/rough));
    return f;
}

float
vop_specular_eval(string lmodel; vector ll, nf, ii, uv, tanu, tanv;
	     float urough, vrough, sharp; int tstyle)
{
    float	seval = 0;

    if (lmodel == "phong")
    {
	seval = phongBRDF(ll, nf, -ii, 1.0/urough);
    }
    else if (lmodel == "blinn")
    {
	seval = blinnBRDF(ll, nf, -ii, urough);
    }
    else if (lmodel == "glossy")
    {
	float	w = sharp/2.0;

	seval = specularBRDF(ll, nf, -ii, urough);
	if (w > 0)
	    seval = smooth(w, 1-w, seval);
    }
    else if (lmodel == "anisotropic")
    {
	seval = (float)vop_anisotropic_eval(ll, nf, -ii,
		uv, tanu, tanv, urough, vrough, 0, tstyle);
    }
    else if (lmodel == "spec" ||
	     lmodel == "specular")
    {
	seval = specularBRDF(ll, nf, -ii, urough);
    }
    return seval;
}



vector
vop_specular(string lmodel; vector nf, ii, uv;
	     float urough, vrough, sharp; int tstyle)
{
    vector	clr, ll;
    vector	tanu, tanv;

    tanu = 0;
    tanv = 0;

    clr = 0;
    illuminance(P, nf, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	shadow(Cl);
	ll = normalize(L);
	clr += Cl * vop_specular_eval(lmodel, ll, nf, ii, uv, tanu, tanv,
		urough, vrough, sharp, tstyle);
    }

    return clr;
}



bsdf
vop_specular_bsdf(string lmodel; vector nf, ii, uv, tanu, tanv;
	     float urough, vrough, sharp; int tstyle)
{
    bsdf	f;

    if (lmodel == "phong")
    {
	f = bsdf(phong(nf, 1.0/urough));
    }
    else if (lmodel == "blinn")
    {
	f = matchvex_blinn(nf, 1.0/urough);
    }
    else if (lmodel == "glossy")
    {
	f = matchvex_specular(nf, 1.0/urough);
    }
    else if (lmodel == "anisotropic")
    {
	bsdf	aniso_bsdf;
	vector	tanU;
	vector	tanV;

	vop_computeTangentsOld(tanU, tanV, nf, uv, tanu, tanv, tstyle);
	aniso_bsdf = ashikhmin(nf, 2.0/(urough*urough), 2.0/(vrough*vrough),
			       normalize(tanU), normalize(tanV));
	f = (1.0 / (2.0 * 3.1415926 * urough * vrough)) * aniso_bsdf;
    }
    else
    {
	f = matchvex_specular(nf, 1.0/urough);
    }
    return f;
}

float
vop_diffuse_eval(string dmodel; vector ll, nf, ii; float rough)
{
    float	deval = 0;
    if (dmodel == "isotropic")
    {
	deval = 1;
    }
    else if (dmodel == "oren")
    {
	deval = diffuseBRDF(ll, nf, -ii, rough);
    }
    else if (dmodel == "diffuse")
    {
	deval = diffuseBRDF(ll, nf);
    }
    return deval;
}

bsdf
vop_diffuse_bsdf(string dmodel; vector nf, ii; float rough)
{
    bsdf	f;

    if (dmodel == "isotropic")
    {
	f = isotropic();
    }
    else if (dmodel == "oren")
    {
	f = bsdf(diffuse(nf, rough));
    }
    else
    {
	f = bsdf(diffuse(nf));
    }
    return f;
}



vector
vop_lighting(string lmodel;
	     vector nf, ii, uv, amb, diff, spec;
	     float urough, vrough; int tstyle)
{
    vector	clr;

    if (lmodel == "constant")
    {
	clr = diff;
    }
    else if (lmodel == "headlight")
    {
	clr = diff * clamp(dot(nf, -ii), 0, 1);
    }
    else
    {
	float	angle;

	clr = amb * ambient();

	if (lmodel == "isotropic")
	    angle = 3.1415926;
	else
	    angle = 3.1415926/2;

	illuminance(P, nf, angle, (bouncemask("diffuse")|bouncemask("reflect")), "lightexport", "")
	{
	    vector ll = normalize(L);
	    vector lclr = 0;

	    if (diff != {0,0,0})
	    {
		float	deval;
		if (lmodel == "isotropic" ||
		    lmodel == "oren")
		    deval = vop_diffuse_eval(lmodel, ll, nf, ii, urough);
		else
		    deval = vop_diffuse_eval("diffuse", ll, nf, ii, urough);

		lclr += deval * diff;
	    }
	    if (lmodel != "isotropic" &&
		lmodel != "oren" &&
		spec != {0,0,0})
	    {
		vector	tanu = 0;
		vector	tanv = 0;

		float seval = vop_specular_eval(lmodel, ll, nf, ii,
			uv, tanu, tanv, urough, vrough, 0, tstyle);

		lclr += seval * spec;
	    }

	    if (lclr != 0)
	    {
		shadow(Cl);
		clr += lclr * Cl;
	    }
	}
    }
    return clr;
}



bsdf
vop_lighting_bsdf(string lmodel;
	     vector nf, ii, uv, amb, diff, spec;
	     float urough, vrough; int tstyle)
{
    bsdf	f;
    vector	tanu = 0;
    vector	tanv = 0;

    if (lmodel == "constant")
    {
	f = bsdf();
    }
    else if (lmodel == "lambert" ||
	     lmodel == "headlight" ||
	     lmodel == "oren" ||
	     lmodel == "isotropic")
    {
	f = diff * vop_diffuse_bsdf(lmodel, nf, ii, urough);
    }
    else
    {
	tanu = 0;
	tanv = 0;
	f = diff * bsdf(diffuse(nf));
	f += spec * vop_specular_bsdf(lmodel, nf, ii,
		uv, tanu, tanv, urough, vrough, 0, tstyle);
    }
    return f;
}





#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/singlescatter.h"
#line 16 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/singlescatter.h"
float
phase(vector v1, v2; float g)
{
    float costheta = dot(-v1, v2);
	float g2 = g*g;
    return (1.0 - g2) / pow(1.0 + g2 - 2.*g*costheta, 1.5);
}








float
singleScatter(vector in, out, nn; float g, albedo, depth)
{
    float win = abs(dot(in, nn));
    float won = abs(dot(out, nn));
    float offset = phase(out, in, g);

    float scatter = albedo * offset/(win + won);
    scatter *= 1.0 - exp(-(1.0/win + 1.0/won) * depth);

    return scatter;
}

vector
efresnel(vector ii, nn; float eta; float Kr, Kt;)
{
    vector R, T;
    fresnel(ii, nn, eta, Kr, Kt, R, T);
    Kr = smooth(0.0, 0.5, Kr);
    Kt = 1.0 - Kr;
    return normalize(T);
}
#line 2147 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/pcscatter.h"
#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shading.h"
#line 14 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/pcscatter.h"

float vop_hgphase(float g; vector Wi, Wo) {
   float g2=g*g;
        return (1. - g2) / pow(1. + g2 - (2.*g*dot(-Wi,Wo)), 1.5);
}

float vop_hgphaseN(float g; vector Wi, Wo) {
   float g2=g*g;
   float num = g>0 ? -1.+g : 1.+g;
        return pow(num*num,1.5) / pow(1.+g2-(2.*g*dot(-Wi,Wo)),1.5);
}

float vop_ssBounceAtten(vector No,Ni,Li) {
   return 1.0 - ((1.0-dot(No,Ni))* (1.0-dot(No,Li)) / 2.0);
}

float vop_cdfSingle(float y) {
   float yy = clamp(y,0.0,1.0);
   return y<=0. ? 0. : (y>=1. ? 1. : yy*(2.0 + (yy-2.0)*yy*yy));
}


void vop_pcIllum (int handle; string att) {
   vector p, n;
   vector illum;
   int status;
   while (pcunshaded(handle, att)) {
      pcimport(handle, "P", p); p = ow_space(p);
      pcimport(handle, "N", n); n = normalize(ow_nspace(n));
      illum = 0;
      illuminance(p, n, 3.1415926/2, bouncemask("diffuse"), "lightexport", "") {
         shadow(Cl);
         illum += Cl * diffuseBRDF(normalize(L), n);
      }
      status = pcexport(handle, att, illum);
   }
}




void vop_pcIrrad (int handle; string att) {
   vector p, n;
   vector irrad;
   int status;
   while (pcunshaded(handle, att)) {
      pcimport(handle, "P", p); p = ow_space(p);
      pcimport(handle, "N", n); n = normalize(ow_nspace(n));
      irrad = irradiance(p,n);
      status = pcexport(handle, att, irrad);
   }
}


float vop_icdfSingle(float x) {
   float rslt = 0.;
   if(x>=1.) {
      rslt = 1.;
   } else if(x>0.) {
      float a = pow(9. - (9.*x) + (1.73205080756887729353 *
                  sqrt(11.-(6.*x)-(21.*x*x)+(16.*x*x*x))), 0.333333333333333);
      float A = (2.*1.587401051968199*(1.-x)) / (1.442249570307408*a);
      float B = (1.259921049894873*a) / 2.080083823051904;
      float C = sqrt(1.0 + A + B);
      rslt = 0.5 * ( 1.0 + sqrt(2.0 - A - B + (2.0/C)) - C );
   }
   return rslt;
}



vector vop_ssIntegMulti (
   string pcmap;
   vector Rdo;
   float sd;
   float bounce;
   int t_rgb;
   vector pcP;
   vector pcN;
   )
{
   vector Xi,Ni;
   vector Xo = pcP;
   vector No = normalize(pcN);
   vector ld = Rdo*sd;
   float ld1 = max(ld);
   int handle = pcopen(pcmap, "P", Xo, ld1, (int)1e9);
   vop_pcIllum(handle,"illum");
   float r,ptarea;
   vector ssm=0, ptillum=0;
   while (pciterate(handle)) {
      pcimport(handle, "P", Xi);
      pcimport(handle, "N", Ni);
      pcimport(handle, "point.distance", r);
      pcimport(handle, "ptarea", ptarea);
      pcimport(handle, "illum", ptillum);
      Ni = normalize(Ni);
      vector Li = (Xo-Xi)/ld1;
      float kb = vop_ssBounceAtten(No,Ni,Li);
      kb = lerp(1.0,kb,bounce);
      if(kb>0.0 ) {
         if(t_rgb)
         {
            int wave;
            for(wave=0;wave<3;wave++) {
               setcomp( ssm,
                        getcomp(ssm,wave) +
                           kb * getcomp(ptillum,wave) * ptarea *
                           (1-smooth(0,getcomp(ld,wave),r)),
                        wave
                      );
            }
         }
         else
            ssm += kb * ptillum * ptarea * (1-smooth(0,ld1,r));
      }
   }
   pcclose(handle);
   if(!t_rgb) ssm*=Rdo;
   float norm = 3.0*ld1*ld1*3.1415926 / 10.0;
   return ssm / norm;
}


vector vop_ssIntegSingle (
   vector Rd;
   float sd;
   float g;
   float eta;
   int samples;
   float tbias;
   int t_rgb;
   vector PP;
   vector NN;
   vector II;
   )
{
   float Kro, Kto, Kri, Kti;
   vector Xi, Wi, Ni;
   int samp;
   vector Psamp;
   float phase,WiNi,AWiNi,spi,spo,ksss;
   string oname = getobjectname();
   vector Xo = PP;
   vector No = normalize(NN);
   vector Wo = -normalize(II);
   vector lu = Rd*sd;
   float lu1 = max(lu);
   float ieta = 1.0 / eta;
   float ieta2 = ieta * ieta;
   vector To = normalize(refract(-Wo,No,ieta));
   vector Wpo = -To;
   float gg = clamp(g,-0.998,.998);
   if(eta!=1.0) { fresnel(Wpo,-No,ieta,Kro,Kto); }
      else Kto = 1.0;
   vector scatt = 0;
   vector realsamples = 0;
   float hitD = rayhittest(Xo,To*1e6,tbias,"scope",oname);
   float spoMax = hitD<0. ? lu1 : min(hitD,lu1);
   float terr = tbias;
   float sinc = (1.0-2.0*terr)/(float)(samples);
   float ss = terr;
   float ssbase= ss;
   if(t_rgb) {
      vector maxadj = set(
            vop_cdfSingle(clamp(spoMax/lu.x,0.,1.)),
            vop_cdfSingle(clamp(spoMax/lu.y,0.,1.)),
            vop_cdfSingle(clamp(spoMax/lu.z,0.,1.))
         );
      int wave;
      for(wave=0;wave<3;wave++)
      {
         ss=ssbase=terr;
         float luk = getcomp(lu,wave);
         for(samp=0; samp<samples; samp++)
         {
            ss = ssbase+sinc*nrandom();
            spo = spoMax*vop_icdfSingle(ss*getcomp(maxadj,wave));
            ssbase+=sinc;
            Psamp = Xo + (To * spo);
            illuminance(Psamp, No, 3.1415926, bouncemask("diffuse"), "lightexport", "")
            {
               Wi = normalize(L);
               hitD = rayhittest(Psamp,L,Xi,Ni,0.,"scope",oname);
               if(hitD>0.) {
                  setcomp(realsamples,getcomp(realsamples,wave)+1,wave);
                  Ni = normalize(Ni);
                  WiNi = dot(Wi,Ni);
                  AWiNi = abs(WiNi);
                  spi = distance(Psamp,Xi) * AWiNi /
                              sqrt(1.0 - ieta2 * (1.0 - AWiNi*AWiNi));
		  if(spi <= luk && WiNi>0.) {
		      if(eta!=1.0) { fresnel(-Wi,Ni,ieta,Kri,Kti); }
		      else Kti = 1.0;
		      float f = Kti * Kto;
		      phase = vop_hgphaseN(gg,Wi,Wpo);
		      ksss = f * phase * (1-smooth(0,luk,spi));
		      setcomp(scatt,getcomp(scatt,wave) +
			      getcomp(Cl,wave)*WiNi*ksss,
			      wave);
                  }
               }
            }
         }
      }
   } else {
      ss=ssbase=terr;
      float icdfmax = vop_cdfSingle(clamp(spoMax/lu1,0.,1.));
      for(samp=0; samp<samples; samp++)
      {
         ss = ssbase+nrandom()*sinc;
         spo = spoMax*vop_icdfSingle(ss*icdfmax);
         ssbase += sinc;
         Psamp = Xo + (To * spo);
         illuminance(Psamp, No, 3.1415926, bouncemask("diffuse"), "lightexport", "")
         {
            Wi = normalize(L);
            hitD = rayhittest(Psamp,L,Xi,Ni,0.,"scope",oname);
            if(hitD>0.) {
               realsamples += 1;
               Ni = normalize(Ni);
               WiNi = dot(Wi,Ni);
               AWiNi = abs(WiNi);
               spi = distance(Psamp,Xi) * AWiNi /
                           sqrt(1.0 - ieta2 * (1.0 - AWiNi*AWiNi));
               if(spi <= lu1 && WiNi>0.) {
                  if(eta!=1.0) { fresnel(-Wi,Ni,ieta,Kri,Kti); }
                     else Kti = 1.0;
                  float f = Kti * Kto;
                     phase = vop_hgphaseN(gg,Wi,Wpo);
                     ksss = f * phase * (1-smooth(0,lu1,spi));
                  scatt+= Cl * Rd * WiNi * ksss;
               }
            }
         }
      }
   }
      return 2.0 * scatt / realsamples;
}
#line 2148 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"

vector
vop_hairspec(vector nn, V, T; float exp;)
{




    float NdotI = dot(nn, V);
    vector illum = 0;

    illuminance (P, nn, 3.1415926/2, bouncemask("reflect"), "lightexport", "")
    {
	vector nL = normalize(L);
	float NdotL = dot(nn, nL);

	float Kajiya = cos(abs(acos(dot(T,nL)) - acos(dot(-T,V))));

	shadow(Cl);
	illum += Cl * NdotL * NdotI * pow(Kajiya, 1.0/exp);
    }
    return illum;
}

vector
vop_simpleSSS(vector nn, ii; float  eta, depth; int facefwd)
{
#line 2186 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
    vector	illum = 0;
    float	Kr, fKr = 1;
    float	Kt = 1;
    float	fKt = 1;
    vector	rayin = efresnel(ii, nn, eta, Kr, Kt);
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));

    illuminance (P, nn, 3.1415926/2, bouncemask("diffuse"), "lightexport", "")
    {
	vector nL = normalize(L);
	vector rayout = efresnel(-nL, nn, eta, fKr, fKt);

	shadow(Cl);
	illum += Cl * dot(nL, nf) * Kt * fKt *
			    (singleScatter(rayin, rayout, nf, .8, .8, depth) +
			     singleScatter(rayin, rayout, nf, .3, .5, depth) +
			     singleScatter(rayin, rayout, nf, 0., .4, depth));
    }
    return illum;
}



bsdf
vop_SSS_bsdf(vector nn, ii; float  eta, depth; int facefwd)
{
    float	Kr = 1;
    float	Kt = 1;
	vector  R, T;
	vector	nf = nn;
	if (facefwd) nf = normalize(frontface(nn, ii));
	bsdf    f;

    fresnel(ii, nn, eta, Kr, Kt, R, T);
	Kr = smooth(0, 0.5, Kr);
	Kt = 1 - Kr;


	f = Kt * bsdf(diffuse(nf));
    return f;
}



vector
vop_multiSSS(vector Pin, Nin, Rd; float sd, bounce;
			 string pcmap; int nfp, t_rgb;)
{
   vector Xo = wo_space(Pin);
   vector No = normalize(wo_nspace(Nin));
   vector mapP, mapN, ssm;
   int xxx;
   string ch_ssm = "ssM";
   int handle = pcopen(pcmap, "P", Xo, "N", No, 1e37, nfp);
   while (pcunshaded(handle, ch_ssm)) {
      pcimport(handle, "P", mapP);
      pcimport(handle, "N", mapN);
      ssm = vop_ssIntegMulti(pcmap, Rd, sd, bounce,t_rgb, mapP, mapN);
      xxx = pcexport(handle, ch_ssm, ssm);
   }
   vector bssrdf = vector(pcfilter(handle, ch_ssm));
   pcclose(handle);
   return bssrdf;
}

vector
vop_singleSSS(vector Pin, Nin, Iin, Rd; float sd, g, eta, tbias;
                string pcmap; int nfp, samples, t_rgb;)
{
   vector bssrdf;
   if(pcmap != "")
   {
      vector Xo = wo_space(Pin);
      vector No = normalize(wo_nspace(Nin));
      vector eye = Pin-Iin;
      vector mapP, mapN, ssm;
      int xxx;
      int handle = pcopen(pcmap, "P", Xo, "N", No, 1e37, nfp);
      string ch_ssm = "ssS";
      while (pcunshaded(handle, ch_ssm)) {
         pcimport(handle, "P", mapP);
         pcimport(handle, "N", mapN);
         ssm = vop_ssIntegSingle (Rd,sd, g,eta,samples,tbias,t_rgb,
                              ow_space(mapP),ow_nspace(mapN),mapP-eye);
         xxx = pcexport(handle, ch_ssm, ssm);
      }
      bssrdf = vector(pcfilter(handle, ch_ssm));
      pcclose(handle);
   }
   else
   {
      bssrdf = vop_ssIntegSingle(Rd,sd,g,eta,samples,tbias,t_rgb,Pin,Nin,Iin);
   }
   return bssrdf;
}


vector
vop_trace_environment(string envmap, envobj; vector raydir, bg;)
{
    vector val = 0;
    if (envmap == "")
    {
	val = bg;
    }
    else
    {
	vector	dir = vtransform("space:current", envobj, raydir);
	val = environment(envmap, dir, dir, dir, dir, "lerp", 1);
    }
    return val;
}


vector
vop_trace(vector Nf, nN, PP, dir, atten, bg; string envmap;
	float bias, angle, thresh, jitter, density; string style;
	int samples; float nhit; string envobj;)
{
    nhit = 0;
    vector sum = 0;
    vector raydir = 0;
    float  atten_interp, dist;
    vector hitCf, hitOf, hitP;

    gather( PP, dir,
	    "Cf", hitCf,
	    "Of", hitOf,
	    "P",  hitP,
	    "ray:direction", raydir,
	    "samples", samples,
	    "bias", bias,
	    "angle", angle,
	    "raystyle", style,
	    "rayweight", thresh,
	    "samplebase", jitter,
	    "variancevar", "Cf")
    {

        atten_interp = 1;
        if ((dot(Nf, nN) > 0) && (dot(Nf, raydir) < 0) && (density > 0))
        {
            dist = length(hitP-PP);
            atten_interp = exp(-dist*density);
        }
        sum += lerp(atten, hitCf, atten_interp);

        if (max(hitOf) < 1)
        {
            sum += (set(1,1,1) - hitOf) *
                    vop_trace_environment(envmap, envobj, raydir, bg);
        }

        nhit += 1;
    }
    else
    {

        sum += vop_trace_environment(envmap, envobj, raydir, bg);
        nhit += 1;
    }
    return sum;
}


float
vop_weave(float ss, tt, sfreq, tfreq, width)
{
	float weave = 0;
	if ( sfreq > 0 && tfreq > 0 && width > 0)
	{

		float vv = tt * 0.5;
		float uu = (ss+vv) * sfreq;
		vv = (ss-vv) * tfreq;
		if (((int(floor(uu)) & 1) == 0) ) vv += 0.5;


		float warppulse = sqrt(abs(sin(uu * 3.1415926)));
		warppulse = smooth(1-width, 1, warppulse);

		float weftpulse = sqrt(abs(sin(vv * 3.1415926)));
		weftpulse = smooth(1-width, 1, weftpulse);


		float weft = lerp(0, 1, warppulse);
		weft = lerp(weft, 0, 1-warppulse);

		weft = lerp(0, weft, weftpulse);
		weft = lerp(weft, 0, 1-weftpulse);


		float warp = lerp(0, 1, weftpulse);
		warp = lerp(warp, 0, 1-weftpulse);

		warp = lerp(0, warp, warppulse);
		warp = lerp(warp, 0, 1-warppulse);

		weave = ((((int(floor(uu)) & 1) == 1) && ((int(floor(vv)) & 1) == 0)) ||
						(((int(floor(uu)) & 1) == 0) && ((int(floor(vv)) & 1) == 1))) ?
										weft : warp;
	}
	return weave;
}

vector
vop_toUnitNormal(vector Ni;)
{
    return Ni * 0.5 + 0.5;
}

vector
vop_fromUnitNormal(vector Ni;)
{
    return Ni * 2.0 - 1.0;
}

vector
vop_tangentNormal(vector Ni;
                  vector nn;
                  vector utan;
                  vector vtan;
                  int onspace;
                  int flipX;
                  int flipY;
                  float heightScale;)
{
    vector Nn   = normalize(nn);
    vector Nin  = lerp(Nn, Ni, heightScale);

    vector No;
    No.x = dot(Nin, utan);
    No.y = dot(Nin, vtan);
    No.z = dot(Nin, nn);
    No = normalize(No);

    if (flipX) { No.x = -No.x; }
    if (flipY) { No.y = -No.y; }

    if (onspace == 0) { No = vop_toUnitNormal(No); }

    return No;
}

vector
vop_tangentNormalRemap(vector Ni;
                       vector nn;
                       vector utan;
                       vector vtan;
                       int inspace;
                       int flipX;
                       int flipY;
                       float heightScale;)
{
    vector Nn   = normalize(nn);
    vector Vs	= normalize(utan);
    vector Vt	= normalize(vtan);
    vector Nin  = Ni;

    if (inspace == 0) { Nin = vop_fromUnitNormal(Nin); }

    if (flipX) { Nin.x = -Nin.x; }
    if (flipY) { Nin.y = -Nin.y; }

    matrix M;
    setcomp(M, Vs.x, 0, 0);
    setcomp(M, Vs.y, 0, 1);
    setcomp(M, Vs.z, 0, 2);
    setcomp(M, 0,    0, 3);
    setcomp(M, Vt.x, 1, 0);
    setcomp(M, Vt.y, 1, 1);
    setcomp(M, Vt.z, 1, 2);
    setcomp(M, 0,    1, 3);
    setcomp(M, Nn.x, 2, 0);
    setcomp(M, Nn.y, 2, 1);
    setcomp(M, Nn.z, 2, 2);
    setcomp(M, 0,    2, 3);
    setcomp(M, 0,    3, 0);
    setcomp(M, 0,    3, 1);
    setcomp(M, 0,    3, 2);
    setcomp(M, 1,    3, 3);

    vector No = normalize(ntransform(Nin, M));

    No = lerp(Nn, No, heightScale);

    return No;
}

vector
vop_bumpToNormalMap(string map;
                    int onspace;
                    int flipX;
                    int flipY;
                    float heightScale;
                    vector uv;)
{
    int xres = 0;
    teximport(map, "texture:xres", xres);
    int yres = 0;
    teximport(map, "texture:yres", yres);
    float dx = 1.0 / max(xres, yres);

    vector v00 = texture(map, uv.x-dx, uv.y-dx);
    vector v01 = texture(map, uv.x-dx, uv.y   );
    vector v02 = texture(map, uv.x-dx, uv.y+dx);
    vector v10 = texture(map, uv.x,    uv.y-dx);
    vector v12 = texture(map, uv.x,    uv.y+dx);
    vector v20 = texture(map, uv.x+dx, uv.y-dx);
    vector v21 = texture(map, uv.x+dx, uv.y   );
    vector v22 = texture(map, uv.x+dx, uv.y+dx);

    float f00 = luminance(v00);
    float f01 = luminance(v01);
    float f02 = luminance(v02);
    float f10 = luminance(v10);
    float f12 = luminance(v12);
    float f20 = luminance(v20);
    float f21 = luminance(v21);
    float f22 = luminance(v22);

    vector No;
    No.x = f20 + 2*f21 + f22 -f00 - 2*f01 - f02;
    No.y = f02 + 2*f12 + f22 -f00 - 2*f10 - f20;
    No.z = 1.0 / heightScale;
    if (flipX) { No.x = -No.x; }
    if (flipY) { No.y = -No.y; }
    No = normalize(No);

    if (onspace == 0) { No = vop_toUnitNormal(No); }

    return No;
}


void
vop_curvature(vector p;
              vector n;
              int mode;
              int space;
              int smooth;
              float tolerance;
              float convexscale;
              float convexbias;
              float concavescale;
              float concavebias;
              float biasmap;
              float Ko;)
{
    float xa = area(P);

    vector dPdu, dPdv;
    getderiv(p, "P", 0, s, t, dPdu, dPdv, "smooth", smooth);
    dPdu /= xa;
    dPdv /= xa;

    vector dNdu, dNdv;
    getderiv(n, "N", 0, s, t, dNdu, dNdv, "smooth", smooth);
    dNdu /= xa;
    dNdv /= xa;

    float a00 = dot(dPdu, dPdu);
    float a01 = dot(dPdu, dPdv);
    float a11 = dot(dPdv, dPdv);

    float b00 = -dot(dNdu, dPdu);
    float b01 = -(dot(dNdu, dPdv) + dot(dNdv, dPdu)) / 2;
    float b11 = -dot(dNdv, dPdv);

    float a = a00*a11 - a01*a01;
    float b = b00*b11 - b01*b01;
    float aa = max(abs(a), tolerance) * sign(a);

    float cn00 = a11 / aa;
    float cn01 = -a01 / aa;
    float cn11 = a00 / aa;

    float K = b / aa;
    float H = ((cn00*b00 + cn11*b11) / 2) + (cn01*b01);

    float Q = H*H - 4*K;
    float QQ = max(Q, 0);
    float SQ = sqrt(QQ);

    float p0 = (H + SQ) / 2;
    float p1 = (H - SQ) / 2;

    Ko = 0;

    if (mode == 0)
    {
        Ko = K;
    }
    else if (mode == 1)
    {
        Ko = -H;
    }

    float biasr = clamp(biasmap, 0, 1) - 0.5;
    if (Ko >  0) { Ko *= convexscale;  Ko =  vop_bias( Ko, clamp(convexbias  + biasr, 0, 1)); }
    if (Ko <= 0) { Ko *= concavescale; Ko = -vop_bias(-Ko, clamp(concavebias + biasr, 0, 1)); }

    if (space == 0)
    {
        Ko = fit(Ko, -1, 1, 0, 1);
    }
}
#line 868 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 870 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 871 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 873 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 874 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

void
uvxform(vector xformuvw;
	 vector uvw;
        int uvwIsConnected;
	 int trs;
	 int xyz;
	 vector trans;
	 vector rot;
	 vector scale;
	 vector pivot;
	 )
{
    if( uvwIsConnected != 0)
	xformuvw = uvw;
    else
	xformuvw = set(s, t, 0);
    xformuvw *= invert(maketransform(trs,xyz,trans,rot,scale,pivot));
}


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 895 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 897 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_bump_mapping_strlen1_snippet1(string str; int resultcharacter)
{
    resultcharacter = strlen(str);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 906 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 907 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 909 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 910 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 912 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_bump_mapping_displace2_swizzle(string order; vector vec)
{
    if(order == "xzy")
        vec = swizzle(vec, 0, 2, 1);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 922 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 924 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 926 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 928 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 929 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 931 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 933 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 934 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 936 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_normal_mapping_strlen1_snippet1(string str; int resultcharacter)
{
    resultcharacter = strlen(str);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 945 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_normal_mapping_displace2_swizzle(string order; vector vec)
{
    if(order == "xzy")
        vec = swizzle(vec, 0, 2, 1);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 955 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 957 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_bump_mapping1_strlen1_snippet1(string str; int resultcharacter)
{
    resultcharacter = strlen(str);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 966 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_bump_mapping1_displace2_swizzle(string order; vector vec)
{
    if(order == "xzy")
        vec = swizzle(vec, 0, 2, 1);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 976 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 978 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_normal_mapping1_strlen1_snippet1(string str; int resultcharacter)
{
    resultcharacter = strlen(str);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 987 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_normal_mapping1_displace2_swizzle(string order; vector vec)
{
    if(order == "xzy")
        vec = swizzle(vec, 0, 2, 1);

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 997 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 999 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1000 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1002 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1003 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1005 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1006 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1008 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1009 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1011 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1012 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1014 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1015 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1017 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1018 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1020 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1021 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1023 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1024 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1026 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1027 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1029 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1030 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1032 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1033 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1035 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1036 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1038 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1039 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1041 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1042 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1044 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1045 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 1048 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1051 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1052 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 1054 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1056 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1057 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/pbr.h"
#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 23 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/pbr.h"
#line 130 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/pbr.h"
vector
pbr_get_pixel(vector p;)
{
    vector res;
    renderstate("renderer:resolution", res);

    vector pr = ptransform("space:current", "space:ndc", p);
    pr.x *= res.x;
    pr.y *= res.y;
    pr.x = floor(pr.x);
    pr.y = floor(pr.y);
    pr.z = 0;

    return pr;
}






vector
pbr_sample_disc(float u;
                float v;
                float radius;
                float radiuspower)
{
    float r = sqrt(pow(u, radiuspower)) * radius;
    float theta = 6.2831852 * v;
    vector x;
    x.x = r * cos(theta);
    x.y = r * sin(theta);
    x.z = 0;

    return x;
}

void
pbr_increment_level(
	int pathstate;
	int reflectlevel;
	int refractlevel;
	int diffuselevel;
        int ssslevel;
	int volumelevel;
	string raystyle)
{
    pathstate &= bouncemask("all");
    if (pathstate & bouncemask("alldiffuse"))
    {
	diffuselevel++;
	raystyle = "diffuse";
    }
    else if (pathstate & bouncemask("allsss"))
    {
        ssslevel++;
        raystyle = "sss";
    }
    else if (pathstate & ((bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))) & ~bouncemask("allrefract")))
    {
	reflectlevel++;
	raystyle = "reflect";
    }
    else if (pathstate & bouncemask("allrefract"))
    {
	refractlevel++;
	raystyle = "refract";
    }
    else if (pathstate & bouncemask("allvolume"))
    {
	volumelevel++;
	raystyle = "diffuse";
    }
}

int
pbr_findlight(int lights[]; int lid; int end)
{
    for (int i = 0; i < end; i++)
	if (lights[i] == lid)
	    return i;
    return -1;
}

float
pbr_filterangle(float pdf; float amount)
{
    return amount / sqrt(pdf*16 + 4);
}

void
pbr_variance_settings(string prefix; int ismicropoly;
              int minsamples; int maxsamples;
              float threshold;
              float diffusequality;
              float sssquality;
              float refractionquality;
              float reflectionquality;)
{
    minsamples = maxsamples = 1;
    renderstate(prefix + "minraysamples", minsamples);
    renderstate(prefix + "maxraysamples", maxsamples);

    threshold = 0;
    if (maxsamples > minsamples)
    {
        renderstate(prefix + "variance", threshold);
        renderstate(prefix + "diffusequality", diffusequality);
        renderstate(prefix + "sssquality", sssquality);
        renderstate(prefix + "refractionquality", refractionquality);
        renderstate(prefix + "reflectionquality", reflectionquality);
    }

    if (!ismicropoly)
    {
        vector	vsamples = 0;
        renderstate("renderer:samples", vsamples);
        float	psamples = vsamples.x * vsamples.y;
        threshold *= sqrt(psamples);
    }
}

void
pbr_indirect_variance_settings(string prefix; int ismicropoly;
		      int minsamples; int maxsamples;
                      float threshold;
                      float diffusequality;
                      float sssquality;
                      float refractionquality;
                      float reflectionquality;
                      float volumequality;)
{
    minsamples = maxsamples = 1;
    int decoupleindirect = 0;
    renderstate(prefix + "decoupleindirect", decoupleindirect);
    if (decoupleindirect)
    {
        renderstate(prefix + "minindirectraysamples", minsamples);
        renderstate(prefix + "maxindirectraysamples", maxsamples);
    }
    else
    {
        renderstate(prefix + "minraysamples", minsamples);
        renderstate(prefix + "maxraysamples", maxsamples);
    }

    threshold = 0;
    float globalquality = 1.0;
    diffusequality = 1.0;
    sssquality = 1.0;
    refractionquality = 1.0;
    reflectionquality = 1.0;
    if (maxsamples > minsamples)
    {
        if (decoupleindirect)
            renderstate(prefix + "indirectvariance", threshold);
        else
            renderstate(prefix + "variance", threshold);

        renderstate(prefix + "globalquality", globalquality);
        renderstate(prefix + "diffusequality", diffusequality);
        renderstate(prefix + "sssquality", sssquality);
        renderstate(prefix + "refractionquality", refractionquality);
        renderstate(prefix + "reflectionquality", reflectionquality);
        renderstate(prefix + "volumequality", volumequality);

        diffusequality *= globalquality;
        sssquality *= globalquality;
        refractionquality *= globalquality;
        reflectionquality *= globalquality;
        volumequality *= globalquality;
    }

    if (!ismicropoly)
    {
	vector	vsamples = 0;
	renderstate("renderer:samples", vsamples);
	float	psamples = vsamples.x * vsamples.y;
	threshold *= sqrt(psamples);
    }
}





struct pbr_grid_f
{
    void resize(int resolution_;)
    {
        resolution = max(1, resolution_);
        dx = 1.0 / resolution;
        resize(buf, resolution*resolution);
    }

    void assign(float value;)
    {
        for (int i = 0; i < resolution*resolution; i++)
        {
            buf[i] = value;
        }
    }

    void addSample(float sx;
                   float sy;
                   float value;)
    {
        int ix = floor(sx * resolution);
        int iy = floor(sy * resolution);
        buf[iy*resolution + ix] += value;
    }

    void scale(float x;)
    {
        for (int i = 0; i < resolution*resolution; i++)
        {
            buf[i] *= x;
        }
    }

    float sum()
    {
        float x = 0;

        for (int i = 0; i < resolution*resolution; i++)
        {
            x += buf[i];
        }

        return x;
    }

    float average()
    {
        float x = this->sum();

        return x / (resolution*resolution);
    }

    void range(float vmin, vmax)
    {
        vmin = 1e6;
        vmax = -1e6;

        for (int i = 0; i < resolution*resolution; i++)
        {
            vmin = min(vmin, buf[i]);
            vmax = max(vmax, buf[i]);
        }
    }

    float variance()
    {
        float vmin = 1e6;
        float vmax = -1e6;
        this->range(vmin, vmax);

        return vmax - vmin;
    }

    void write(string filename;)
    {
        int i = 0;

        for (int y = 0; y < resolution; y++)
        {
            for (int x = 0; x < resolution; x++)
            {
                vector Pr;
                Pr.x = x;
                Pr.y = y;
                Pr.z = 0;

                vector Ce;
                Ce.x = buf[i];
                Ce.y = buf[i];
                Ce.z = buf[i];

                pcwrite(filename, "P", Pr, "Ce", Ce);

                i++;
            }
        }
    }

    int resolution;
    float dx;
    float buf[];
}





struct pbr_varianceaa
{
    void reset()
    {
        var = { 0, 0, 0, 0 };
        prevlum = { 0, 0, 0, 0 };
        done = 0;
        nsamples = { 0, 0, 0, 0 };
    }

    int numSamples()
    {
        return (nsamples[0] + nsamples[1] + nsamples[2] + nsamples[3]);
    }

    int atEnd()
    {
        return done;
    }

    void advance(int pathstate; vector value;
         int minsamples; int maxsamples;
         string colorspace;
         float threshold;
         float diffusequality;
         float sssquality;
         float refractionquality;
         float reflectionquality;)
    {
        int psi = ( pathstate & (bouncemask("alldiffuse") | bouncemask("allvolume")) ) ? 0 : ( pathstate & bouncemask("allsss") ) ? 1 : ( pathstate & bouncemask("allrefract") ) ? 2 : ( pathstate & bouncemask("all") ) ? 3 : 0;

        int wmaxsamples[] = {0, 0, 0, 0};
        wmaxsamples[0] = floor(maxsamples * diffusequality);
        wmaxsamples[1] = floor(maxsamples * sssquality);
        wmaxsamples[2] = floor(maxsamples * refractionquality);
        wmaxsamples[3] = floor(maxsamples * reflectionquality);

        if ((wmaxsamples[psi] > minsamples) && (nsamples[psi]+1) < wmaxsamples[psi])
        {
            float lum = luminance(value) / (nsamples[psi]+1);
            if (colorspace == "gamma")
            lum = sqrt(lum);

            int		samplesize;
            float	mean;
            float	newvar = variance(lum - prevlum[psi], mean, samplesize);

            var[psi] = (var[psi]*nsamples[psi] + newvar) / (nsamples[psi]+1);
            prevlum[psi] = lum;

            done = (nsamples[psi]+1) >= minsamples
                    && var[0] < (threshold*threshold * 1.0 / diffusequality)
                    && var[1] < (threshold*threshold * 1.0 / sssquality)
                    && var[2] < (threshold*threshold * 1.0 / refractionquality)
                    && var[3] < (threshold*threshold * 1.0 / reflectionquality);
        }
        else
        {
            done = (nsamples[psi]+1) >= minsamples;
        }

        nsamples[psi]++;
    }

    float   var[] = { 0, 0, 0, 0 };
    float   prevlum[] = { 0, 0, 0, 0 };
    int     done;
    int     nsamples[] = { 0, 0, 0, 0 };
}

pbr_varianceaa variance_start()
{
    return pbr_varianceaa();
}



struct pbr_lighting_parms {
    int		doshadow;
}






void
pbr_bounce_mask(int direct_bounces; int indirect_bounces;
		int shadow_bounces; int background_bounces;
		int direct_mask; int indirect_mask;
		string pathtype; int pathstate; int hitBounces;
		int reflectlevel; int reflectlimit;
		int refractlevel; int refractlimit;
		int diffuselevel; int diffuselimit;
                int ssslevel; int ssslimit;
		int volumelevel; int volumelimit;
		string raylimiteval; int raylimitmask;)
{

    if (pathtype == "diffuse" ||
	pathtype == "specular")
    {
        if (pathstate & (bouncemask("alldiffuse") | bouncemask("allvolume") | bouncemask("allsss")))
	{




            indirect_bounces = bouncemask("alldiffuse") | bouncemask("allvolume") | bouncemask("allsss");
            direct_bounces = bouncemask("alldiffuse") | bouncemask("allvolume") | bouncemask("allsss");
	}
	else
	{





	    indirect_bounces = bouncemask("all");
	    direct_bounces = bouncemask("all");
	}
    }
    else
    {
	indirect_bounces = bouncemask("all");
	direct_bounces = bouncemask("all");
    }


    direct_bounces &= direct_mask;
    indirect_bounces &= indirect_mask;


    raylimitmask = 0;
    if (reflectlevel >= reflectlimit)
        raylimitmask |= ((bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))) & ~bouncemask("allrefract"));
    if (refractlevel >= refractlimit)
        raylimitmask |= bouncemask("allrefract");
    if (diffuselevel >= diffuselimit)
        raylimitmask |= bouncemask("alldiffuse");
    if (ssslevel >= ssslimit)
    {
        raylimitmask |= bouncemask("allsss");

    }
    if (volumelevel >= volumelimit)
        raylimitmask |= bouncemask("allvolume");

    background_bounces = 0;
    shadow_bounces = direct_bounces;
    if (raylimiteval == "direct")
    {
        indirect_bounces &= ~(raylimitmask & ~(bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss"))));
        raylimitmask &= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
        shadow_bounces &= ~raylimitmask;
        background_bounces = raylimitmask;
    }
    else
    {
        indirect_bounces &= ~raylimitmask;
    }


    direct_bounces &= hitBounces;
    indirect_bounces &= hitBounces;
}

float
pbr_shadowmattecomp(float lit; float shad)
{
    return shad > 1e-6 ? max(1.0 - lit/shad, 0.0) : 0.0;
}

vector
pbr_shadowmatte(vector lit; vector shad)
{
    return (vector)pbr_shadowmattecomp(max(lit), max(shad));
}



float
pbr_clampCf(vector clr; float colorlimit)
{
    float	kscale = 1;
    float	lum = luminance(clr);
    if (colorlimit >= 0 && lum > colorlimit)
	kscale = colorlimit/lum;
    return kscale;
}

struct pbr_sss_trace_cache
{
    int seed = 0;
    vector exitN[];
    vector exitP[];
    vector throughput[];
};
#line 1058 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 1060 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/bsdf.h"




#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 5 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/bsdf.h"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/pbr.h"
#line 6 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/bsdf.h"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/ggx_utils.h"




#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 5 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/ggx_utils.h"

int SameHemisphere(vector w; vector wp) {
    return (w.z * wp.z) > 0.0f;
}

float sqr(float v) {
    return v*v;
}

float schlick_f(float u) {
    float m = clamp(1.0-u, 0.0, 1.0);
    float m2 = m*m;
    return m2*m2*m;
}

float smith_g(vector w; float alphax, alphay) {
    if (w.z <= 0.0) {
        return 0.0;
    }

    float tanTheta2 = (1 - w.z * w.z) / (w.z * w.z);
    float cosPhi = w.x;
    float sinPhi = w.y;

    float alpha2 = (cosPhi*cosPhi)*(alphax*alphax) + (sinPhi*sinPhi)*(alphay*alphay);
    alpha2 /= cosPhi*cosPhi + sinPhi*sinPhi;

    return 2.0 / (1.0 + sqrt(1.0 + alpha2 * tanTheta2));
}

vector ggx_albedo_estimate(const float cosTheta, rough, ior; const vector F0)
{
    float cosNI = 1.0 - abs(cosTheta);
    float tmp2 = pow(cosNI, lerp(5, 1.9, rough));

    float divide3 = sqr(ior-1) / sqr(ior+1);

    vector facing = F0 * fit01(pow(rough, 2.7), divide3, 0.31*divide3);
    float pow2 = pow(rough, 1-rough);
    vector grazing = (vector) lerp(1, rough * divide3 * 0.9, pow2);
    return select(ior > 1.000001, lerp(facing, grazing, tmp2), 0.0);
}


float computeD(vector wm; float alphax, alphay)
{
    return 1.0 / sqr(sqr(wm.x/alphax) + sqr(wm.y/alphay) + sqr(wm.z));
}






float computeDwi(vector wi, wm; float Gi, D)
{

    return Gi * abs(dot(wi, wm)) * D / abs(wi.z);
}

vector2 sample_ggx_slope(const float theta_i, sx, sy)
{
    vector2 slope;


    if(theta_i < 0.0001)
    {
	float r = sqrt(sx/(1-sx));
	float phi = 6.2831852 * sy;
	slope.x = r * cos(phi);
	slope.y = r * sin(phi);
	return slope;
    }


    float tan_theta_i = tan(theta_i);
    float a = 1 / (tan_theta_i);
    float G1 = 2 / (1 + sqrt(1.0+1.0/(a*a)));


    float A = 2.0*sx/G1 - 1.0;
    float tmp = 1.0 / (A*A-1.0);
    float B = tan_theta_i;
    float D = sqrt(B*B*tmp*tmp - (A*A-B*B)*tmp);
    float slope_x_1 = B*tmp - D;
    float slope_x_2 = B*tmp + D;
    slope.x = (A < 0 || slope_x_2 > 1.0/tan_theta_i) ? slope_x_1 : slope_x_2;


    float S = select(sy > 0.5, 1.0, -1.0);
    float sy_ = select(sy > 0.5, 2.0*(sy-0.5), 2.0*(0.5-sy));

    float z = (sy_*(sy_*(sy_*0.27385-0.73369)+0.46341)) / (sy_*(sy_*(sy_*0.093073+0.309420)-1.000000)+0.597999);
    slope.y = S * z * sqrt(1.0+slope.x*slope.x);

    return slope;
}

vector sample_ggx(const vector wi; const float alpha_x, alpha_y, sx, sy)
{

    vector wi_ = normalize(set(alpha_x * wi.x, alpha_y * wi.y, wi.z));


    int normalinc = wi_.z >= 0.99999;
    float theta_ = select(normalinc, 0.0, acos(wi_.z));
    float phi_ = select(normalinc, 0.0, atan2(wi_.y, wi_.x));


    vector2 slope = sample_ggx_slope(theta_, sx, sy);


    float tmp = cos(phi_)*slope.x - sin(phi_)*slope.y;
    slope.y = sin(phi_)*slope.x + cos(phi_)*slope.y;
    slope.x = tmp;


    slope.x = alpha_x * slope.x;
    slope.y = alpha_y * slope.y;


    return normalize(set(-slope.x, -slope.y, 1.0));
}
#line 7 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/bsdf.h"
#line 19 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/bsdf.h"
float
pbrspecular_toexponent(float width)
{
    float       costheta2;
    float       costheta2_clamped;
    float       exponent;

    costheta2 = max(width, 1e-5);
    costheta2 = 1-costheta2*costheta2;
    costheta2_clamped = max(costheta2, 0.1);

    exponent = -2*log(2)/log(costheta2_clamped) + 1;
    if (costheta2 < 0.1)
    {
        exponent = lerp(1.0, exponent, costheta2 / 0.1);
    }

    return exponent;
}

float
pbrspecular_rough_to_exponent(float roughness)
{
    return (2.0/(roughness*roughness)-2.0);
}

float
pbrspecular_rough_to_angle(float roughness)
{
    float invrough = 2.0/roughness;

    float costheta = exp(1.3862943611198906/(-invrough*invrough+6));



    return costheta > 1 ? 0.5 * 3.1415926 : acos(costheta);
}

float eta_to_fzero(float eta)
{
    return (eta*eta - 2.0*eta + 1.0) / (eta*eta + 2.0*eta + 1.0);
}

vector combined_fresnel_reflect(float eta, kr; vector F0)
{
#line 74 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/bsdf.h"
    float fresf0 = eta_to_fzero(eta);

    return lerp(fresf0*F0, {1,1,1}, fit(kr, fresf0, 1.0, 0.0, 1.0));
}

bsdf get_bsdf(string model; vector nNg, nN, nI, utan, vtan, F0;
	      float eta, rough, aniso, aniso_dir;
	      int masking, thinfilm, fresblend;
	      float reflect, refract, dispersion;
	      export float handled_energy; string reflectlabel, refractlabel)
{

    bsdf f, fr, ft = bsdf();
    handled_energy = 0.0;

    vector utan_ = utan;
    vector vtan_ = vtan;

    float kr;
    float kt;
    vector nR;
    vector nT;


    int perfect_spec = rough <= 1e-5;

    if (model != "ggx")
    {
	if(model != "ggx" && thinfilm)
	{
	    thinfresnel(nI, nN, eta, kr, kt, nR, nT);
	}
	else
	{
	    fresnel(nI, nN, eta, kr, kt, nR, nT);
	}
    }

    float dotNI = dot(nN, nI);

    vector flippedNR = select(dotNI > 0, -nN, nN);
    vector flippedNT = select(dotNI < 0, -nN, nN);

    if (!perfect_spec || model == "ggx")
    {
        float       uexp, vexp;
        float       rough2;

        if(model == "blinn" || model == "ggx")
        {

            rough2 = rough*rough;
        }
        else
        {
            rough2 = rough;
        }

        uexp = vexp = pbrspecular_rough_to_exponent(rough2);

        if ((model != "cone" && abs(aniso) > 1e-5) && !perfect_spec)
        {
            if (aniso_dir != 0)
            {
                matrix3 rot = ident();
                rotate(rot, 3.1415926 * aniso_dir, cross(utan_, vtan_));
                utan_ *= rot;
                vtan_ *= rot;
            }



            if (aniso < 0)
                uexp *= pbrspecular_toexponent(1+(aniso));
            else
                vexp *= pbrspecular_toexponent(1-(aniso));

            if (model == "blinn")
            {
                fr = ashikhmin(flippedNR, uexp, vexp, utan_, vtan_, "label", reflectlabel);
            }
            else if (model == "ggx")
            {

                vtan_ = normalize(cross(nN,utan_));
                utan_ = normalize(cross(nN,vtan_));

                int flip = aniso < 0;

                float aspect = sqrt(1.0-abs(aniso)*0.9);
                float alphax = max(0.001, rough2/aspect);
                float alphay = max(0.001, rough2*aspect);

		f = cvex_bsdf(
			       "oplib:/Shop/ggx_eval?Shop/ggx_eval",
			       "oplib:/Shop/ggx_sample?Shop/ggx_sample",
			       "label", reflectlabel + " " + refractlabel,
			       "ng", nNg,
			       "nn", nN,
			       "xg", select(flip, vtan_, utan_),
			       "yg", select(flip, utan_, vtan_),
			       "F0", F0,
			       "alphax", alphax,
			       "alphay", alphay,
			       "masking", masking,
			       "fresblend", fresblend,
			       "eta", eta,
			       "reflect", reflect,
			       "refract", refract,
			       "reflectmask", bouncemask(reflectlabel),
			       "refractmask", bouncemask(refractlabel),
			       "dispersion", dispersion);
            }
            else
            {
                fr = phonglobe(flippedNR, nR, uexp, vexp, utan_, vtan_, "label", reflectlabel);
                ft = phonglobe(flippedNT, nT, uexp, vexp, utan_, vtan_, "label", refractlabel);
            }
        }
        else
        {
            if (model == "cone")
            {
                float newangle = pbrspecular_rough_to_angle(rough2);
                fr = cone(flippedNR, nR, newangle, "label", reflectlabel);
                ft = cone(flippedNT, nT, newangle, "label", refractlabel);
            }
            else if (model == "blinn")
            {
                fr = blinn(flippedNR, uexp, "label", reflectlabel);
            }
            else if(model == "ggx")
            {

		matrix3 to_world = dihedral({0.0,0.0,1.0}, nN);
		utan_ = {1,0,0} * to_world;
		vtan_ = {0,1,0} * to_world;

                int flip = aniso < 0;

                float alpha = max(0.001, rough2);

		f = cvex_bsdf(
			       "oplib:/Shop/ggx_eval?Shop/ggx_eval",
			       "oplib:/Shop/ggx_sample?Shop/ggx_sample",
			       "label", reflectlabel + " " + refractlabel,
			       "ng", nNg,
			       "nn", nN,
			       "xg", select(flip, vtan_, utan_),
			       "yg", select(flip, utan_, vtan_),
			       "F0", F0,
			       "alphax", alpha,
			       "alphay", alpha,
			       "masking", masking,
			       "fresblend", fresblend,
			       "eta", eta,
			       "reflect", reflect,
			       "refract", refract,
			       "reflectmask", bouncemask(reflectlabel),
			       "refractmask", bouncemask(refractlabel),
			       "dispersion", dispersion);
            }
            else
            {
                fr = phonglobe(flippedNR, nR, uexp, "label", reflectlabel);
                ft = phonglobe(flippedNT, nT, uexp, "label", refractlabel);
            }
        }
	if(model != "ggx")
	{
	    f  *= 1.0 / luminance(albedo(f));
	    fr *= 1.0 / luminance(albedo(fr));
	    ft *= 1.0 / luminance(albedo(ft));
	}
    }
    else
    {
	fr = specular(nR, "label", reflectlabel);
	ft = specular(nT, "label", refractlabel);
    }








    if (model != "ggx")
    {
	vector trans_int;
	vector refl_int;
	int handle_both = reflect > 0 && refract > 0;
	if(fresblend || handle_both)
	{
	    if(fresblend)
	    {
		kt = 1.0 - (reflect*kr);
		handled_energy = lerp(reflect * kr, 1, refract);
	    }
	    else
	    {
		kr = 1;
		kt = 1;
		handled_energy = refract;
	    }

	    refl_int = reflect * combined_fresnel_reflect(eta, kr, F0);
	    trans_int = refract * kt;

	    f = trans_int * ft + refl_int * fr;

	}
	else
	{
	    float schlick = schlick_f(abs(dot(nN, nI)));
	    trans_int = refract;
	    refl_int = reflect * F0 + (1.0-F0) * schlick;
	    f = select(refract > 0, ft * trans_int, fr * refl_int);
	    handled_energy = refract;
	}
    }
    else
    {
	float est_eta = select(fresblend, 1.0/eta, 0.0);
	vector estimate = ggx_albedo_estimate(dot(nN, nI), rough, est_eta, F0);
	handled_energy = lerp(reflect * luminance(estimate), 1.0, refract);
    }

    return f;
}

bsdf get_bsdf(string model, label; vector nNg, nN, nI, utan, vtan, F0; float eta, rough, aniso, aniso_dir; int masking, thinfilm, fresblend)
{
    float handled_energy;
    float refract = (bouncemask(label) & bouncemask("allrefract")) > 0;
    float reflect = refract == 0;
    float dispersion = 0;
    return get_bsdf(model, nNg, nN, nI, utan, vtan, F0, eta, rough, aniso, aniso_dir, masking, thinfilm, fresblend, reflect, refract, dispersion, handled_energy, label, label);
}

bsdf get_bsdf(string model, label; vector nNg, nN, nI, utan, vtan; vector F0; float eta, rough, aniso, aniso_dir; int masking, thinfilm)
{
    return get_bsdf(model, label, nNg, nN, nI, utan, vtan, F0, eta, rough, aniso, aniso_dir, masking, thinfilm, 0              );
}

bsdf get_bsdf(string model, label; vector nNg, nN, nI, utan, vtan; vector F0; float eta, rough, aniso, aniso_dir; int masking)
{
    return get_bsdf(model, label, nNg, nN, nI, utan, vtan, F0, eta, rough, aniso, aniso_dir, masking, 0             , 0              );
}
#line 1062 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 1063 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/shaderlayer.h"
#line 1065 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

import pbrlighting;


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/math.h"
#line 1069 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
void
_mat_materialbuilder1_principledshader1_add_layer_exports(ShaderLayer layer; vector export_diffcolor; vector export_speccolor; float export_metallic; vector export_basecolor; float export_reflect; float export_reflecttint; float export_specrough; float export_aniso; float export_anisodir; float export_sss; float export_sssdist; vector export_ssscolor; float export_sheen; float export_sheentint; float export_coatrough; float export_coat; vector export_emitcolor; float export_emitint; vector export_uv)
{
    int bake_layerexport = 0;
    renderstate("global:bake_layerexport", bake_layerexport);

    if(!bake_layerexport)
        return;


    int numf = len(layer.exports.names_f);
    resize(layer.exports.names_f, numf + 17-4);
    layer.exports.names_f[numf] = "export_metallic";
    layer.exports.values_f[numf++] = export_metallic;








    layer.exports.names_f[numf] = "export_reflect";
    layer.exports.values_f[numf++] = export_reflect;
    layer.exports.names_f[numf] = "export_reflecttint";
    layer.exports.values_f[numf++] = export_reflecttint;
    layer.exports.names_f[numf] = "export_specrough";
    layer.exports.values_f[numf++] = export_specrough;
    layer.exports.names_f[numf] = "export_aniso";
    layer.exports.values_f[numf++] = export_aniso;
    layer.exports.names_f[numf] = "export_anisodir";
    layer.exports.values_f[numf++] = export_anisodir;
    layer.exports.names_f[numf] = "export_sss";
    layer.exports.values_f[numf++] = export_sss;
    layer.exports.names_f[numf] = "export_sssdist";
    layer.exports.values_f[numf++] = export_sssdist;
    layer.exports.names_f[numf] = "export_sheen";
    layer.exports.values_f[numf++] = export_sheen;
    layer.exports.names_f[numf] = "export_sheentint";
    layer.exports.values_f[numf++] = export_sheentint;
    layer.exports.names_f[numf] = "export_coatrough";
    layer.exports.values_f[numf++] = export_coatrough;
    layer.exports.names_f[numf] = "export_coat";
    layer.exports.values_f[numf++] = export_coat;
    layer.exports.names_f[numf] = "export_emitint";
    layer.exports.values_f[numf++] = export_emitint;


    int numv = len(layer.exports.names_v);
    resize(layer.exports.names_v, numv + 7-1);
    layer.exports.names_v[numv] = "export_diffcolor";
    layer.exports.values_v[numv++] = export_diffcolor;
    layer.exports.names_v[numv] = "export_speccolor";
    layer.exports.values_v[numv++] = export_speccolor;
    layer.exports.names_v[numv] = "export_basecolor";
    layer.exports.values_v[numv++] = export_basecolor;


    layer.exports.names_v[numv] = "export_ssscolor";
    layer.exports.values_v[numv++] = export_ssscolor;
    layer.exports.names_v[numv] = "export_emitcolor";
    layer.exports.values_v[numv++] = export_emitcolor;
    layer.exports.names_v[numv] = "export_uv";
    layer.exports.values_v[numv++] = export_uv;

}



#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1138 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1139 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"


#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voptype.h"
#line 1141 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"

#line 1 "/cgsoft/sesi/hfs16.5.691/houdini/vex/include/voplib.h"
#line 1142 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
surface
mat_materialbuilder1_principledshader1(string surface_textureFilter = "catrom";
	float surface_textureFilterWidth = 1;
	vector uv = {0, 0, 0};
	string difflabel = "diffuse";
	string refllabel = "reflect";
	string coatlabel = "coat";
	float anisodir = 0;
	vector emitcolor = { 0, 0, 0 };
	int emitcolor_useTexture = 0;
	string emitcolor_texture = "";
	string emitcolor_textureWrap = "repeat";
	float emitcolor_textureIntensity = 1;
	int emitillum = 1;
	float emitint = 1;
	int anisodir_monoChannel = 0;
	int anisodir_useTexture = 0;
	string anisodir_texture = "";
	string anisodir_textureWrap = "repeat";
	string anisodir_textureFilter = "point";
	string baseBumpAndNormal_type = "normal";
	string baseBump_colorSpace = "linear";
	string baseNormal_vectorSpace = "uvtangent";
	string baseBump_wrap = "repeat";
	string baseBump_filter = "gauss";
	float baseBump_filterWidth = 1;
	int baseBump_channel = 0;
	string baseBump_imagePlane = "";
	int baseNormal_space = 0;
	int baseNormal_flipX = 0;
	int baseNormal_flipY = 0;
	string basecolor_textureColorSpace = "auto";
	string metallic_textureColorSpace = "linear";
	string reflecttint_textureColorSpace = "linear";
	string rough_textureColorSpace = "linear";
	string aniso_textureColorSpace = "linear";
	string sss_textureColorSpace = "linear";
	string sheentint_textureColorSpace = "linear";
	string coatrough_textureColorSpace = "linear";
	string sheen_textureColorSpace = "linear";
	string coat_textureColorSpace = "linear";
	string emitcolor_textureColorSpace = "repeat";
	vector Cd = { 1, 1, 1 };
	float Alpha = 1;
	vector basecolor = { 0.20000000000000001, 0.20000000000000001, 0.20000000000000001 };
	int basecolor_usePointColor = 1;
	int basecolor_useTexture = 0;
	string basecolor_texture = "";
	string basecolor_textureWrap = "repeat";
	float basecolor_textureIntensity = 1;
	int metallic_monoChannel = 0;
	int metallic_useTexture = 0;
	string metallic_texture = "";
	string metallic_textureWrap = "repeat";
	int basecolor_usePackedColor = 0;
	int baseBumpAndNormal_enable = 0;
	int separateCoatNormals = 0;
	float metallic = 0;
	int reflecttint_monoChannel = 0;
	int reflecttint_useTexture = 0;
	string reflecttint_texture = "";
	string reflecttint_textureWrap = "repeat";
	float reflecttint = 0;
	int rough_monoChannel = 0;
	int rough_useTexture = 0;
	string rough_texture = "";
	string rough_textureWrap = "repeat";
	float rough = 0.29999999999999999;
	int aniso_monoChannel = 0;
	int aniso_useTexture = 0;
	string aniso_texture = "";
	string aniso_textureWrap = "repeat";
	float aniso = 0;
	int sss_monoChannel = 0;
	int sss_useTexture = 0;
	string sss_texture = "";
	string sss_textureWrap = "repeat";
	float sss = 0;
	int sheen_monoChannel = 0;
	int sheen_useTexture = 0;
	string sheen_texture = "";
	string sheen_textureWrap = "repeat";
	float sheen = 0;
	int sheentint_monoChannel = 0;
	int sheentint_useTexture = 0;
	string sheentint_texture = "";
	string sheentint_textureWrap = "repeat";
	float sheentint = 0;
	int coat_monoChannel = 0;
	int coat_useTexture = 0;
	string coat_texture = "";
	string coat_textureWrap = "repeat";
	float coat = 0;
	int coatrough_monoChannel = 0;
	int coatrough_useTexture = 0;
	string coatrough_texture = "";
	string coatrough_textureWrap = "repeat";
	float coatrough = 0;
	string baseBump_bumpTexture = "";
	float baseBump_bumpScale = 0.050000000000000003;
	string baseNormal_colorspace = "linear";
	string baseNormal_wrap = "repeat";
	string baseNormal_filter = "gauss";
	float baseNormal_filterWidth = 1;
	int baseNormal_channel = 0;
	string baseNormal_imagePlane = "";
	string baseNormal_texture = "";
	float baseNormal_scale = 1;
	vector2 uvtrans = { 0, 0 };
	float uvrot = 0;
	vector2 uvscale = { 1, 1 };
	string coatBumpAndNormal_type = "normal";
	string coatBump_colorSpace = "linear";
	string coatNormal_vectorSpace = "uvtangent";
	string coatBump_wrap = "repeat";
	string coatBump_filter = "gauss";
	float coatBump_filterWidth = 1;
	int coatBump_channel = 0;
	string coatBump_imagePlane = "";
	int coatNormal_space = 0;
	int coatNormal_flipX = 0;
	int coatNormal_flipY = 0;
	int coatBumpAndNormal_enable = 1;
	string coatBump_bumpTexture = "";
	float coatBump_bumpScale = 0.050000000000000003;
	string coatNormal_colorspace = "linear";
	string coatNormal_wrap = "repeat";
	string coatNormal_filter = "gauss";
	float coatNormal_filterWidth = 1;
	int coatNormal_channel = 0;
	string coatNormal_imagePlane = "";
	string coatNormal_texture = "";
	float coatNormal_scale = 1;
	string sssdist_textureColorSpace = "linear";
	int sssdist_monoChannel = 0;
	int sssdist_useTexture = 0;
	string sssdist_texture = "";
	string sssdist_textureWrap = "repeat";
	float sssdist = 0.10000000000000001;
	string ssscolor_textureColorSpace = "linear";
	int ssscolor_useTexture = 0;
	string ssscolor_texture = "";
	string ssscolor_textureWrap = "repeat";
	vector ssscolor = { 1, 1, 1 };
	string ssslabel = "sss";
	export ShaderLayer layer = {};
	export vector export_basecolor = { 0, 0, 0 };
	export vector export_diffcolor = { 0, 0, 0 };
	export float export_metallic = 0;
	export float export_reflecttint = 0;
	export float export_specrough = 0;
	export float export_aniso = 0;
	export float export_anisodir = 0;
	export float export_sss = 0;
	export float export_sssdist = 0;
	export vector export_ssscolor = { 0, 0, 0 };
	export float export_sheen = 0;
	export float export_sheentint = 0;
	export float export_coatrough = 0;
	export float export_coat = 0;
	export vector export_emitcolor = { 0, 0, 0 };
	export float export_emitint = 0;
	export vector export_speccolor = { 0, 0, 0 };
	export vector Oc = { 0, 0, 0 };
	export vector Cv = { 0, 0, 0 };
	export vector Th = { 0, 0, 0 };
	export vector Ab = { 0, 0, 0 };
	export vector Cu = { 0, 0, 0 };
	export vector Vd = { 0, 0, 0 };
	export vector Nt = { 0, 0, 0 };
	export vector Ds = { 0, 0, 0 };
	export vector Vdt = { 0, 0, 0 };
	float curvatureConvex = 0;
	float curvatureConcave = 0;
	export vector direct = { 0, 0, 0 };
	export vector indirect = { 0, 0, 0 };
	export vector Ce = { 0, 0, 0 };
	export vector direct_emission = { 0, 0, 0 };
	export vector all_emission = { 0, 0, 0 };
	export vector all = { 0, 0, 0 };
	export vector indirect_emission = { 0, 0, 0 };
	export vector direct_comp[] = {};
	export vector indirect_comp[] = {};
	export vector all_comp[] = {};
	export vector direct_noshadow = { 0, 0, 0 };
	export vector direct_shadow = { 0, 0, 0 };
	export vector indirect_noshadow = { 0, 0, 0 };
	export vector indirect_shadow = { 0, 0, 0 };
	export float level = 0;
	export float diffuselevel = 0;
	export float specularlevel = 0;
	export float volumelevel = 0;
	export float direct_samples = 0;
	export float indirect_samples = 0;
	export float nlights = 0;
	export vector direct_noshadow_comp[] = {};
	export vector indirect_noshadow_comp[] = {};
	export float nddispersion = 0;
	export float ndpriority = 0;
	export float ndior = 0;
	export vector absorption = { 0, 0, 0 };
	string reflect_textureColorSpace = "linear";
	int reflect_monoChannel = 0;
	int reflect_useTexture = 0;
	string reflect_texture = "";
	string reflect_textureWrap = "repeat";
	float reflect = 1;
	export float export_reflect = 0;
	vector baseN = { 0, 0, 0 };
	vector coatN = { 0, 0, 0 };
	float coatlightcull = 1;
	export vector albedo = { 0, 0, 0 };
	float top_layer_ior = 1)
{
    int	bound_baseN;
    int	bound_coatN;
    float	export_reflect_tmp;
    vector	export_diffcolor_tmp;
    vector	export_speccolor_tmp;
    float	export_metallic_tmp;
    vector	export_basecolor_tmp;
    float	export_reflecttint_tmp;
    float	export_specrough_tmp;
    float	export_aniso_tmp;
    float	export_anisodir_tmp;
    float	export_sss_tmp;
    float	export_sssdist_tmp;
    vector	export_ssscolor_tmp;
    float	export_sheen_tmp;
    float	export_sheentint_tmp;
    float	export_coatrough_tmp;
    float	export_coat_tmp;
    vector	export_emitcolor_tmp;
    float	export_emitint_tmp;
    int	bool1;
    vector	nvec;
    vector	nvec1;
    vector	result;
    int	bool2;
    vector	uv2;
    int	bound_uv;
    vector	uv3;
    vector	result1;
    vector	result2;
    float	fval1;
    float	fval2;
    float	fval3;
    vector	output1;
    vector	vec;
    vector	output11;
    vector	xformuvw;
    vector	uv4;
    int	bound_uv1;
    vector	result3;
    float	fval11;
    float	fval21;
    float	fval31;
    vector	clr;
    int	Value;
    string	outstr;
    int	outresultcharacter;
    int	bool3;
    float	product;
    int	bool4;
    int	bool5;
    int	scaled;
    int	bool6;
    int	scaled1;
    int	sum;
    vector	result4;
    vector	result5;
    vector	nvec2;
    float	lum;
    float	fval12;
    float	fval22;
    float	fval32;
    float	result6;
    float	sum1;
    vector	dispP;
    vector	dispN;
    vector	product1;
    string	outorder;
    vector	outvec;
    vector	uv5;
    int	bound_uv2;
    vector	result7;
    int	bool7;
    int	bool8;
    int	connected;
    vector	result8;
    vector	nvec3;
    vector4	quat;
    string	tstyle;
    vector	in_utan;
    vector	in_vtan;
    vector	nml;
    vector	uv6;
    int	bound_uv3;
    vector	result9;
    vector	uv7;
    vector	utan;
    vector	vtan;
    vector	result10;
    vector	result11;
    vector	result12;
    vector	result13;
    float	fval13;
    float	fval23;
    float	fval33;
    float	fval14;
    float	fval24;
    float	fval34;
    float	fval15;
    float	fval25;
    float	fval35;
    matrix3	matx;
    matrix	xform;
    matrix3	m3;
    matrix3	result14;
    matrix	xform1;
    matrix3	m31;
    matrix3	result15;
    vector	product2;
    vector	sum2;
    vector	result16;
    vector	dispP1;
    vector	dispN1;
    vector	Ns;
    vector	Nf;
    vector	product3;
    vector	nvec4;
    float	dotprod;
    float	trig;
    vector	crossprod;
    vector	nvec5;
    vector4	quat1;
    vector4	blend;
    vector	result17;
    vector	newN;
    vector	result18;
    vector	Value1;
    vector	diff;
    vector	result19;
    float	Value2;
    float	product4;
    float	len;
    float	result20;
    vector	uv8;
    int	bound_uv4;
    vector	result21;
    float	fval16;
    float	fval26;
    float	fval36;
    vector	clr1;
    int	Value3;
    string	outstr1;
    int	outresultcharacter1;
    int	bool9;
    float	product5;
    int	bool10;
    int	bool11;
    int	scaled2;
    int	bool12;
    int	scaled3;
    int	sum3;
    vector	result22;
    vector	result23;
    vector	nvec6;
    float	lum1;
    float	fval17;
    float	fval27;
    float	fval37;
    float	result24;
    float	sum4;
    vector	dispP2;
    vector	dispN2;
    vector	product6;
    string	outorder1;
    vector	outvec1;
    vector	uv9;
    int	bound_uv5;
    vector	result25;
    int	bool13;
    int	bool14;
    int	connected1;
    vector	result26;
    vector	nvec7;
    vector4	quat2;
    string	tstyle1;
    vector	in_utan1;
    vector	in_vtan1;
    vector	nml1;
    vector	uv10;
    int	bound_uv6;
    vector	result27;
    vector	uv11;
    vector	utan1;
    vector	vtan1;
    vector	result28;
    vector	result29;
    vector	result30;
    vector	result31;
    float	fval18;
    float	fval28;
    float	fval38;
    float	fval19;
    float	fval29;
    float	fval39;
    float	fval110;
    float	fval210;
    float	fval310;
    matrix3	matx1;
    matrix	xform2;
    matrix3	m32;
    matrix3	result32;
    matrix	xform3;
    matrix3	m33;
    matrix3	result33;
    vector	product7;
    vector	sum5;
    vector	result34;
    vector	dispP3;
    vector	dispN3;
    vector	Ns1;
    vector	Nf1;
    vector	product8;
    vector	nvec8;
    float	dotprod1;
    float	trig1;
    vector	crossprod1;
    vector	nvec9;
    vector4	quat3;
    vector4	blend1;
    vector	result35;
    vector	newN1;
    vector	result36;
    vector	Value4;
    vector	diff1;
    vector	result37;
    float	Value5;
    float	product9;
    float	len1;
    float	result38;
    vector	result39;
    vector	result40;
    int	bool15;
    vector	nvec10;
    vector	result41;
    vector	uv12;
    int	bound_uv7;
    vector	result42;
    float	fval111;
    float	fval211;
    float	fval311;
    vector	clr2;
    int	Value6;
    string	outstr2;
    int	outresultcharacter2;
    int	bool16;
    float	product10;
    int	bool17;
    int	bool18;
    int	scaled4;
    int	bool19;
    int	scaled5;
    int	sum6;
    vector	result43;
    vector	result44;
    vector	nvec11;
    float	lum2;
    float	fval112;
    float	fval212;
    float	fval312;
    float	result45;
    float	sum7;
    vector	dispP4;
    vector	dispN4;
    vector	product11;
    string	outorder2;
    vector	outvec2;
    vector	uv13;
    int	bound_uv8;
    vector	result46;
    int	bool20;
    int	bool21;
    int	connected2;
    vector	result47;
    vector	nvec12;
    vector4	quat4;
    string	tstyle2;
    vector	in_utan2;
    vector	in_vtan2;
    vector	nml2;
    vector	uv14;
    int	bound_uv9;
    vector	result48;
    vector	uv15;
    vector	utan2;
    vector	vtan2;
    vector	result49;
    vector	result50;
    vector	result51;
    vector	result52;
    float	fval113;
    float	fval213;
    float	fval313;
    float	fval114;
    float	fval214;
    float	fval314;
    float	fval115;
    float	fval215;
    float	fval315;
    matrix3	matx2;
    matrix	xform4;
    matrix3	m34;
    matrix3	result53;
    matrix	xform5;
    matrix3	m35;
    matrix3	result54;
    vector	product12;
    vector	sum8;
    vector	result55;
    vector	dispP5;
    vector	dispN5;
    vector	Ns2;
    vector	Nf2;
    vector	product13;
    vector	nvec13;
    float	dotprod2;
    float	trig2;
    vector	crossprod2;
    vector	nvec14;
    vector4	quat5;
    vector4	blend2;
    vector	result56;
    vector	newN2;
    vector	result57;
    vector	Value7;
    vector	diff2;
    vector	result58;
    float	Value8;
    float	product14;
    float	len2;
    float	result59;
    vector	uv16;
    int	bound_uv10;
    vector	result60;
    float	fval116;
    float	fval216;
    float	fval316;
    vector	clr3;
    int	Value9;
    string	outstr3;
    int	outresultcharacter3;
    int	bool22;
    float	product15;
    int	bool23;
    int	bool24;
    int	scaled6;
    int	bool25;
    int	scaled7;
    int	sum9;
    vector	result61;
    vector	result62;
    vector	nvec15;
    float	lum3;
    float	fval117;
    float	fval217;
    float	fval317;
    float	result63;
    float	sum10;
    vector	dispP6;
    vector	dispN6;
    vector	product16;
    string	outorder3;
    vector	outvec3;
    vector	uv17;
    int	bound_uv11;
    vector	result64;
    int	bool26;
    int	bool27;
    int	connected3;
    vector	result65;
    vector	nvec16;
    vector4	quat6;
    string	tstyle3;
    vector	in_utan3;
    vector	in_vtan3;
    vector	nml3;
    vector	uv18;
    int	bound_uv12;
    vector	result66;
    vector	uv19;
    vector	utan3;
    vector	vtan3;
    vector	result67;
    vector	result68;
    vector	result69;
    vector	result70;
    float	fval118;
    float	fval218;
    float	fval318;
    float	fval119;
    float	fval219;
    float	fval319;
    float	fval120;
    float	fval220;
    float	fval320;
    matrix3	matx3;
    matrix	xform6;
    matrix3	m36;
    matrix3	result71;
    matrix	xform7;
    matrix3	m37;
    matrix3	result72;
    vector	product17;
    vector	sum11;
    vector	result73;
    vector	dispP7;
    vector	dispN7;
    vector	Ns3;
    vector	Nf3;
    vector	product18;
    vector	nvec17;
    float	dotprod3;
    float	trig3;
    vector	crossprod3;
    vector	nvec18;
    vector4	quat7;
    vector4	blend3;
    vector	result74;
    vector	newN3;
    vector	result75;
    vector	Value10;
    vector	diff3;
    vector	result76;
    float	Value11;
    float	product19;
    float	len3;
    float	result77;
    vector	result78;
    vector	result79;
    vector	result80;
    int	connected4;
    vector	result81;
    vector	nvec19;
    vector4	quat8;
    string	tstyle4;
    vector	in_utan4;
    vector	in_vtan4;
    vector	nml4;
    vector	uv20;
    int	bound_uv13;
    vector	result82;
    vector	uv21;
    vector	utan4;
    vector	vtan4;
    vector	result83;
    vector	result84;
    vector	result85;
    vector	result86;
    vector	result87;
    vector	result88;
    vector	val;
    int	found;
    vector	result89;
    int	bool28;
    vector	uv23;
    int	bound_uv14;
    vector	uv24;
    vector	result90;
    vector	result91;
    float	fval121;
    float	fval221;
    float	fval321;
    vector	result92;
    vector	_uv15;
    vector4	clr5;
    vector4	result93;
    vector	vec1;
    float	fval4;
    float	lum4;
    float	fval122;
    float	fval222;
    float	fval322;
    float	result94;
    vector	vec2;
    vector	result95;
    float	clamp;
    vector	blend4;
    float	clamp1;
    vector	product20;
    vector	product21;
    float	result96;
    float	val1;
    int	found1;
    float	result97;
    float	product22;
    vector	output12;
    vector	result98;
    vector	result99;
    vector	val2;
    int	found2;
    vector	result100;
    int	bool29;
    vector	uv26;
    int	bound_uv15;
    vector	uv27;
    vector	result101;
    vector	result102;
    float	fval123;
    float	fval223;
    float	fval323;
    vector	result103;
    vector	_uv18;
    vector4	clr7;
    vector4	result104;
    vector	vec3;
    float	fval41;
    float	lum5;
    float	fval124;
    float	fval224;
    float	fval324;
    float	result105;
    vector	vec4;
    vector	result106;
    float	clamp2;
    vector	blend5;
    float	clamp3;
    vector	product23;
    vector	product24;
    float	result107;
    float	val3;
    int	found3;
    float	result108;
    float	product25;
    float	output13;
    float	output2;
    float	output3;
    vector	output14;
    vector	result109;
    vector	result110;
    vector	val4;
    int	found4;
    vector	result111;
    int	bool30;
    vector	uv29;
    int	bound_uv16;
    vector	uv30;
    vector	result112;
    vector	result113;
    float	fval125;
    float	fval225;
    float	fval325;
    vector	result114;
    vector	_uv21;
    vector4	clr9;
    vector4	result115;
    vector	vec5;
    float	fval42;
    float	lum6;
    float	fval126;
    float	fval226;
    float	fval326;
    float	result116;
    vector	vec6;
    vector	result117;
    float	clamp4;
    vector	blend6;
    float	clamp5;
    vector	product26;
    vector	product27;
    float	result118;
    float	val5;
    int	found5;
    float	result119;
    float	product28;
    float	output15;
    float	output21;
    float	output31;
    vector	output16;
    vector	result120;
    vector	result121;
    vector	val6;
    int	found6;
    vector	result122;
    int	bool31;
    vector	uv32;
    int	bound_uv17;
    vector	uv33;
    vector	result123;
    vector	result124;
    float	fval127;
    float	fval227;
    float	fval327;
    vector	result125;
    vector	_uv24;
    vector4	clr11;
    vector4	result126;
    vector	vec7;
    float	fval43;
    float	lum7;
    float	fval128;
    float	fval228;
    float	fval328;
    float	result127;
    vector	vec8;
    vector	result128;
    float	clamp6;
    vector	blend7;
    float	clamp7;
    vector	product29;
    vector	product30;
    float	result129;
    float	val7;
    int	found7;
    float	result130;
    float	product31;
    float	output17;
    float	output22;
    float	output32;
    vector	output18;
    vector	result131;
    vector	result132;
    vector	val8;
    int	found8;
    vector	result133;
    int	bool32;
    vector	uv35;
    int	bound_uv18;
    vector	uv36;
    vector	result134;
    vector	result135;
    float	fval129;
    float	fval229;
    float	fval329;
    vector	result136;
    vector	_uv27;
    vector4	clr13;
    vector4	result137;
    vector	vec9;
    float	fval44;
    float	lum8;
    float	fval130;
    float	fval230;
    float	fval330;
    float	result138;
    vector	vec10;
    vector	result139;
    float	clamp8;
    vector	blend8;
    float	clamp9;
    vector	product32;
    vector	product33;
    float	result140;
    float	val9;
    int	found9;
    float	result141;
    float	product34;
    float	output19;
    float	output23;
    float	output33;
    vector	output110;
    vector	result142;
    vector	result143;
    vector	val10;
    int	found10;
    vector	result144;
    int	bool33;
    vector	uv38;
    int	bound_uv19;
    vector	uv39;
    vector	result145;
    vector	result146;
    float	fval131;
    float	fval231;
    float	fval331;
    vector	result147;
    vector	_uv30;
    vector4	clr15;
    vector4	result148;
    vector	vec11;
    float	fval45;
    float	lum9;
    float	fval132;
    float	fval232;
    float	fval332;
    float	result149;
    vector	vec12;
    vector	result150;
    float	clamp10;
    vector	blend9;
    float	clamp11;
    vector	product35;
    vector	product36;
    float	result151;
    float	val11;
    int	found11;
    float	result152;
    float	product37;
    float	output111;
    float	output24;
    float	output34;
    vector	output112;
    vector	result153;
    vector	result154;
    vector	val12;
    int	found12;
    vector	result155;
    int	bool34;
    vector	uv41;
    int	bound_uv20;
    vector	uv42;
    vector	result156;
    vector	result157;
    float	fval133;
    float	fval233;
    float	fval333;
    vector	result158;
    vector	_uv33;
    vector4	clr17;
    vector4	result159;
    vector	vec13;
    float	fval46;
    float	lum10;
    float	fval134;
    float	fval234;
    float	fval334;
    float	result160;
    vector	vec14;
    vector	result161;
    float	clamp12;
    vector	blend10;
    float	clamp13;
    vector	product38;
    vector	product39;
    float	result162;
    float	val13;
    int	found13;
    float	result163;
    float	product40;
    float	output113;
    float	output25;
    float	output35;
    vector	output114;
    vector	result164;
    vector	result165;
    vector	val14;
    int	found14;
    vector	result166;
    int	bool35;
    vector	uv44;
    int	bound_uv21;
    vector	uv45;
    vector	result167;
    vector	result168;
    float	fval135;
    float	fval235;
    float	fval335;
    vector	result169;
    vector	_uv36;
    vector4	clr19;
    vector4	result170;
    vector	vec15;
    float	fval47;
    float	lum11;
    float	fval136;
    float	fval236;
    float	fval336;
    float	result171;
    vector	vec16;
    vector	result172;
    float	clamp14;
    vector	blend11;
    float	clamp15;
    vector	product41;
    vector	product42;
    float	result173;
    float	val15;
    int	found15;
    float	result174;
    float	product43;
    float	output115;
    float	output26;
    float	output36;
    vector	output116;
    vector	result175;
    vector	result176;
    vector	val16;
    int	found16;
    vector	result177;
    int	bool36;
    vector	uv47;
    int	bound_uv22;
    vector	uv48;
    vector	result178;
    vector	result179;
    float	fval137;
    float	fval237;
    float	fval337;
    vector	result180;
    vector	_uv39;
    vector4	clr21;
    vector4	result181;
    vector	vec17;
    float	fval48;
    float	lum12;
    float	fval138;
    float	fval238;
    float	fval338;
    float	result182;
    vector	vec18;
    vector	result183;
    float	clamp16;
    vector	blend12;
    float	clamp17;
    vector	product44;
    vector	product45;
    float	result184;
    float	val17;
    int	found17;
    float	result185;
    float	product46;
    float	output117;
    float	output27;
    float	output37;
    vector	result186;
    vector	result187;
    vector	val18;
    int	found18;
    vector	result188;
    int	bool37;
    vector	uv50;
    int	bound_uv23;
    vector	uv51;
    vector	result189;
    vector	result190;
    float	fval139;
    float	fval239;
    float	fval339;
    vector	result191;
    vector	_uv42;
    vector4	clr23;
    vector4	result192;
    vector	vec19;
    float	fval49;
    float	lum13;
    float	fval140;
    float	fval240;
    float	fval340;
    float	result193;
    vector	vec20;
    vector	result194;
    float	clamp18;
    vector	blend13;
    float	clamp19;
    vector	product47;
    vector	product48;
    float	result195;
    float	val19;
    int	found19;
    float	result196;
    float	product49;
    vector	product50;
    vector	output118;
    vector	result197;
    vector	result198;
    vector	val20;
    int	found20;
    vector	result199;
    int	bool38;
    vector	uv53;
    int	bound_uv24;
    vector	uv54;
    vector	result200;
    vector	result201;
    float	fval141;
    float	fval241;
    float	fval341;
    vector	result202;
    vector	_uv45;
    vector4	clr25;
    vector4	result203;
    vector	vec21;
    float	fval410;
    float	lum14;
    float	fval142;
    float	fval242;
    float	fval342;
    float	result204;
    vector	vec22;
    vector	result205;
    float	clamp20;
    vector	blend14;
    float	clamp21;
    vector	product51;
    vector	product52;
    float	result206;
    float	val21;
    int	found21;
    float	result207;
    float	product53;
    float	output119;
    float	output28;
    float	output38;
    vector	output120;
    vector	result208;
    vector	result209;
    vector	val22;
    int	found22;
    vector	result210;
    int	bool39;
    vector	uv56;
    int	bound_uv25;
    vector	uv57;
    vector	result211;
    vector	result212;
    float	fval143;
    float	fval243;
    float	fval343;
    vector	result213;
    vector	_uv48;
    vector4	clr27;
    vector4	result214;
    vector	vec23;
    float	fval411;
    float	lum15;
    float	fval144;
    float	fval244;
    float	fval344;
    float	result215;
    vector	vec24;
    vector	result216;
    float	clamp22;
    vector	blend15;
    float	clamp23;
    vector	product54;
    vector	product55;
    float	result217;
    float	val23;
    int	found23;
    float	result218;
    float	product56;
    float	output121;
    float	output29;
    float	output39;
    vector	result219;
    vector	result220;
    vector	val24;
    int	found24;
    vector	result221;
    int	bool40;
    vector	uv59;
    int	bound_uv26;
    vector	uv60;
    vector	result222;
    vector	result223;
    float	fval145;
    float	fval245;
    float	fval345;
    vector	result224;
    vector	_uv51;
    vector4	clr29;
    vector4	result225;
    vector	vec25;
    float	fval412;
    float	lum16;
    float	fval146;
    float	fval246;
    float	fval346;
    float	result226;
    vector	vec26;
    vector	result227;
    float	clamp24;
    vector	blend16;
    float	clamp25;
    vector	product57;
    vector	product58;
    float	result228;
    float	val25;
    int	found25;
    float	result229;
    float	product59;
    vector	output122;
    vector	result230;
    vector	result231;
    vector	val26;
    int	found26;
    vector	result232;
    int	bool41;
    vector	uv62;
    int	bound_uv27;
    vector	uv63;
    vector	result233;
    vector	result234;
    float	fval147;
    float	fval247;
    float	fval347;
    vector	result235;
    vector	_uv54;
    vector4	clr31;
    vector4	result236;
    vector	vec27;
    float	fval413;
    float	lum17;
    float	fval148;
    float	fval248;
    float	fval348;
    float	result237;
    vector	vec28;
    vector	result238;
    float	clamp26;
    vector	blend17;
    float	clamp27;
    vector	product60;
    vector	product61;
    float	result239;
    float	val27;
    int	found27;
    float	result240;
    float	product62;
    float	output123;
    float	output210;
    float	output310;
    vector	output124;
    vector	result241;
    vector	result242;
    vector	val28;
    int	found28;
    vector	result243;
    int	bool42;
    vector	uv65;
    int	bound_uv28;
    vector	uv66;
    vector	result244;
    vector	result245;
    float	fval149;
    float	fval249;
    float	fval349;
    vector	result246;
    vector	_uv57;
    vector4	clr33;
    vector4	result247;
    vector	vec29;
    float	fval414;
    float	lum18;
    float	fval150;
    float	fval250;
    float	fval350;
    float	result248;
    vector	vec30;
    vector	result249;
    float	clamp28;
    vector	blend18;
    float	clamp29;
    vector	product63;
    vector	product64;
    float	result250;
    float	val29;
    int	found29;
    float	result251;
    float	product65;
    float	output125;
    float	output211;
    float	output311;
    vector	result252;
    vector	frontN;
    ShaderLayer	layer2;
    bsdf	f;
    bsdf	f1;
    bsdf	blend19;
    vector	result253;
    float	lum19;
    int	bool43;
    vector	white;
    vector	div;
    vector	result255;
    vector	blend20;
    bsdf	f2;
    float	scaled8;
    bsdf	product66;
    bsdf	f3;
    vector	blend21;
    bsdf	product67;
    bsdf	sum12;
    bsdf	f4;
    bsdf	blend22;
    vector	result256;
    vector	frontN1;
    bsdf	f5;
    bsdf	product68;
    vector	albedo1;
    vector	complem;
    vector	blend23;
    bsdf	product69;
    bsdf	sum13;
    vector	albedo2;
    float	lum20;
    float	eps;
    float	max;
    float	inverse;
    float	input2;
    float	min;
    bsdf	product70;
    float	scale108;
    ShaderLayer	layer3;
    ShaderLayer	layer4;
    vector	Ce2;
    ShaderLayer	out_struct;
    bsdf	out_F;
    vector	out_Of;
    vector	out_Ce;
    vector	out_P;
    vector	out_N;
    float	out_layeralpha;
    float	out_masks[];
    int	connected5;
    int	connected6;
    ShaderLayer	layer5;
    ShaderLayer	result257;
    ShaderLayer	out_struct1;
    bsdf	out_F2;
    vector	out_Of2;
    vector	out_Ce1;
    vector	out_P1;
    vector	out_N1;
    float	out_layeralpha1;
    float	out_masks1[];
    bsdf	result258;
    bsdf	F5;
    int	connected7;
    vector	result259;
    vector	Of4;
    int	connected8;
    vector	result260;
    vector	Ce6;
    vector	value;
    int	found30;
    int	index4;
    float	value1;
    int	found31;
    int	index5;
    int	output126;
    float	value2;
    int	found32;
    int	index6;
    vector	direct1;
    vector	indirect1;
    vector	all1;
    vector	indirect_emission1;
    vector	direct_comp1[];
    vector	indirect_comp1[];
    vector	all_comp1[];
    vector	direct_noshadow1;
    vector	direct_shadow1;
    vector	indirect_noshadow1;
    vector	indirect_shadow1;
    float	level1;
    float	diffuselevel1;
    float	specularlevel1;
    float	volumelevel1;
    float	direct_samples1;
    float	indirect_samples1;
    float	nlights1;
    vector	direct_noshadow_comp1[];
    vector	indirect_noshadow_comp1[];
    vector	sum14;
    vector	sum15;
    vector	Cf2;
    vector	out_Of3;
    bsdf	out_F3;
    vector	sum16;
    vector	sum17;
    float	value3;
    int	found33;
    int	index7;
    vector	clamp30;
    vector	complem1;
    vector	product71;
    float	lum21;
    vector	div1;
    float	output127;
    float	output212;
    float	output312;
    vector	blend24;
    float	output128;
    float	output213;
    float	output313;
    vector	blend25;
    float	output129;
    float	output214;
    float	output314;
    float	output130;
    float	output215;
    float	output315;
    float	output131;
    float	output216;
    float	output316;
    float	output132;
    float	output217;
    float	output317;
    float	output133;
    float	output218;
    float	output318;
    float	output134;
    float	output219;
    float	output319;
    float	output135;
    float	output220;
    float	output320;
    float	output136;
    float	output221;
    float	output321;
    float	output137;
    float	output222;
    float	output322;
    float	output138;
    float	output223;
    float	output323;
    float	output139;
    float	output224;
    float	output324;
    vector	export_uv;
    ShaderLayer	outlayer;
    vector	outexport_diffcolor;
    vector	outexport_speccolor;
    float	outexport_metallic;
    vector	outexport_basecolor;
    float	outexport_reflect;
    float	outexport_reflecttint;
    float	outexport_specrough;
    float	outexport_aniso;
    float	outexport_anisodir;
    float	outexport_sss;
    float	outexport_sssdist;
    vector	outexport_ssscolor;
    float	outexport_sheen;
    float	outexport_sheentint;
    float	outexport_coatrough;
    float	outexport_coat;
    vector	outexport_emitcolor;
    float	outexport_emitint;
    vector	outexport_uv;
    int	val30;
    int	found34;
    int	samples;
    float	Oc1;
    float	val31;
    int	found35;
    float	occlusionbias;
    float	bias;
    vector	vec31;
    float	val32;
    int	found36;
    float	cavitydistance;
    float	Cv1;
    float	val33;
    int	found37;
    float	cavitybias;
    float	bias1;
    vector	vec32;
    vector	Cf3;
    vector	blend26;
    float	val34;
    int	found38;
    float	curvaturescale;
    float	val35;
    int	found39;
    float	curvaturebias;
    int	val36;
    int	found40;
    int	curvatureOcc;
    float	val37;
    int	found41;
    float	curvatureSDist;
    float	K;
    vector	vec33;
    vector	Vd1;
    int	val38;
    int	found42;
    int	usemikkt;
    int	val39;
    int	found43;
    int	ntflipx;
    int	val40;
    int	found44;
    int	ntflipy;
    int	val41;
    int	found45;
    int	ntincludedisp;
    int	isuvrender;
    string	uvobject;
    string	uvhiresobject;
    vector	nvec20;
    int	connected9;
    vector	result261;
    vector	nvec21;
    vector4	quat9;
    string	tstyle5;
    vector	in_utan5;
    vector	in_vtan5;
    vector	nml5;
    vector	uv67;
    int	bound_uv29;
    vector	result262;
    vector	uv68;
    vector	utan6;
    vector	vtan6;
    vector	result263;
    vector	result264;
    vector	result265;
    vector	result266;
    int	val42;
    int	found46;
    int	unwrapmethod;
    int	val43;
    int	found47;
    int	flipnormal;
    int	val44;
    int	found48;
    int	faceforward;
    vector	Ni;
    vector	nn;
    vector	utan7;
    vector	vtan7;
    vector	Nf4;
    vector	result267;
    vector	tangentN1;
    vector	Ds1;
    vector	nn2;
    vector	utan9;
    vector	vtan9;
    matrix3	matx4;
    matrix3	inverse1;
    vector	product72;
    vector	albedo3;


    bool1 = (baseBumpAndNormal_type == "bump");


    bound_baseN = isbound("baseN");


    nvec = normalize(baseN);


    nvec1 = normalize(N);
#line 2701 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result = (0 != 0 ? (bound_baseN != 0 ? nvec1 : nvec)
                                  : (bound_baseN != 0 ? nvec : nvec1));




    string	_mode = "uv";
    vector	uv1 = vector();
    float	u = 0.0;
    float	v = 0.0;
    float	w = 0.0;
    {


        bool2 = (_mode == "st");


        bound_uv = isbound("uv");
        if( bound_uv ) {
            uv2 = uv;
        } else {
            uv2 = vector();
        }



        uv3 = set(s, t, 0);





        if( bound_uv == 0 )
            result1 = uv3;
        else
            result1 = uv2;


        if( bool2 == 0 )
            result2 = result1;
        else
            result2 = uv3;


        assign(fval1,fval2,fval3, result2);


        uv1 = result2;
        u = fval1;
        v = fval2;
        w = fval3;
    }


    output1 = uvtrans;


    vec = set(0,0,uvrot);


    output11 = uvscale;


    uvxform(xformuvw, uv1, 1,
    	   0, 0, output1, vec, output11, { 0, 0, 0 });


    vector	_P = vector();
    vector	_N = result;
    vector	_uv = xformuvw;
    string	_type = "bump";
    string	_texcolorspace = baseBump_colorSpace;
    string	_vectorspace = "uvtangent";
    string	_channelorder = "xyz";
    float	_offset = -0.5;
    float	_scale = baseBump_bumpScale;
    string	_texture = baseBump_bumpTexture;
    int	_udim = 1;
    string	_texwrap = baseBump_wrap;
    string	_texfilter = baseBump_filter;
    float	_texfilterwidth = baseBump_filterWidth;
    int	_texchannel = baseBump_channel;
    string	_teximageplane = baseBump_imagePlane;
    int	_normalspace = 0;
    int	_normalflipx = 0;
    int	_normalflipy = 0;
    vector	outP = vector();
    vector	outN = vector();
    vector	doffset = vector();
    float	ddist = 0.0;
    {


        bound_uv1 = isbound("uv");
        if( bound_uv1 ) {
            uv4 = uv;
        } else {
            uv4 = set(s, t, .5);
        }


        result3 = 1 != 0 ? _uv : uv4;


        assign(fval11,fval21,fval31, result3);


        if (_texture != "") {

            float myS = 1 ? fval11 : s;
            float myT = 1 ? fval21 : t;
            int fptex = 0 ? 0 : getptextureid();





            string wrapmode = _texwrap;
            if (0 & 0x01) { myS = 1 - myS; }
            if (0 & 0x02) { myT = 1 - myT; }
            if (0 & 0x04) { float x = myS; myS = myT; myT = x; }
            string map_udim = _texture;
            if (_udim) { map_udim = expand_udim(myS, myT, _texture); }
            if (map_udim == '') { clr = set({ 0, 0, 0, 0 }); }
            else {
                if (map_udim != _texture) {
                    myS %= 1.0; myT %= 1.0;
                    wrapmode = 'streak';
                }
                if (0 != 0 && 0 != 0) {
                    float tds = 0.0*0.5, tdt = 0.0*0.5;
                    if (0 & 0x04) { float x = tds; tds = tdt; tdt = x; }
                    clr = texture(map_udim,
                             myS - tds, myT - tdt,
                             myS + tds, myT - tdt,
                             myS + tds, myT + tdt,
                             myS - tds, myT + tdt,
                            "wrap", wrapmode, "filter", _texfilter,
                            "width", _texfilterwidth, "border", { 0, 0, 0, 1 },
                            "extrapolate", 1, "lerp", 0,
                            "channel", _teximageplane, "face", fptex,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace);
                } else {
                    clr = texture(map_udim, myS, myT, "wrap", wrapmode,
                            "filter", _texfilter, "width", _texfilterwidth,
                            "border", { 0, 0, 0, 1 }, "extrapolate", 1,
                            "channel", _teximageplane, "face", fptex,
                            "lerp", 0,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace);
                }
            }
        } else {
           clr = set({ 0, 0, 0, 0 });
        }


        string	_string = _texture;
        int	length = 0;
        {


            Value = 0;


            outstr = _string;
            outresultcharacter = Value;

            _mat_materialbuilder1_principledshader1_bump_mapping_strlen1_snippet1(outstr, outresultcharacter);


            length = outresultcharacter;
        }


        bool3 = (length > 0);


        product = _scale * bool3;


        vector	_P1 = _P;
        vector	_N1 = _N;
        vector	_uv1 = result3;
        vector	_value = clr;
        string	_type1 = _type;
        string	_vectorspace1 = _vectorspace;
        string	_channelorder1 = _channelorder;
        float	_offset1 = _offset;
        float	_scale1 = product;
        int	_channel = _texchannel;
        int	_normalspace1 = _normalspace;
        int	_normalflipx1 = _normalflipx;
        int	_normalflipy1 = _normalflipy;
        vector	outP1 = vector();
        vector	outN1 = vector();
        vector	doffset1 = vector();
        float	ddist1 = 0.0;
        {


            bool4 = (_type1 == "normal");


            bool5 = (_type1 == "disp");


            scaled = (bool5 + 0) * 2 + 0;


            bool6 = (_type1 == "vectordisp");


            scaled1 = (bool6 + 0) * 3 + 0;


            sum = bool4 + scaled + scaled1;


            result4 = 0 != 0 ? _P1 : P;








            result5 = 1 != 0 ? _N1 : N;


            nvec2 = normalize(result5);


            lum = luminance(_value);


            assign(fval12,fval22,fval32, _value);


            if( _channel == 0 )
                result6 = lum;
            else if( _channel == 1 )
                result6 = fval12;
            else if( _channel == 2 )
                result6 = fval22;
            else
                result6 = fval32;


            sum1 = result6 + _offset1;


            vop_displaceAlongNormal((1 != 0) ? result4 : P,
            			 (1 != 0) ? nvec2 : normalize(N),
            			 sum1, _scale1, 0, 0,
            			 1, 0, 0, dispP, dispN);





            product1 = _value * _scale1;


            outorder = _channelorder1;
            outvec = product1;

            _mat_materialbuilder1_principledshader1_bump_mapping_displace2_swizzle(outorder, outvec);


            bound_uv2 = isbound("uv");
            if( bound_uv2 ) {
                uv5 = uv;
            } else {
                uv5 = set(s, t, .5);
            }


            result7 = 1 != 0 ? _uv1 : uv5;


            vector	_result = result7;
            vector	_nvec = nvec2;
            string	__vectorspace = _vectorspace1;
            matrix3	result_2 = matrix3();
            {


                bool7 = (__vectorspace == "world");


                bool8 = (__vectorspace == "object");


                string	_tstyle = "uv";
                vector	_uv2 = _result;
                vector	_N2 = _nvec;
                vector	_utan = vector();
                vector	_vtan = vector();
                float	_angle = 0.0;
                {


                    connected = 0 ? 1 : 0;


                    result8 = 1 != 0 ? _N2 : N;


                    nvec3 = normalize(result8);


                    quat = quaternion(_angle, nvec3);


                    tstyle = _tstyle;


                    in_utan = _utan;


                    in_vtan = _vtan;


                    nml = nvec3;


                    bound_uv3 = isbound("uv");
                    if( bound_uv3 ) {
                        uv6 = uv;
                    } else {
                        uv6 = set(s, t, .5);
                    }


                    result9 = 1 != 0 ? _uv2 : uv6;


                    uv7 = result9;


                    vop_computeTangents(tstyle, nml, uv7, in_utan, in_vtan, utan, vtan);


                    result10 = qrotate(quat, utan);
#line 3059 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result11 = (0 != 0 ? (connected != 0 ? utan : result10)
                                                  : (connected != 0 ? result10 : utan));




                    result12 = qrotate(quat, vtan);
#line 3077 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result13 = (0 != 0 ? (connected != 0 ? vtan : result12)
                                                  : (connected != 0 ? result12 : vtan));




                    _utan = result11;
                    _vtan = result13;
                }


                assign(fval13,fval23,fval33, _utan);


                assign(fval14,fval24,fval34, _vtan);


                assign(fval15,fval25,fval35, _nvec);


                matx = set(fval13, fval23, fval33,
                            fval14, fval24, fval34,
                            fval15, fval25, fval35);


                xform = getspace("space:object", "space:current");


                m3 = (matrix3)xform;


                if( bool8 == 0 )
                    result14 = matx;
                else
                    result14 = m3;


                xform1 = getspace("space:world", "space:current");


                m31 = (matrix3)xform1;


                if( bool7 == 0 )
                    result15 = result14;
                else
                    result15 = m31;


                result_2 = result15;
            }


            product2 = outvec * result_2;


            sum2 = result4 + product2;





            if( sum == 0 )
                result16 = result4;
            else if( sum == 1 )
                result16 = result4;
            else if( sum == 2 )
                result16 = dispP;
            else
                result16 = sum2;


            vop_displaceAlongNormal((1 != 0) ? result4 : P,
            			 (1 != 0) ? nvec2 : normalize(N),
            			 sum1, _scale1, 0, 0,
            			 1, 0, 1, dispP1, dispN1);





            Ns = _value;
            if (_normalspace1 == 0) { Ns = vop_fromUnitNormal(Ns); }


            Nf = Ns;
            if (_normalflipx1) { Nf.x = -Nf.x; }
            if (_normalflipy1) { Nf.y = -Nf.y; }



            product3 = Nf * result_2;


            nvec4 = normalize(product3);


            dotprod = dot(nvec4, nvec2);


            trig = acos(1*dotprod - 0);


            crossprod = cross(nvec2, nvec4);


            nvec5 = normalize(crossprod);


            quat1 = quaternion(trig, nvec5);


            blend = slerp({ 0, 0, 0, 1 }, quat1, _scale1);


            result17 = qrotate(blend, nvec2);








            vector myP  = 1  ? sum2  : P;
            vector myN  = 0  ? vector()  : N;
            vector myNg = 0 ? vector() : Ng;
            newN = computenormal(myP, myN, myNg, "extrapolate", 0,
                                 "smooth", 1);





            if( sum == 0 )
                result18 = dispN1;
            else if( sum == 1 )
                result18 = result17;
            else if( sum == 2 )
                result18 = dispN;
            else
                result18 = newN;


            Value1 = { 0, 0, 0 };


            diff = dispP - result4;


            if( sum == 0 )
                result19 = Value1;
            else if( sum == 1 )
                result19 = Value1;
            else if( sum == 2 )
                result19 = diff;
            else
                result19 = product2;


            Value2 = 0;


            product4 = sum1 * _scale1;


            len = length(product2);


            if( sum == 0 )
                result20 = Value2;
            else if( sum == 1 )
                result20 = Value2;
            else if( sum == 2 )
                result20 = product4;
            else
                result20 = len;


            outP1 = result16;
            outN1 = result18;
            doffset1 = result19;
            ddist1 = result20;
        }


        outP = outP1;
        outN = outN1;
        doffset = doffset1;
        ddist = ddist1;
    }


    vector	_P2 = vector();
    vector	_N3 = result;
    vector	_uv3 = xformuvw;
    string	_type2 = "normal";
    string	_texcolorspace1 = baseNormal_colorspace;
    string	_vectorspace2 = baseNormal_vectorSpace;
    string	_channelorder2 = "xyz";
    float	_offset2 = -0.5;
    float	_scale2 = baseNormal_scale;
    string	_texture1 = baseNormal_texture;
    int	_udim1 = 1;
    string	_texwrap1 = baseNormal_wrap;
    string	_texfilter1 = baseNormal_filter;
    float	_texfilterwidth1 = baseNormal_filterWidth;
    int	_texchannel1 = baseNormal_channel;
    string	_teximageplane1 = baseNormal_imagePlane;
    int	_normalspace2 = baseNormal_space;
    int	_normalflipx2 = baseNormal_flipX;
    int	_normalflipy2 = baseNormal_flipY;
    vector	outP2 = vector();
    vector	outN2 = vector();
    vector	doffset2 = vector();
    float	ddist2 = 0.0;
    {


        bound_uv4 = isbound("uv");
        if( bound_uv4 ) {
            uv8 = uv;
        } else {
            uv8 = set(s, t, .5);
        }


        result21 = 1 != 0 ? _uv3 : uv8;


        assign(fval16,fval26,fval36, result21);


        if (_texture1 != "") {

            float myS = 1 ? fval16 : s;
            float myT = 1 ? fval26 : t;
            int fptex = 0 ? 0 : getptextureid();





            string wrapmode = _texwrap1;
            if (0 & 0x01) { myS = 1 - myS; }
            if (0 & 0x02) { myT = 1 - myT; }
            if (0 & 0x04) { float x = myS; myS = myT; myT = x; }
            string map_udim = _texture1;
            if (_udim1) { map_udim = expand_udim(myS, myT, _texture1); }
            if (map_udim == '') { clr1 = set({ 0, 0, 0, 0 }); }
            else {
                if (map_udim != _texture1) {
                    myS %= 1.0; myT %= 1.0;
                    wrapmode = 'streak';
                }
                if (0 != 0 && 0 != 0) {
                    float tds = 0.0*0.5, tdt = 0.0*0.5;
                    if (0 & 0x04) { float x = tds; tds = tdt; tdt = x; }
                    clr1 = texture(map_udim,
                             myS - tds, myT - tdt,
                             myS + tds, myT - tdt,
                             myS + tds, myT + tdt,
                             myS - tds, myT + tdt,
                            "wrap", wrapmode, "filter", _texfilter1,
                            "width", _texfilterwidth1, "border", { 0, 0, 0, 1 },
                            "extrapolate", 1, "lerp", 0,
                            "channel", _teximageplane1, "face", fptex,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace1);
                } else {
                    clr1 = texture(map_udim, myS, myT, "wrap", wrapmode,
                            "filter", _texfilter1, "width", _texfilterwidth1,
                            "border", { 0, 0, 0, 1 }, "extrapolate", 1,
                            "channel", _teximageplane1, "face", fptex,
                            "lerp", 0,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace1);
                }
            }
        } else {
           clr1 = set({ 0, 0, 0, 0 });
        }


        string	_string1 = _texture1;
        int	length1 = 0;
        {


            Value3 = 0;


            outstr1 = _string1;
            outresultcharacter1 = Value3;

            _mat_materialbuilder1_principledshader1_normal_mapping_strlen1_snippet1(outstr1, outresultcharacter1);


            length1 = outresultcharacter1;
        }


        bool9 = (length1 > 0);


        product5 = _scale2 * bool9;


        vector	_P3 = _P2;
        vector	_N4 = _N3;
        vector	_uv4 = result21;
        vector	_value1 = clr1;
        string	_type3 = _type2;
        string	_vectorspace3 = _vectorspace2;
        string	_channelorder3 = _channelorder2;
        float	_offset3 = _offset2;
        float	_scale3 = product5;
        int	_channel1 = _texchannel1;
        int	_normalspace3 = _normalspace2;
        int	_normalflipx3 = _normalflipx2;
        int	_normalflipy3 = _normalflipy2;
        vector	outP3 = vector();
        vector	outN3 = vector();
        vector	doffset3 = vector();
        float	ddist3 = 0.0;
        {


            bool10 = (_type3 == "normal");


            bool11 = (_type3 == "disp");


            scaled2 = (bool11 + 0) * 2 + 0;


            bool12 = (_type3 == "vectordisp");


            scaled3 = (bool12 + 0) * 3 + 0;


            sum3 = bool10 + scaled2 + scaled3;


            result22 = 0 != 0 ? _P3 : P;








            result23 = 1 != 0 ? _N4 : N;


            nvec6 = normalize(result23);


            lum1 = luminance(_value1);


            assign(fval17,fval27,fval37, _value1);


            if( _channel1 == 0 )
                result24 = lum1;
            else if( _channel1 == 1 )
                result24 = fval17;
            else if( _channel1 == 2 )
                result24 = fval27;
            else
                result24 = fval37;


            sum4 = result24 + _offset3;


            vop_displaceAlongNormal((1 != 0) ? result22 : P,
            			 (1 != 0) ? nvec6 : normalize(N),
            			 sum4, _scale3, 0, 0,
            			 1, 0, 0, dispP2, dispN2);





            product6 = _value1 * _scale3;


            outorder1 = _channelorder3;
            outvec1 = product6;

            _mat_materialbuilder1_principledshader1_normal_mapping_displace2_swizzle(outorder1, outvec1);


            bound_uv5 = isbound("uv");
            if( bound_uv5 ) {
                uv9 = uv;
            } else {
                uv9 = set(s, t, .5);
            }


            result25 = 1 != 0 ? _uv4 : uv9;


            vector	_result1 = result25;
            vector	_nvec1 = nvec6;
            string	__vectorspace1 = _vectorspace3;
            matrix3	result_21 = matrix3();
            {


                bool13 = (__vectorspace1 == "world");


                bool14 = (__vectorspace1 == "object");


                string	_tstyle1 = "uv";
                vector	_uv5 = _result1;
                vector	_N5 = _nvec1;
                vector	_utan1 = vector();
                vector	_vtan1 = vector();
                float	_angle1 = 0.0;
                {


                    connected1 = 0 ? 1 : 0;


                    result26 = 1 != 0 ? _N5 : N;


                    nvec7 = normalize(result26);


                    quat2 = quaternion(_angle1, nvec7);


                    tstyle1 = _tstyle1;


                    in_utan1 = _utan1;


                    in_vtan1 = _vtan1;


                    nml1 = nvec7;


                    bound_uv6 = isbound("uv");
                    if( bound_uv6 ) {
                        uv10 = uv;
                    } else {
                        uv10 = set(s, t, .5);
                    }


                    result27 = 1 != 0 ? _uv5 : uv10;


                    uv11 = result27;


                    vop_computeTangents(tstyle1, nml1, uv11, in_utan1, in_vtan1, utan1, vtan1);


                    result28 = qrotate(quat2, utan1);
#line 3561 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result29 = (0 != 0 ? (connected1 != 0 ? utan1 : result28)
                                                  : (connected1 != 0 ? result28 : utan1));




                    result30 = qrotate(quat2, vtan1);
#line 3579 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result31 = (0 != 0 ? (connected1 != 0 ? vtan1 : result30)
                                                  : (connected1 != 0 ? result30 : vtan1));




                    _utan1 = result29;
                    _vtan1 = result31;
                }


                assign(fval18,fval28,fval38, _utan1);


                assign(fval19,fval29,fval39, _vtan1);


                assign(fval110,fval210,fval310, _nvec1);


                matx1 = set(fval18, fval28, fval38,
                            fval19, fval29, fval39,
                            fval110, fval210, fval310);


                xform2 = getspace("space:object", "space:current");


                m32 = (matrix3)xform2;


                if( bool14 == 0 )
                    result32 = matx1;
                else
                    result32 = m32;


                xform3 = getspace("space:world", "space:current");


                m33 = (matrix3)xform3;


                if( bool13 == 0 )
                    result33 = result32;
                else
                    result33 = m33;


                result_21 = result33;
            }


            product7 = outvec1 * result_21;


            sum5 = result22 + product7;





            if( sum3 == 0 )
                result34 = result22;
            else if( sum3 == 1 )
                result34 = result22;
            else if( sum3 == 2 )
                result34 = dispP2;
            else
                result34 = sum5;


            vop_displaceAlongNormal((1 != 0) ? result22 : P,
            			 (1 != 0) ? nvec6 : normalize(N),
            			 sum4, _scale3, 0, 0,
            			 1, 0, 1, dispP3, dispN3);





            Ns1 = _value1;
            if (_normalspace3 == 0) { Ns1 = vop_fromUnitNormal(Ns1); }


            Nf1 = Ns1;
            if (_normalflipx3) { Nf1.x = -Nf1.x; }
            if (_normalflipy3) { Nf1.y = -Nf1.y; }



            product8 = Nf1 * result_21;


            nvec8 = normalize(product8);


            dotprod1 = dot(nvec8, nvec6);


            trig1 = acos(1*dotprod1 - 0);


            crossprod1 = cross(nvec6, nvec8);


            nvec9 = normalize(crossprod1);


            quat3 = quaternion(trig1, nvec9);


            blend1 = slerp({ 0, 0, 0, 1 }, quat3, _scale3);


            result35 = qrotate(blend1, nvec6);








            vector myP1  = 1  ? sum5  : P;
            vector myN1  = 0  ? vector()  : N;
            vector myNg1 = 0 ? vector() : Ng;
            newN1 = computenormal(myP1, myN1, myNg1, "extrapolate", 0,
                                 "smooth", 1);





            if( sum3 == 0 )
                result36 = dispN3;
            else if( sum3 == 1 )
                result36 = result35;
            else if( sum3 == 2 )
                result36 = dispN2;
            else
                result36 = newN1;


            Value4 = { 0, 0, 0 };


            diff1 = dispP2 - result22;


            if( sum3 == 0 )
                result37 = Value4;
            else if( sum3 == 1 )
                result37 = Value4;
            else if( sum3 == 2 )
                result37 = diff1;
            else
                result37 = product7;


            Value5 = 0;


            product9 = sum4 * _scale3;


            len1 = length(product7);


            if( sum3 == 0 )
                result38 = Value5;
            else if( sum3 == 1 )
                result38 = Value5;
            else if( sum3 == 2 )
                result38 = product9;
            else
                result38 = len1;


            outP3 = result34;
            outN3 = result36;
            doffset3 = result37;
            ddist3 = result38;
        }


        outP2 = outP3;
        outN2 = outN3;
        doffset2 = doffset3;
        ddist2 = ddist3;
    }
#line 3781 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result39 = (0 != 0 ? (bool1 != 0 ? outN2 : outN)
                                  : (bool1 != 0 ? outN : outN2));
#line 3796 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result40 = (0 != 0 ? (baseBumpAndNormal_enable != 0 ? result : result39)
                                  : (baseBumpAndNormal_enable != 0 ? result39 : result));




    bool15 = (coatBumpAndNormal_type == "bump");


    bound_coatN = isbound("coatN");


    nvec10 = normalize(coatN);
#line 3820 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result41 = (0 != 0 ? (bound_coatN != 0 ? nvec1 : nvec10)
                                  : (bound_coatN != 0 ? nvec10 : nvec1));




    vector	_P4 = vector();
    vector	_N6 = result41;
    vector	_uv6 = xformuvw;
    string	_type4 = "bump";
    string	_texcolorspace2 = coatBump_colorSpace;
    string	_vectorspace4 = "uvtangent";
    string	_channelorder4 = "xyz";
    float	_offset4 = -0.5;
    float	_scale4 = coatBump_bumpScale;
    string	_texture2 = coatBump_bumpTexture;
    int	_udim2 = 1;
    string	_texwrap2 = coatBump_wrap;
    string	_texfilter2 = coatBump_filter;
    float	_texfilterwidth2 = coatBump_filterWidth;
    int	_texchannel2 = coatBump_channel;
    string	_teximageplane2 = coatBump_imagePlane;
    int	_normalspace4 = 0;
    int	_normalflipx4 = 0;
    int	_normalflipy4 = 0;
    vector	outP4 = vector();
    vector	outN4 = vector();
    vector	doffset4 = vector();
    float	ddist4 = 0.0;
    {


        bound_uv7 = isbound("uv");
        if( bound_uv7 ) {
            uv12 = uv;
        } else {
            uv12 = set(s, t, .5);
        }


        result42 = 1 != 0 ? _uv6 : uv12;


        assign(fval111,fval211,fval311, result42);


        if (_texture2 != "") {

            float myS = 1 ? fval111 : s;
            float myT = 1 ? fval211 : t;
            int fptex = 0 ? 0 : getptextureid();





            string wrapmode = _texwrap2;
            if (0 & 0x01) { myS = 1 - myS; }
            if (0 & 0x02) { myT = 1 - myT; }
            if (0 & 0x04) { float x = myS; myS = myT; myT = x; }
            string map_udim = _texture2;
            if (_udim2) { map_udim = expand_udim(myS, myT, _texture2); }
            if (map_udim == '') { clr2 = set({ 0, 0, 0, 0 }); }
            else {
                if (map_udim != _texture2) {
                    myS %= 1.0; myT %= 1.0;
                    wrapmode = 'streak';
                }
                if (0 != 0 && 0 != 0) {
                    float tds = 0.0*0.5, tdt = 0.0*0.5;
                    if (0 & 0x04) { float x = tds; tds = tdt; tdt = x; }
                    clr2 = texture(map_udim,
                             myS - tds, myT - tdt,
                             myS + tds, myT - tdt,
                             myS + tds, myT + tdt,
                             myS - tds, myT + tdt,
                            "wrap", wrapmode, "filter", _texfilter2,
                            "width", _texfilterwidth2, "border", { 0, 0, 0, 1 },
                            "extrapolate", 1, "lerp", 0,
                            "channel", _teximageplane2, "face", fptex,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace2);
                } else {
                    clr2 = texture(map_udim, myS, myT, "wrap", wrapmode,
                            "filter", _texfilter2, "width", _texfilterwidth2,
                            "border", { 0, 0, 0, 1 }, "extrapolate", 1,
                            "channel", _teximageplane2, "face", fptex,
                            "lerp", 0,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace2);
                }
            }
        } else {
           clr2 = set({ 0, 0, 0, 0 });
        }


        string	_string2 = _texture2;
        int	length2 = 0;
        {


            Value6 = 0;


            outstr2 = _string2;
            outresultcharacter2 = Value6;

            _mat_materialbuilder1_principledshader1_bump_mapping1_strlen1_snippet1(outstr2, outresultcharacter2);


            length2 = outresultcharacter2;
        }


        bool16 = (length2 > 0);


        product10 = _scale4 * bool16;


        vector	_P5 = _P4;
        vector	_N7 = _N6;
        vector	_uv7 = result42;
        vector	_value2 = clr2;
        string	_type5 = _type4;
        string	_vectorspace5 = _vectorspace4;
        string	_channelorder5 = _channelorder4;
        float	_offset5 = _offset4;
        float	_scale5 = product10;
        int	_channel2 = _texchannel2;
        int	_normalspace5 = _normalspace4;
        int	_normalflipx5 = _normalflipx4;
        int	_normalflipy5 = _normalflipy4;
        vector	outP5 = vector();
        vector	outN5 = vector();
        vector	doffset5 = vector();
        float	ddist5 = 0.0;
        {


            bool17 = (_type5 == "normal");


            bool18 = (_type5 == "disp");


            scaled4 = (bool18 + 0) * 2 + 0;


            bool19 = (_type5 == "vectordisp");


            scaled5 = (bool19 + 0) * 3 + 0;


            sum6 = bool17 + scaled4 + scaled5;


            result43 = 0 != 0 ? _P5 : P;








            result44 = 1 != 0 ? _N7 : N;


            nvec11 = normalize(result44);


            lum2 = luminance(_value2);


            assign(fval112,fval212,fval312, _value2);


            if( _channel2 == 0 )
                result45 = lum2;
            else if( _channel2 == 1 )
                result45 = fval112;
            else if( _channel2 == 2 )
                result45 = fval212;
            else
                result45 = fval312;


            sum7 = result45 + _offset5;


            vop_displaceAlongNormal((1 != 0) ? result43 : P,
            			 (1 != 0) ? nvec11 : normalize(N),
            			 sum7, _scale5, 0, 0,
            			 1, 0, 0, dispP4, dispN4);





            product11 = _value2 * _scale5;


            outorder2 = _channelorder5;
            outvec2 = product11;

            _mat_materialbuilder1_principledshader1_bump_mapping1_displace2_swizzle(outorder2, outvec2);


            bound_uv8 = isbound("uv");
            if( bound_uv8 ) {
                uv13 = uv;
            } else {
                uv13 = set(s, t, .5);
            }


            result46 = 1 != 0 ? _uv7 : uv13;


            vector	_result2 = result46;
            vector	_nvec2 = nvec11;
            string	__vectorspace2 = _vectorspace5;
            matrix3	result_22 = matrix3();
            {


                bool20 = (__vectorspace2 == "world");


                bool21 = (__vectorspace2 == "object");


                string	_tstyle2 = "uv";
                vector	_uv8 = _result2;
                vector	_N8 = _nvec2;
                vector	_utan2 = vector();
                vector	_vtan2 = vector();
                float	_angle2 = 0.0;
                {


                    connected2 = 0 ? 1 : 0;


                    result47 = 1 != 0 ? _N8 : N;


                    nvec12 = normalize(result47);


                    quat4 = quaternion(_angle2, nvec12);


                    tstyle2 = _tstyle2;


                    in_utan2 = _utan2;


                    in_vtan2 = _vtan2;


                    nml2 = nvec12;


                    bound_uv9 = isbound("uv");
                    if( bound_uv9 ) {
                        uv14 = uv;
                    } else {
                        uv14 = set(s, t, .5);
                    }


                    result48 = 1 != 0 ? _uv8 : uv14;


                    uv15 = result48;


                    vop_computeTangents(tstyle2, nml2, uv15, in_utan2, in_vtan2, utan2, vtan2);


                    result49 = qrotate(quat4, utan2);
#line 4117 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result50 = (0 != 0 ? (connected2 != 0 ? utan2 : result49)
                                                  : (connected2 != 0 ? result49 : utan2));




                    result51 = qrotate(quat4, vtan2);
#line 4135 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result52 = (0 != 0 ? (connected2 != 0 ? vtan2 : result51)
                                                  : (connected2 != 0 ? result51 : vtan2));




                    _utan2 = result50;
                    _vtan2 = result52;
                }


                assign(fval113,fval213,fval313, _utan2);


                assign(fval114,fval214,fval314, _vtan2);


                assign(fval115,fval215,fval315, _nvec2);


                matx2 = set(fval113, fval213, fval313,
                            fval114, fval214, fval314,
                            fval115, fval215, fval315);


                xform4 = getspace("space:object", "space:current");


                m34 = (matrix3)xform4;


                if( bool21 == 0 )
                    result53 = matx2;
                else
                    result53 = m34;


                xform5 = getspace("space:world", "space:current");


                m35 = (matrix3)xform5;


                if( bool20 == 0 )
                    result54 = result53;
                else
                    result54 = m35;


                result_22 = result54;
            }


            product12 = outvec2 * result_22;


            sum8 = result43 + product12;





            if( sum6 == 0 )
                result55 = result43;
            else if( sum6 == 1 )
                result55 = result43;
            else if( sum6 == 2 )
                result55 = dispP4;
            else
                result55 = sum8;


            vop_displaceAlongNormal((1 != 0) ? result43 : P,
            			 (1 != 0) ? nvec11 : normalize(N),
            			 sum7, _scale5, 0, 0,
            			 1, 0, 1, dispP5, dispN5);





            Ns2 = _value2;
            if (_normalspace5 == 0) { Ns2 = vop_fromUnitNormal(Ns2); }


            Nf2 = Ns2;
            if (_normalflipx5) { Nf2.x = -Nf2.x; }
            if (_normalflipy5) { Nf2.y = -Nf2.y; }



            product13 = Nf2 * result_22;


            nvec13 = normalize(product13);


            dotprod2 = dot(nvec13, nvec11);


            trig2 = acos(1*dotprod2 - 0);


            crossprod2 = cross(nvec11, nvec13);


            nvec14 = normalize(crossprod2);


            quat5 = quaternion(trig2, nvec14);


            blend2 = slerp({ 0, 0, 0, 1 }, quat5, _scale5);


            result56 = qrotate(blend2, nvec11);








            vector myP2  = 1  ? sum8  : P;
            vector myN2  = 0  ? vector()  : N;
            vector myNg2 = 0 ? vector() : Ng;
            newN2 = computenormal(myP2, myN2, myNg2, "extrapolate", 0,
                                 "smooth", 1);





            if( sum6 == 0 )
                result57 = dispN5;
            else if( sum6 == 1 )
                result57 = result56;
            else if( sum6 == 2 )
                result57 = dispN4;
            else
                result57 = newN2;


            Value7 = { 0, 0, 0 };


            diff2 = dispP4 - result43;


            if( sum6 == 0 )
                result58 = Value7;
            else if( sum6 == 1 )
                result58 = Value7;
            else if( sum6 == 2 )
                result58 = diff2;
            else
                result58 = product12;


            Value8 = 0;


            product14 = sum7 * _scale5;


            len2 = length(product12);


            if( sum6 == 0 )
                result59 = Value8;
            else if( sum6 == 1 )
                result59 = Value8;
            else if( sum6 == 2 )
                result59 = product14;
            else
                result59 = len2;


            outP5 = result55;
            outN5 = result57;
            doffset5 = result58;
            ddist5 = result59;
        }


        outP4 = outP5;
        outN4 = outN5;
        doffset4 = doffset5;
        ddist4 = ddist5;
    }


    vector	_P6 = vector();
    vector	_N9 = result41;
    vector	_uv9 = xformuvw;
    string	_type6 = "normal";
    string	_texcolorspace3 = coatNormal_colorspace;
    string	_vectorspace6 = coatNormal_vectorSpace;
    string	_channelorder6 = "xyz";
    float	_offset6 = -0.5;
    float	_scale6 = coatNormal_scale;
    string	_texture3 = coatNormal_texture;
    int	_udim3 = 1;
    string	_texwrap3 = coatNormal_wrap;
    string	_texfilter3 = coatNormal_filter;
    float	_texfilterwidth3 = coatNormal_filterWidth;
    int	_texchannel3 = coatNormal_channel;
    string	_teximageplane3 = coatNormal_imagePlane;
    int	_normalspace6 = coatNormal_space;
    int	_normalflipx6 = coatNormal_flipX;
    int	_normalflipy6 = coatNormal_flipY;
    vector	outP6 = vector();
    vector	outN6 = vector();
    vector	doffset6 = vector();
    float	ddist6 = 0.0;
    {


        bound_uv10 = isbound("uv");
        if( bound_uv10 ) {
            uv16 = uv;
        } else {
            uv16 = set(s, t, .5);
        }


        result60 = 1 != 0 ? _uv9 : uv16;


        assign(fval116,fval216,fval316, result60);


        if (_texture3 != "") {

            float myS = 1 ? fval116 : s;
            float myT = 1 ? fval216 : t;
            int fptex = 0 ? 0 : getptextureid();





            string wrapmode = _texwrap3;
            if (0 & 0x01) { myS = 1 - myS; }
            if (0 & 0x02) { myT = 1 - myT; }
            if (0 & 0x04) { float x = myS; myS = myT; myT = x; }
            string map_udim = _texture3;
            if (_udim3) { map_udim = expand_udim(myS, myT, _texture3); }
            if (map_udim == '') { clr3 = set({ 0, 0, 0, 0 }); }
            else {
                if (map_udim != _texture3) {
                    myS %= 1.0; myT %= 1.0;
                    wrapmode = 'streak';
                }
                if (0 != 0 && 0 != 0) {
                    float tds = 0.0*0.5, tdt = 0.0*0.5;
                    if (0 & 0x04) { float x = tds; tds = tdt; tdt = x; }
                    clr3 = texture(map_udim,
                             myS - tds, myT - tdt,
                             myS + tds, myT - tdt,
                             myS + tds, myT + tdt,
                             myS - tds, myT + tdt,
                            "wrap", wrapmode, "filter", _texfilter3,
                            "width", _texfilterwidth3, "border", { 0, 0, 0, 1 },
                            "extrapolate", 1, "lerp", 0,
                            "channel", _teximageplane3, "face", fptex,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace3);
                } else {
                    clr3 = texture(map_udim, myS, myT, "wrap", wrapmode,
                            "filter", _texfilter3, "width", _texfilterwidth3,
                            "border", { 0, 0, 0, 1 }, "extrapolate", 1,
                            "channel", _teximageplane3, "face", fptex,
                            "lerp", 0,
                            "blur", 0, "pixelblur", 0,
                            "srccolorspace", _texcolorspace3);
                }
            }
        } else {
           clr3 = set({ 0, 0, 0, 0 });
        }


        string	_string3 = _texture3;
        int	length3 = 0;
        {


            Value9 = 0;


            outstr3 = _string3;
            outresultcharacter3 = Value9;

            _mat_materialbuilder1_principledshader1_normal_mapping1_strlen1_snippet1(outstr3, outresultcharacter3);


            length3 = outresultcharacter3;
        }


        bool22 = (length3 > 0);


        product15 = _scale6 * bool22;


        vector	_P7 = _P6;
        vector	_N10 = _N9;
        vector	_uv10 = result60;
        vector	_value3 = clr3;
        string	_type7 = _type6;
        string	_vectorspace7 = _vectorspace6;
        string	_channelorder7 = _channelorder6;
        float	_offset7 = _offset6;
        float	_scale7 = product15;
        int	_channel3 = _texchannel3;
        int	_normalspace7 = _normalspace6;
        int	_normalflipx7 = _normalflipx6;
        int	_normalflipy7 = _normalflipy6;
        vector	outP7 = vector();
        vector	outN7 = vector();
        vector	doffset7 = vector();
        float	ddist7 = 0.0;
        {


            bool23 = (_type7 == "normal");


            bool24 = (_type7 == "disp");


            scaled6 = (bool24 + 0) * 2 + 0;


            bool25 = (_type7 == "vectordisp");


            scaled7 = (bool25 + 0) * 3 + 0;


            sum9 = bool23 + scaled6 + scaled7;


            result61 = 0 != 0 ? _P7 : P;








            result62 = 1 != 0 ? _N10 : N;


            nvec15 = normalize(result62);


            lum3 = luminance(_value3);


            assign(fval117,fval217,fval317, _value3);


            if( _channel3 == 0 )
                result63 = lum3;
            else if( _channel3 == 1 )
                result63 = fval117;
            else if( _channel3 == 2 )
                result63 = fval217;
            else
                result63 = fval317;


            sum10 = result63 + _offset7;


            vop_displaceAlongNormal((1 != 0) ? result61 : P,
            			 (1 != 0) ? nvec15 : normalize(N),
            			 sum10, _scale7, 0, 0,
            			 1, 0, 0, dispP6, dispN6);





            product16 = _value3 * _scale7;


            outorder3 = _channelorder7;
            outvec3 = product16;

            _mat_materialbuilder1_principledshader1_normal_mapping1_displace2_swizzle(outorder3, outvec3);


            bound_uv11 = isbound("uv");
            if( bound_uv11 ) {
                uv17 = uv;
            } else {
                uv17 = set(s, t, .5);
            }


            result64 = 1 != 0 ? _uv10 : uv17;


            vector	_result3 = result64;
            vector	_nvec3 = nvec15;
            string	__vectorspace3 = _vectorspace7;
            matrix3	result_23 = matrix3();
            {


                bool26 = (__vectorspace3 == "world");


                bool27 = (__vectorspace3 == "object");


                string	_tstyle3 = "uv";
                vector	_uv11 = _result3;
                vector	_N11 = _nvec3;
                vector	_utan3 = vector();
                vector	_vtan3 = vector();
                float	_angle3 = 0.0;
                {


                    connected3 = 0 ? 1 : 0;


                    result65 = 1 != 0 ? _N11 : N;


                    nvec16 = normalize(result65);


                    quat6 = quaternion(_angle3, nvec16);


                    tstyle3 = _tstyle3;


                    in_utan3 = _utan3;


                    in_vtan3 = _vtan3;


                    nml3 = nvec16;


                    bound_uv12 = isbound("uv");
                    if( bound_uv12 ) {
                        uv18 = uv;
                    } else {
                        uv18 = set(s, t, .5);
                    }


                    result66 = 1 != 0 ? _uv11 : uv18;


                    uv19 = result66;


                    vop_computeTangents(tstyle3, nml3, uv19, in_utan3, in_vtan3, utan3, vtan3);


                    result67 = qrotate(quat6, utan3);
#line 4619 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result68 = (0 != 0 ? (connected3 != 0 ? utan3 : result67)
                                                  : (connected3 != 0 ? result67 : utan3));




                    result69 = qrotate(quat6, vtan3);
#line 4637 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                        result70 = (0 != 0 ? (connected3 != 0 ? vtan3 : result69)
                                                  : (connected3 != 0 ? result69 : vtan3));




                    _utan3 = result68;
                    _vtan3 = result70;
                }


                assign(fval118,fval218,fval318, _utan3);


                assign(fval119,fval219,fval319, _vtan3);


                assign(fval120,fval220,fval320, _nvec3);


                matx3 = set(fval118, fval218, fval318,
                            fval119, fval219, fval319,
                            fval120, fval220, fval320);


                xform6 = getspace("space:object", "space:current");


                m36 = (matrix3)xform6;


                if( bool27 == 0 )
                    result71 = matx3;
                else
                    result71 = m36;


                xform7 = getspace("space:world", "space:current");


                m37 = (matrix3)xform7;


                if( bool26 == 0 )
                    result72 = result71;
                else
                    result72 = m37;


                result_23 = result72;
            }


            product17 = outvec3 * result_23;


            sum11 = result61 + product17;





            if( sum9 == 0 )
                result73 = result61;
            else if( sum9 == 1 )
                result73 = result61;
            else if( sum9 == 2 )
                result73 = dispP6;
            else
                result73 = sum11;


            vop_displaceAlongNormal((1 != 0) ? result61 : P,
            			 (1 != 0) ? nvec15 : normalize(N),
            			 sum10, _scale7, 0, 0,
            			 1, 0, 1, dispP7, dispN7);





            Ns3 = _value3;
            if (_normalspace7 == 0) { Ns3 = vop_fromUnitNormal(Ns3); }


            Nf3 = Ns3;
            if (_normalflipx7) { Nf3.x = -Nf3.x; }
            if (_normalflipy7) { Nf3.y = -Nf3.y; }



            product18 = Nf3 * result_23;


            nvec17 = normalize(product18);


            dotprod3 = dot(nvec17, nvec15);


            trig3 = acos(1*dotprod3 - 0);


            crossprod3 = cross(nvec15, nvec17);


            nvec18 = normalize(crossprod3);


            quat7 = quaternion(trig3, nvec18);


            blend3 = slerp({ 0, 0, 0, 1 }, quat7, _scale7);


            result74 = qrotate(blend3, nvec15);








            vector myP3  = 1  ? sum11  : P;
            vector myN3  = 0  ? vector()  : N;
            vector myNg3 = 0 ? vector() : Ng;
            newN3 = computenormal(myP3, myN3, myNg3, "extrapolate", 0,
                                 "smooth", 1);





            if( sum9 == 0 )
                result75 = dispN7;
            else if( sum9 == 1 )
                result75 = result74;
            else if( sum9 == 2 )
                result75 = dispN6;
            else
                result75 = newN3;


            Value10 = { 0, 0, 0 };


            diff3 = dispP6 - result61;


            if( sum9 == 0 )
                result76 = Value10;
            else if( sum9 == 1 )
                result76 = Value10;
            else if( sum9 == 2 )
                result76 = diff3;
            else
                result76 = product17;


            Value11 = 0;


            product19 = sum10 * _scale7;


            len3 = length(product17);


            if( sum9 == 0 )
                result77 = Value11;
            else if( sum9 == 1 )
                result77 = Value11;
            else if( sum9 == 2 )
                result77 = product19;
            else
                result77 = len3;


            outP7 = result73;
            outN7 = result75;
            doffset7 = result76;
            ddist7 = result77;
        }


        outP6 = outP7;
        outN6 = outN7;
        doffset6 = doffset7;
        ddist6 = ddist7;
    }
#line 4839 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result78 = (0 != 0 ? (bool15 != 0 ? outN6 : outN4)
                                  : (bool15 != 0 ? outN4 : outN6));
#line 4854 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result79 = (0 != 0 ? (coatBumpAndNormal_enable != 0 ? result41 : result78)
                                  : (coatBumpAndNormal_enable != 0 ? result78 : result41));
#line 4869 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
        result80 = (0 != 0 ? (separateCoatNormals != 0 ? result40 : result79)
                                  : (separateCoatNormals != 0 ? result79 : result40));




    string	_tstyle4 = "uv";
    vector	_uv12 = xformuvw;
    vector	_N12 = vector();
    vector	_utan4 = vector();
    vector	_vtan4 = vector();
    float	_angle4 = 0.0;
    {


        connected4 = 0 ? 1 : 0;


        result81 = 0 != 0 ? _N12 : N;


        nvec19 = normalize(result81);


        quat8 = quaternion(_angle4, nvec19);


        tstyle4 = _tstyle4;


        in_utan4 = _utan4;


        in_vtan4 = _vtan4;


        nml4 = nvec19;


        bound_uv13 = isbound("uv");
        if( bound_uv13 ) {
            uv20 = uv;
        } else {
            uv20 = set(s, t, .5);
        }


        result82 = 1 != 0 ? _uv12 : uv20;


        uv21 = result82;


        vop_computeTangents(tstyle4, nml4, uv21, in_utan4, in_vtan4, utan4, vtan4);


        result83 = qrotate(quat8, utan4);
#line 4937 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result84 = (0 != 0 ? (connected4 != 0 ? utan4 : result83)
                                      : (connected4 != 0 ? result83 : utan4));




        result85 = qrotate(quat8, vtan4);
#line 4955 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result86 = (0 != 0 ? (connected4 != 0 ? vtan4 : result85)
                                      : (connected4 != 0 ? result85 : vtan4));




        _utan4 = result84;
        _vtan4 = result86;
    }


    vector	_uv13 = xformuvw;
    int	_useBaseColor = 1;
    vector	_baseColor = basecolor;
    int	_usePointColor = basecolor_usePointColor;
    int	_usePointAlpha = 0;
    int	_usePackedColor = basecolor_usePackedColor;
    int	_usePackedAlpha = 0;
    int	_useTexture = basecolor_useTexture;
    string	_texture4 = basecolor_texture;
    int	_udim4 = 1;
    float	_textureIntensity = basecolor_textureIntensity;
    string	_textureWrap = basecolor_textureWrap;
    string	_textureSourceColorSpace = basecolor_textureColorSpace;
    string	_textureFilter = surface_textureFilter;
    float	_textureFilterWidth = surface_textureFilterWidth;
    vector4	_textureBorderColor = { 0, 0, 0, 0 };
    int	_monoOutput = 0;
    int	_monoChannel = 0;
    vector	color = vector();
    float	alpha = 0.0;
    {
#line 4998 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result87 = (0 != 0 ? (_useBaseColor != 0 ? { 1, 1, 1 } : _baseColor)
                                      : (_useBaseColor != 0 ? _baseColor : { 1, 1, 1 }));
#line 5013 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result88 = (0 != 0 ? (_usePointColor != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor != 0 ? Cd : { 1, 1, 1 }));




        found = renderstate("packed:Cd", val);
        if (!found) val = { 1, 1, 1 };
#line 5032 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result89 = (0 != 0 ? (_usePackedColor != 0 ? { 1, 1, 1 } : val)
                                      : (_usePackedColor != 0 ? val : { 1, 1, 1 }));




        vector	_uv14 = _uv13;
        vector	_duv = vector();
        string	_map = _texture4;
        int	_udim5 = _udim4;
        string	_srccolorspace = _textureSourceColorSpace;
        string	_wrap = _textureWrap;
        string	_filter = _textureFilter;
        float	_width = _textureFilterWidth;
        float	_blur = 0;
        float	_pixelblur = 0;
        vector4	_border = _textureBorderColor;
        int	_extrapol = 1;
        int	_interp = 1;
        vector4	_defclr = { 1, 1, 1, 1 };
        string	_channel4 = "";
        int	_ptexface = 0;
        int	_orient = 0;
        vector4	clr4 = vector4();
        {


            string	_mode1 = "uv";
            vector	uv22 = vector();
            float	u1 = 0.0;
            float	v1 = 0.0;
            float	w1 = 0.0;
            {


                bool28 = (_mode1 == "st");


                bound_uv14 = isbound("uv");
                if( bound_uv14 ) {
                    uv23 = uv;
                } else {
                    uv23 = vector();
                }



                uv24 = set(s, t, 0);





                if( bound_uv14 == 0 )
                    result90 = uv24;
                else
                    result90 = uv23;


                if( bool28 == 0 )
                    result91 = result90;
                else
                    result91 = uv24;


                assign(fval121,fval221,fval321, result91);


                uv22 = result91;
                u1 = fval121;
                v1 = fval221;
                w1 = fval321;
            }


            result92 = 1 != 0 ? _uv14 : uv22;


            _uv15 = result92;


            if (_map != "") {



                int fptex = 0 ? _ptexface : getptextureid();



                string wrapmode = _wrap;
                if (_orient & 0x02) { _uv15.y = 1 - _uv15.y; }
                if (_orient & 0x04) { float x = _uv15.x; _uv15.x = _uv15.y; _uv15.y = x; }
                string _map_udim = _map;
                if (_udim5) { _map_udim = expand_udim(_uv15.x, _uv15.y, _map); }
                if (_map_udim == '') { clr5 = set(_defclr); }
                else {
                    if (_map_udim != _map) {
                        _uv15.x %= 1.0; _uv15.y %= 1.0;
                        wrapmode = 'streak';
                    }
                    if (_orient & 0x01) { _uv15.x = 1 - _uv15.x; }
                    if (0 != 0) {
                        vector tduv = 0.5 * _duv;
                        if (_orient & 0x04) { float x = tduv.x; tduv.x = tduv.y; tduv.y = x; }
                        clr5 = texture(_map_udim,
                                 _uv15.x - tduv.x, _uv15.y - tduv.y,
                                 _uv15.x + tduv.x, _uv15.y - tduv.y,
                                 _uv15.x + tduv.x, _uv15.y + tduv.y,
                                 _uv15.x - tduv.x, _uv15.y + tduv.y,
                                "wrap", wrapmode, "filter", _filter,
                                "width", _width, "border", _border,
                                "extrapolate", _extrapol, "lerp", _interp,
                                "channel", _channel4, "face", fptex,
                                "blur", _blur, "pixelblur", _pixelblur,
                                "srccolorspace", _srccolorspace);
                    } else {
                        clr5 = texture(_map_udim, _uv15.x, _uv15.y, "wrap", wrapmode,
                                "filter", _filter, "width", _width,
                                "border", _border, "extrapolate", _extrapol,
                                "channel", _channel4, "face", fptex,
                                "lerp", _interp,
                                "blur", _blur, "pixelblur", _pixelblur,
                                "srccolorspace", _srccolorspace);
                    }
                }
            } else {
               clr5 = set(_defclr);
            }


            clr4 = clr5;
        }
#line 5175 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result93 = (0 != 0 ? (_useTexture != 0 ? { 1, 1, 1, 1 } : clr4)
                                      : (_useTexture != 0 ? clr4 : { 1, 1, 1, 1 }));




        vec1 = (vector)result93;
        fval4 = getcomp(result93, 3);


        lum4 = luminance(vec1);


        assign(fval122,fval222,fval322, vec1);


        if( _monoChannel == 0 )
            result94 = lum4;
        else if( _monoChannel == 1 )
            result94 = fval122;
        else if( _monoChannel == 2 )
            result94 = fval222;
        else
            result94 = fval322;


        vec2 = set(result94,result94,result94);


        if( _monoOutput == 0 )
            result95 = vec1;
        else
            result95 = vec2;


        clamp = clamp(_textureIntensity, 0, 1);



          blend4 = lerp({ 1, 1, 1 }, result95, clamp);





        clamp1 = clamp(_textureIntensity, 1, 1000);


        product20 = blend4 * clamp1;


        product21 = result87 * result88 * result89 * product20;
#line 5238 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result96 = (0 != 0 ? (_usePointAlpha != 0 ? 1 : Alpha)
                                      : (_usePointAlpha != 0 ? Alpha : 1));




        found1 = renderstate("packed:Alpha", val1);
        if (!found1) val1 = 1;
#line 5257 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result97 = (0 != 0 ? (_usePackedAlpha != 0 ? 1 : val1)
                                      : (_usePackedAlpha != 0 ? val1 : 1));




        product22 = fval4 * result96 * result97;


        color = product21;
        alpha = product22;
    }


    output12 = set(rough,rough,rough);


    vector	_uv16 = xformuvw;
    int	_useBaseColor1 = 1;
    vector	_baseColor1 = output12;
    int	_usePointColor1 = 0;
    int	_usePointAlpha1 = 0;
    int	_usePackedColor1 = 0;
    int	_usePackedAlpha1 = 0;
    int	_useTexture1 = rough_useTexture;
    string	_texture5 = rough_texture;
    int	_udim6 = 1;
    float	_textureIntensity1 = 1;
    string	_textureWrap1 = rough_textureWrap;
    string	_textureSourceColorSpace1 = rough_textureColorSpace;
    string	_textureFilter1 = surface_textureFilter;
    float	_textureFilterWidth1 = surface_textureFilterWidth;
    vector4	_textureBorderColor1 = { 0, 0, 0, 0 };
    int	_monoOutput1 = 1;
    int	_monoChannel1 = rough_monoChannel;
    vector	color1 = vector();
    float	alpha1 = 0.0;
    {
#line 5306 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result98 = (0 != 0 ? (_useBaseColor1 != 0 ? { 1, 1, 1 } : _baseColor1)
                                      : (_useBaseColor1 != 0 ? _baseColor1 : { 1, 1, 1 }));
#line 5321 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result99 = (0 != 0 ? (_usePointColor1 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor1 != 0 ? Cd : { 1, 1, 1 }));




        found2 = renderstate("packed:Cd", val2);
        if (!found2) val2 = { 1, 1, 1 };
#line 5340 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result100 = (0 != 0 ? (_usePackedColor1 != 0 ? { 1, 1, 1 } : val2)
                                      : (_usePackedColor1 != 0 ? val2 : { 1, 1, 1 }));




        vector	_uv17 = _uv16;
        vector	_duv1 = vector();
        string	_map1 = _texture5;
        int	_udim7 = _udim6;
        string	_srccolorspace1 = _textureSourceColorSpace1;
        string	_wrap1 = _textureWrap1;
        string	_filter1 = _textureFilter1;
        float	_width1 = _textureFilterWidth1;
        float	_blur1 = 0;
        float	_pixelblur1 = 0;
        vector4	_border1 = _textureBorderColor1;
        int	_extrapol1 = 1;
        int	_interp1 = 1;
        vector4	_defclr1 = { 1, 1, 1, 1 };
        string	_channel5 = "";
        int	_ptexface1 = 0;
        int	_orient1 = 0;
        vector4	clr6 = vector4();
        {


            string	_mode2 = "uv";
            vector	uv25 = vector();
            float	u2 = 0.0;
            float	v2 = 0.0;
            float	w2 = 0.0;
            {


                bool29 = (_mode2 == "st");


                bound_uv15 = isbound("uv");
                if( bound_uv15 ) {
                    uv26 = uv;
                } else {
                    uv26 = vector();
                }



                uv27 = set(s, t, 0);





                if( bound_uv15 == 0 )
                    result101 = uv27;
                else
                    result101 = uv26;


                if( bool29 == 0 )
                    result102 = result101;
                else
                    result102 = uv27;


                assign(fval123,fval223,fval323, result102);


                uv25 = result102;
                u2 = fval123;
                v2 = fval223;
                w2 = fval323;
            }


            result103 = 1 != 0 ? _uv17 : uv25;


            _uv18 = result103;


            if (_map1 != "") {



                int fptex = 0 ? _ptexface1 : getptextureid();



                string wrapmode1 = _wrap1;
                if (_orient1 & 0x02) { _uv18.y = 1 - _uv18.y; }
                if (_orient1 & 0x04) { float x = _uv18.x; _uv18.x = _uv18.y; _uv18.y = x; }
                string _map_udim1 = _map1;
                if (_udim7) { _map_udim1 = expand_udim(_uv18.x, _uv18.y, _map1); }
                if (_map_udim1 == '') { clr7 = set(_defclr1); }
                else {
                    if (_map_udim1 != _map1) {
                        _uv18.x %= 1.0; _uv18.y %= 1.0;
                        wrapmode1 = 'streak';
                    }
                    if (_orient1 & 0x01) { _uv18.x = 1 - _uv18.x; }
                    if (0 != 0) {
                        vector tduv1 = 0.5 * _duv1;
                        if (_orient1 & 0x04) { float x = tduv1.x; tduv1.x = tduv1.y; tduv1.y = x; }
                        clr7 = texture(_map_udim1,
                                 _uv18.x - tduv1.x, _uv18.y - tduv1.y,
                                 _uv18.x + tduv1.x, _uv18.y - tduv1.y,
                                 _uv18.x + tduv1.x, _uv18.y + tduv1.y,
                                 _uv18.x - tduv1.x, _uv18.y + tduv1.y,
                                "wrap", wrapmode1, "filter", _filter1,
                                "width", _width1, "border", _border1,
                                "extrapolate", _extrapol1, "lerp", _interp1,
                                "channel", _channel5, "face", fptex,
                                "blur", _blur1, "pixelblur", _pixelblur1,
                                "srccolorspace", _srccolorspace1);
                    } else {
                        clr7 = texture(_map_udim1, _uv18.x, _uv18.y, "wrap", wrapmode1,
                                "filter", _filter1, "width", _width1,
                                "border", _border1, "extrapolate", _extrapol1,
                                "channel", _channel5, "face", fptex,
                                "lerp", _interp1,
                                "blur", _blur1, "pixelblur", _pixelblur1,
                                "srccolorspace", _srccolorspace1);
                    }
                }
            } else {
               clr7 = set(_defclr1);
            }


            clr6 = clr7;
        }
#line 5483 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result104 = (0 != 0 ? (_useTexture1 != 0 ? { 1, 1, 1, 1 } : clr6)
                                      : (_useTexture1 != 0 ? clr6 : { 1, 1, 1, 1 }));




        vec3 = (vector)result104;
        fval41 = getcomp(result104, 3);


        lum5 = luminance(vec3);


        assign(fval124,fval224,fval324, vec3);


        if( _monoChannel1 == 0 )
            result105 = lum5;
        else if( _monoChannel1 == 1 )
            result105 = fval124;
        else if( _monoChannel1 == 2 )
            result105 = fval224;
        else
            result105 = fval324;


        vec4 = set(result105,result105,result105);


        if( _monoOutput1 == 0 )
            result106 = vec3;
        else
            result106 = vec4;


        clamp2 = clamp(_textureIntensity1, 0, 1);



          blend5 = lerp({ 1, 1, 1 }, result106, clamp2);





        clamp3 = clamp(_textureIntensity1, 1, 1000);


        product23 = blend5 * clamp3;


        product24 = result98 * result99 * result100 * product23;
#line 5546 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result107 = (0 != 0 ? (_usePointAlpha1 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha1 != 0 ? Alpha : 1));




        found3 = renderstate("packed:Alpha", val3);
        if (!found3) val3 = 1;
#line 5565 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result108 = (0 != 0 ? (_usePackedAlpha1 != 0 ? 1 : val3)
                                      : (_usePackedAlpha1 != 0 ? val3 : 1));




        product25 = fval41 * result107 * result108;


        color1 = product24;
        alpha1 = product25;
    }


    assign(output13,output2,output3, color1);


    output14 = set(reflect,reflect,reflect);


    vector	_uv19 = xformuvw;
    int	_useBaseColor2 = 1;
    vector	_baseColor2 = output14;
    int	_usePointColor2 = 0;
    int	_usePointAlpha2 = 0;
    int	_usePackedColor2 = 0;
    int	_usePackedAlpha2 = 0;
    int	_useTexture2 = reflect_useTexture;
    string	_texture6 = reflect_texture;
    int	_udim8 = 1;
    float	_textureIntensity2 = 1;
    string	_textureWrap2 = reflect_textureWrap;
    string	_textureSourceColorSpace2 = reflect_textureColorSpace;
    string	_textureFilter2 = surface_textureFilter;
    float	_textureFilterWidth2 = surface_textureFilterWidth;
    vector4	_textureBorderColor2 = { 0, 0, 0, 0 };
    int	_monoOutput2 = 1;
    int	_monoChannel2 = reflect_monoChannel;
    vector	color2 = vector();
    float	alpha2 = 0.0;
    {
#line 5617 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result109 = (0 != 0 ? (_useBaseColor2 != 0 ? { 1, 1, 1 } : _baseColor2)
                                      : (_useBaseColor2 != 0 ? _baseColor2 : { 1, 1, 1 }));
#line 5632 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result110 = (0 != 0 ? (_usePointColor2 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor2 != 0 ? Cd : { 1, 1, 1 }));




        found4 = renderstate("packed:Cd", val4);
        if (!found4) val4 = { 1, 1, 1 };
#line 5651 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result111 = (0 != 0 ? (_usePackedColor2 != 0 ? { 1, 1, 1 } : val4)
                                      : (_usePackedColor2 != 0 ? val4 : { 1, 1, 1 }));




        vector	_uv20 = _uv19;
        vector	_duv2 = vector();
        string	_map2 = _texture6;
        int	_udim9 = _udim8;
        string	_srccolorspace2 = _textureSourceColorSpace2;
        string	_wrap2 = _textureWrap2;
        string	_filter2 = _textureFilter2;
        float	_width2 = _textureFilterWidth2;
        float	_blur2 = 0;
        float	_pixelblur2 = 0;
        vector4	_border2 = _textureBorderColor2;
        int	_extrapol2 = 1;
        int	_interp2 = 1;
        vector4	_defclr2 = { 1, 1, 1, 1 };
        string	_channel6 = "";
        int	_ptexface2 = 0;
        int	_orient2 = 0;
        vector4	clr8 = vector4();
        {


            string	_mode3 = "uv";
            vector	uv28 = vector();
            float	u3 = 0.0;
            float	v3 = 0.0;
            float	w3 = 0.0;
            {


                bool30 = (_mode3 == "st");


                bound_uv16 = isbound("uv");
                if( bound_uv16 ) {
                    uv29 = uv;
                } else {
                    uv29 = vector();
                }



                uv30 = set(s, t, 0);





                if( bound_uv16 == 0 )
                    result112 = uv30;
                else
                    result112 = uv29;


                if( bool30 == 0 )
                    result113 = result112;
                else
                    result113 = uv30;


                assign(fval125,fval225,fval325, result113);


                uv28 = result113;
                u3 = fval125;
                v3 = fval225;
                w3 = fval325;
            }


            result114 = 1 != 0 ? _uv20 : uv28;


            _uv21 = result114;


            if (_map2 != "") {



                int fptex = 0 ? _ptexface2 : getptextureid();



                string wrapmode2 = _wrap2;
                if (_orient2 & 0x02) { _uv21.y = 1 - _uv21.y; }
                if (_orient2 & 0x04) { float x = _uv21.x; _uv21.x = _uv21.y; _uv21.y = x; }
                string _map_udim2 = _map2;
                if (_udim9) { _map_udim2 = expand_udim(_uv21.x, _uv21.y, _map2); }
                if (_map_udim2 == '') { clr9 = set(_defclr2); }
                else {
                    if (_map_udim2 != _map2) {
                        _uv21.x %= 1.0; _uv21.y %= 1.0;
                        wrapmode2 = 'streak';
                    }
                    if (_orient2 & 0x01) { _uv21.x = 1 - _uv21.x; }
                    if (0 != 0) {
                        vector tduv2 = 0.5 * _duv2;
                        if (_orient2 & 0x04) { float x = tduv2.x; tduv2.x = tduv2.y; tduv2.y = x; }
                        clr9 = texture(_map_udim2,
                                 _uv21.x - tduv2.x, _uv21.y - tduv2.y,
                                 _uv21.x + tduv2.x, _uv21.y - tduv2.y,
                                 _uv21.x + tduv2.x, _uv21.y + tduv2.y,
                                 _uv21.x - tduv2.x, _uv21.y + tduv2.y,
                                "wrap", wrapmode2, "filter", _filter2,
                                "width", _width2, "border", _border2,
                                "extrapolate", _extrapol2, "lerp", _interp2,
                                "channel", _channel6, "face", fptex,
                                "blur", _blur2, "pixelblur", _pixelblur2,
                                "srccolorspace", _srccolorspace2);
                    } else {
                        clr9 = texture(_map_udim2, _uv21.x, _uv21.y, "wrap", wrapmode2,
                                "filter", _filter2, "width", _width2,
                                "border", _border2, "extrapolate", _extrapol2,
                                "channel", _channel6, "face", fptex,
                                "lerp", _interp2,
                                "blur", _blur2, "pixelblur", _pixelblur2,
                                "srccolorspace", _srccolorspace2);
                    }
                }
            } else {
               clr9 = set(_defclr2);
            }


            clr8 = clr9;
        }
#line 5794 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result115 = (0 != 0 ? (_useTexture2 != 0 ? { 1, 1, 1, 1 } : clr8)
                                      : (_useTexture2 != 0 ? clr8 : { 1, 1, 1, 1 }));




        vec5 = (vector)result115;
        fval42 = getcomp(result115, 3);


        lum6 = luminance(vec5);


        assign(fval126,fval226,fval326, vec5);


        if( _monoChannel2 == 0 )
            result116 = lum6;
        else if( _monoChannel2 == 1 )
            result116 = fval126;
        else if( _monoChannel2 == 2 )
            result116 = fval226;
        else
            result116 = fval326;


        vec6 = set(result116,result116,result116);


        if( _monoOutput2 == 0 )
            result117 = vec5;
        else
            result117 = vec6;


        clamp4 = clamp(_textureIntensity2, 0, 1);



          blend6 = lerp({ 1, 1, 1 }, result117, clamp4);





        clamp5 = clamp(_textureIntensity2, 1, 1000);


        product26 = blend6 * clamp5;


        product27 = result109 * result110 * result111 * product26;
#line 5857 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result118 = (0 != 0 ? (_usePointAlpha2 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha2 != 0 ? Alpha : 1));




        found5 = renderstate("packed:Alpha", val5);
        if (!found5) val5 = 1;
#line 5876 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result119 = (0 != 0 ? (_usePackedAlpha2 != 0 ? 1 : val5)
                                      : (_usePackedAlpha2 != 0 ? val5 : 1));




        product28 = fval42 * result118 * result119;


        color2 = product27;
        alpha2 = product28;
    }


    assign(output15,output21,output31, color2);


    export_reflect = output15;
    export_reflect_tmp = export_reflect;


    output16 = set(reflecttint,reflecttint,reflecttint);


    vector	_uv22 = xformuvw;
    int	_useBaseColor3 = 1;
    vector	_baseColor3 = output16;
    int	_usePointColor3 = 0;
    int	_usePointAlpha3 = 0;
    int	_usePackedColor3 = 0;
    int	_usePackedAlpha3 = 0;
    int	_useTexture3 = reflecttint_useTexture;
    string	_texture7 = reflecttint_texture;
    int	_udim10 = 1;
    float	_textureIntensity3 = 1;
    string	_textureWrap3 = reflecttint_textureWrap;
    string	_textureSourceColorSpace3 = reflecttint_textureColorSpace;
    string	_textureFilter3 = surface_textureFilter;
    float	_textureFilterWidth3 = surface_textureFilterWidth;
    vector4	_textureBorderColor3 = { 0, 0, 0, 0 };
    int	_monoOutput3 = 1;
    int	_monoChannel3 = reflecttint_monoChannel;
    vector	color3 = vector();
    float	alpha3 = 0.0;
    {
#line 5932 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result120 = (0 != 0 ? (_useBaseColor3 != 0 ? { 1, 1, 1 } : _baseColor3)
                                      : (_useBaseColor3 != 0 ? _baseColor3 : { 1, 1, 1 }));
#line 5947 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result121 = (0 != 0 ? (_usePointColor3 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor3 != 0 ? Cd : { 1, 1, 1 }));




        found6 = renderstate("packed:Cd", val6);
        if (!found6) val6 = { 1, 1, 1 };
#line 5966 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result122 = (0 != 0 ? (_usePackedColor3 != 0 ? { 1, 1, 1 } : val6)
                                      : (_usePackedColor3 != 0 ? val6 : { 1, 1, 1 }));




        vector	_uv23 = _uv22;
        vector	_duv3 = vector();
        string	_map3 = _texture7;
        int	_udim11 = _udim10;
        string	_srccolorspace3 = _textureSourceColorSpace3;
        string	_wrap3 = _textureWrap3;
        string	_filter3 = _textureFilter3;
        float	_width3 = _textureFilterWidth3;
        float	_blur3 = 0;
        float	_pixelblur3 = 0;
        vector4	_border3 = _textureBorderColor3;
        int	_extrapol3 = 1;
        int	_interp3 = 1;
        vector4	_defclr3 = { 1, 1, 1, 1 };
        string	_channel7 = "";
        int	_ptexface3 = 0;
        int	_orient3 = 0;
        vector4	clr10 = vector4();
        {


            string	_mode4 = "uv";
            vector	uv31 = vector();
            float	u4 = 0.0;
            float	v4 = 0.0;
            float	w4 = 0.0;
            {


                bool31 = (_mode4 == "st");


                bound_uv17 = isbound("uv");
                if( bound_uv17 ) {
                    uv32 = uv;
                } else {
                    uv32 = vector();
                }



                uv33 = set(s, t, 0);





                if( bound_uv17 == 0 )
                    result123 = uv33;
                else
                    result123 = uv32;


                if( bool31 == 0 )
                    result124 = result123;
                else
                    result124 = uv33;


                assign(fval127,fval227,fval327, result124);


                uv31 = result124;
                u4 = fval127;
                v4 = fval227;
                w4 = fval327;
            }


            result125 = 1 != 0 ? _uv23 : uv31;


            _uv24 = result125;


            if (_map3 != "") {



                int fptex = 0 ? _ptexface3 : getptextureid();



                string wrapmode3 = _wrap3;
                if (_orient3 & 0x02) { _uv24.y = 1 - _uv24.y; }
                if (_orient3 & 0x04) { float x = _uv24.x; _uv24.x = _uv24.y; _uv24.y = x; }
                string _map_udim3 = _map3;
                if (_udim11) { _map_udim3 = expand_udim(_uv24.x, _uv24.y, _map3); }
                if (_map_udim3 == '') { clr11 = set(_defclr3); }
                else {
                    if (_map_udim3 != _map3) {
                        _uv24.x %= 1.0; _uv24.y %= 1.0;
                        wrapmode3 = 'streak';
                    }
                    if (_orient3 & 0x01) { _uv24.x = 1 - _uv24.x; }
                    if (0 != 0) {
                        vector tduv3 = 0.5 * _duv3;
                        if (_orient3 & 0x04) { float x = tduv3.x; tduv3.x = tduv3.y; tduv3.y = x; }
                        clr11 = texture(_map_udim3,
                                 _uv24.x - tduv3.x, _uv24.y - tduv3.y,
                                 _uv24.x + tduv3.x, _uv24.y - tduv3.y,
                                 _uv24.x + tduv3.x, _uv24.y + tduv3.y,
                                 _uv24.x - tduv3.x, _uv24.y + tduv3.y,
                                "wrap", wrapmode3, "filter", _filter3,
                                "width", _width3, "border", _border3,
                                "extrapolate", _extrapol3, "lerp", _interp3,
                                "channel", _channel7, "face", fptex,
                                "blur", _blur3, "pixelblur", _pixelblur3,
                                "srccolorspace", _srccolorspace3);
                    } else {
                        clr11 = texture(_map_udim3, _uv24.x, _uv24.y, "wrap", wrapmode3,
                                "filter", _filter3, "width", _width3,
                                "border", _border3, "extrapolate", _extrapol3,
                                "channel", _channel7, "face", fptex,
                                "lerp", _interp3,
                                "blur", _blur3, "pixelblur", _pixelblur3,
                                "srccolorspace", _srccolorspace3);
                    }
                }
            } else {
               clr11 = set(_defclr3);
            }


            clr10 = clr11;
        }
#line 6109 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result126 = (0 != 0 ? (_useTexture3 != 0 ? { 1, 1, 1, 1 } : clr10)
                                      : (_useTexture3 != 0 ? clr10 : { 1, 1, 1, 1 }));




        vec7 = (vector)result126;
        fval43 = getcomp(result126, 3);


        lum7 = luminance(vec7);


        assign(fval128,fval228,fval328, vec7);


        if( _monoChannel3 == 0 )
            result127 = lum7;
        else if( _monoChannel3 == 1 )
            result127 = fval128;
        else if( _monoChannel3 == 2 )
            result127 = fval228;
        else
            result127 = fval328;


        vec8 = set(result127,result127,result127);


        if( _monoOutput3 == 0 )
            result128 = vec7;
        else
            result128 = vec8;


        clamp6 = clamp(_textureIntensity3, 0, 1);



          blend7 = lerp({ 1, 1, 1 }, result128, clamp6);





        clamp7 = clamp(_textureIntensity3, 1, 1000);


        product29 = blend7 * clamp7;


        product30 = result120 * result121 * result122 * product29;
#line 6172 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result129 = (0 != 0 ? (_usePointAlpha3 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha3 != 0 ? Alpha : 1));




        found7 = renderstate("packed:Alpha", val7);
        if (!found7) val7 = 1;
#line 6191 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result130 = (0 != 0 ? (_usePackedAlpha3 != 0 ? 1 : val7)
                                      : (_usePackedAlpha3 != 0 ? val7 : 1));




        product31 = fval43 * result129 * result130;


        color3 = product30;
        alpha3 = product31;
    }


    assign(output17,output22,output32, color3);


    output18 = set(metallic,metallic,metallic);


    vector	_uv25 = xformuvw;
    int	_useBaseColor4 = 1;
    vector	_baseColor4 = output18;
    int	_usePointColor4 = 0;
    int	_usePointAlpha4 = 0;
    int	_usePackedColor4 = 0;
    int	_usePackedAlpha4 = 0;
    int	_useTexture4 = metallic_useTexture;
    string	_texture8 = metallic_texture;
    int	_udim12 = 1;
    float	_textureIntensity4 = 1;
    string	_textureWrap4 = metallic_textureWrap;
    string	_textureSourceColorSpace4 = metallic_textureColorSpace;
    string	_textureFilter4 = surface_textureFilter;
    float	_textureFilterWidth4 = surface_textureFilterWidth;
    vector4	_textureBorderColor4 = { 0, 0, 0, 0 };
    int	_monoOutput4 = 1;
    int	_monoChannel4 = metallic_monoChannel;
    vector	color4 = vector();
    float	alpha4 = 0.0;
    {
#line 6243 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result131 = (0 != 0 ? (_useBaseColor4 != 0 ? { 1, 1, 1 } : _baseColor4)
                                      : (_useBaseColor4 != 0 ? _baseColor4 : { 1, 1, 1 }));
#line 6258 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result132 = (0 != 0 ? (_usePointColor4 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor4 != 0 ? Cd : { 1, 1, 1 }));




        found8 = renderstate("packed:Cd", val8);
        if (!found8) val8 = { 1, 1, 1 };
#line 6277 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result133 = (0 != 0 ? (_usePackedColor4 != 0 ? { 1, 1, 1 } : val8)
                                      : (_usePackedColor4 != 0 ? val8 : { 1, 1, 1 }));




        vector	_uv26 = _uv25;
        vector	_duv4 = vector();
        string	_map4 = _texture8;
        int	_udim13 = _udim12;
        string	_srccolorspace4 = _textureSourceColorSpace4;
        string	_wrap4 = _textureWrap4;
        string	_filter4 = _textureFilter4;
        float	_width4 = _textureFilterWidth4;
        float	_blur4 = 0;
        float	_pixelblur4 = 0;
        vector4	_border4 = _textureBorderColor4;
        int	_extrapol4 = 1;
        int	_interp4 = 1;
        vector4	_defclr4 = { 1, 1, 1, 1 };
        string	_channel8 = "";
        int	_ptexface4 = 0;
        int	_orient4 = 0;
        vector4	clr12 = vector4();
        {


            string	_mode5 = "uv";
            vector	uv34 = vector();
            float	u5 = 0.0;
            float	v5 = 0.0;
            float	w5 = 0.0;
            {


                bool32 = (_mode5 == "st");


                bound_uv18 = isbound("uv");
                if( bound_uv18 ) {
                    uv35 = uv;
                } else {
                    uv35 = vector();
                }



                uv36 = set(s, t, 0);





                if( bound_uv18 == 0 )
                    result134 = uv36;
                else
                    result134 = uv35;


                if( bool32 == 0 )
                    result135 = result134;
                else
                    result135 = uv36;


                assign(fval129,fval229,fval329, result135);


                uv34 = result135;
                u5 = fval129;
                v5 = fval229;
                w5 = fval329;
            }


            result136 = 1 != 0 ? _uv26 : uv34;


            _uv27 = result136;


            if (_map4 != "") {



                int fptex = 0 ? _ptexface4 : getptextureid();



                string wrapmode4 = _wrap4;
                if (_orient4 & 0x02) { _uv27.y = 1 - _uv27.y; }
                if (_orient4 & 0x04) { float x = _uv27.x; _uv27.x = _uv27.y; _uv27.y = x; }
                string _map_udim4 = _map4;
                if (_udim13) { _map_udim4 = expand_udim(_uv27.x, _uv27.y, _map4); }
                if (_map_udim4 == '') { clr13 = set(_defclr4); }
                else {
                    if (_map_udim4 != _map4) {
                        _uv27.x %= 1.0; _uv27.y %= 1.0;
                        wrapmode4 = 'streak';
                    }
                    if (_orient4 & 0x01) { _uv27.x = 1 - _uv27.x; }
                    if (0 != 0) {
                        vector tduv4 = 0.5 * _duv4;
                        if (_orient4 & 0x04) { float x = tduv4.x; tduv4.x = tduv4.y; tduv4.y = x; }
                        clr13 = texture(_map_udim4,
                                 _uv27.x - tduv4.x, _uv27.y - tduv4.y,
                                 _uv27.x + tduv4.x, _uv27.y - tduv4.y,
                                 _uv27.x + tduv4.x, _uv27.y + tduv4.y,
                                 _uv27.x - tduv4.x, _uv27.y + tduv4.y,
                                "wrap", wrapmode4, "filter", _filter4,
                                "width", _width4, "border", _border4,
                                "extrapolate", _extrapol4, "lerp", _interp4,
                                "channel", _channel8, "face", fptex,
                                "blur", _blur4, "pixelblur", _pixelblur4,
                                "srccolorspace", _srccolorspace4);
                    } else {
                        clr13 = texture(_map_udim4, _uv27.x, _uv27.y, "wrap", wrapmode4,
                                "filter", _filter4, "width", _width4,
                                "border", _border4, "extrapolate", _extrapol4,
                                "channel", _channel8, "face", fptex,
                                "lerp", _interp4,
                                "blur", _blur4, "pixelblur", _pixelblur4,
                                "srccolorspace", _srccolorspace4);
                    }
                }
            } else {
               clr13 = set(_defclr4);
            }


            clr12 = clr13;
        }
#line 6420 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result137 = (0 != 0 ? (_useTexture4 != 0 ? { 1, 1, 1, 1 } : clr12)
                                      : (_useTexture4 != 0 ? clr12 : { 1, 1, 1, 1 }));




        vec9 = (vector)result137;
        fval44 = getcomp(result137, 3);


        lum8 = luminance(vec9);


        assign(fval130,fval230,fval330, vec9);


        if( _monoChannel4 == 0 )
            result138 = lum8;
        else if( _monoChannel4 == 1 )
            result138 = fval130;
        else if( _monoChannel4 == 2 )
            result138 = fval230;
        else
            result138 = fval330;


        vec10 = set(result138,result138,result138);


        if( _monoOutput4 == 0 )
            result139 = vec9;
        else
            result139 = vec10;


        clamp8 = clamp(_textureIntensity4, 0, 1);



          blend8 = lerp({ 1, 1, 1 }, result139, clamp8);





        clamp9 = clamp(_textureIntensity4, 1, 1000);


        product32 = blend8 * clamp9;


        product33 = result131 * result132 * result133 * product32;
#line 6483 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result140 = (0 != 0 ? (_usePointAlpha4 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha4 != 0 ? Alpha : 1));




        found9 = renderstate("packed:Alpha", val9);
        if (!found9) val9 = 1;
#line 6502 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result141 = (0 != 0 ? (_usePackedAlpha4 != 0 ? 1 : val9)
                                      : (_usePackedAlpha4 != 0 ? val9 : 1));




        product34 = fval44 * result140 * result141;


        color4 = product33;
        alpha4 = product34;
    }


    assign(output19,output23,output33, color4);


    output110 = set(aniso,aniso,aniso);


    vector	_uv28 = xformuvw;
    int	_useBaseColor5 = 1;
    vector	_baseColor5 = output110;
    int	_usePointColor5 = 0;
    int	_usePointAlpha5 = 0;
    int	_usePackedColor5 = 0;
    int	_usePackedAlpha5 = 0;
    int	_useTexture5 = aniso_useTexture;
    string	_texture9 = aniso_texture;
    int	_udim14 = 1;
    float	_textureIntensity5 = 1;
    string	_textureWrap5 = aniso_textureWrap;
    string	_textureSourceColorSpace5 = aniso_textureColorSpace;
    string	_textureFilter5 = surface_textureFilter;
    float	_textureFilterWidth5 = surface_textureFilterWidth;
    vector4	_textureBorderColor5 = { 0, 0, 0, 0 };
    int	_monoOutput5 = 1;
    int	_monoChannel5 = aniso_monoChannel;
    vector	color5 = vector();
    float	alpha5 = 0.0;
    {
#line 6554 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result142 = (0 != 0 ? (_useBaseColor5 != 0 ? { 1, 1, 1 } : _baseColor5)
                                      : (_useBaseColor5 != 0 ? _baseColor5 : { 1, 1, 1 }));
#line 6569 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result143 = (0 != 0 ? (_usePointColor5 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor5 != 0 ? Cd : { 1, 1, 1 }));




        found10 = renderstate("packed:Cd", val10);
        if (!found10) val10 = { 1, 1, 1 };
#line 6588 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result144 = (0 != 0 ? (_usePackedColor5 != 0 ? { 1, 1, 1 } : val10)
                                      : (_usePackedColor5 != 0 ? val10 : { 1, 1, 1 }));




        vector	_uv29 = _uv28;
        vector	_duv5 = vector();
        string	_map5 = _texture9;
        int	_udim15 = _udim14;
        string	_srccolorspace5 = _textureSourceColorSpace5;
        string	_wrap5 = _textureWrap5;
        string	_filter5 = _textureFilter5;
        float	_width5 = _textureFilterWidth5;
        float	_blur5 = 0;
        float	_pixelblur5 = 0;
        vector4	_border5 = _textureBorderColor5;
        int	_extrapol5 = 1;
        int	_interp5 = 1;
        vector4	_defclr5 = { 1, 1, 1, 1 };
        string	_channel9 = "";
        int	_ptexface5 = 0;
        int	_orient5 = 0;
        vector4	clr14 = vector4();
        {


            string	_mode6 = "uv";
            vector	uv37 = vector();
            float	u6 = 0.0;
            float	v6 = 0.0;
            float	w6 = 0.0;
            {


                bool33 = (_mode6 == "st");


                bound_uv19 = isbound("uv");
                if( bound_uv19 ) {
                    uv38 = uv;
                } else {
                    uv38 = vector();
                }



                uv39 = set(s, t, 0);





                if( bound_uv19 == 0 )
                    result145 = uv39;
                else
                    result145 = uv38;


                if( bool33 == 0 )
                    result146 = result145;
                else
                    result146 = uv39;


                assign(fval131,fval231,fval331, result146);


                uv37 = result146;
                u6 = fval131;
                v6 = fval231;
                w6 = fval331;
            }


            result147 = 1 != 0 ? _uv29 : uv37;


            _uv30 = result147;


            if (_map5 != "") {



                int fptex = 0 ? _ptexface5 : getptextureid();



                string wrapmode5 = _wrap5;
                if (_orient5 & 0x02) { _uv30.y = 1 - _uv30.y; }
                if (_orient5 & 0x04) { float x = _uv30.x; _uv30.x = _uv30.y; _uv30.y = x; }
                string _map_udim5 = _map5;
                if (_udim15) { _map_udim5 = expand_udim(_uv30.x, _uv30.y, _map5); }
                if (_map_udim5 == '') { clr15 = set(_defclr5); }
                else {
                    if (_map_udim5 != _map5) {
                        _uv30.x %= 1.0; _uv30.y %= 1.0;
                        wrapmode5 = 'streak';
                    }
                    if (_orient5 & 0x01) { _uv30.x = 1 - _uv30.x; }
                    if (0 != 0) {
                        vector tduv5 = 0.5 * _duv5;
                        if (_orient5 & 0x04) { float x = tduv5.x; tduv5.x = tduv5.y; tduv5.y = x; }
                        clr15 = texture(_map_udim5,
                                 _uv30.x - tduv5.x, _uv30.y - tduv5.y,
                                 _uv30.x + tduv5.x, _uv30.y - tduv5.y,
                                 _uv30.x + tduv5.x, _uv30.y + tduv5.y,
                                 _uv30.x - tduv5.x, _uv30.y + tduv5.y,
                                "wrap", wrapmode5, "filter", _filter5,
                                "width", _width5, "border", _border5,
                                "extrapolate", _extrapol5, "lerp", _interp5,
                                "channel", _channel9, "face", fptex,
                                "blur", _blur5, "pixelblur", _pixelblur5,
                                "srccolorspace", _srccolorspace5);
                    } else {
                        clr15 = texture(_map_udim5, _uv30.x, _uv30.y, "wrap", wrapmode5,
                                "filter", _filter5, "width", _width5,
                                "border", _border5, "extrapolate", _extrapol5,
                                "channel", _channel9, "face", fptex,
                                "lerp", _interp5,
                                "blur", _blur5, "pixelblur", _pixelblur5,
                                "srccolorspace", _srccolorspace5);
                    }
                }
            } else {
               clr15 = set(_defclr5);
            }


            clr14 = clr15;
        }
#line 6731 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result148 = (0 != 0 ? (_useTexture5 != 0 ? { 1, 1, 1, 1 } : clr14)
                                      : (_useTexture5 != 0 ? clr14 : { 1, 1, 1, 1 }));




        vec11 = (vector)result148;
        fval45 = getcomp(result148, 3);


        lum9 = luminance(vec11);


        assign(fval132,fval232,fval332, vec11);


        if( _monoChannel5 == 0 )
            result149 = lum9;
        else if( _monoChannel5 == 1 )
            result149 = fval132;
        else if( _monoChannel5 == 2 )
            result149 = fval232;
        else
            result149 = fval332;


        vec12 = set(result149,result149,result149);


        if( _monoOutput5 == 0 )
            result150 = vec11;
        else
            result150 = vec12;


        clamp10 = clamp(_textureIntensity5, 0, 1);



          blend9 = lerp({ 1, 1, 1 }, result150, clamp10);





        clamp11 = clamp(_textureIntensity5, 1, 1000);


        product35 = blend9 * clamp11;


        product36 = result142 * result143 * result144 * product35;
#line 6794 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result151 = (0 != 0 ? (_usePointAlpha5 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha5 != 0 ? Alpha : 1));




        found11 = renderstate("packed:Alpha", val11);
        if (!found11) val11 = 1;
#line 6813 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result152 = (0 != 0 ? (_usePackedAlpha5 != 0 ? 1 : val11)
                                      : (_usePackedAlpha5 != 0 ? val11 : 1));




        product37 = fval45 * result151 * result152;


        color5 = product36;
        alpha5 = product37;
    }


    assign(output111,output24,output34, color5);


    output112 = set(anisodir,anisodir,anisodir);


    vector	_uv31 = xformuvw;
    int	_useBaseColor6 = 1;
    vector	_baseColor6 = output112;
    int	_usePointColor6 = 0;
    int	_usePointAlpha6 = 0;
    int	_usePackedColor6 = 0;
    int	_usePackedAlpha6 = 0;
    int	_useTexture6 = anisodir_useTexture;
    string	_texture10 = anisodir_texture;
    int	_udim16 = 1;
    float	_textureIntensity6 = 1;
    string	_textureWrap6 = anisodir_textureWrap;
    string	_textureSourceColorSpace6 = "repeat";
    string	_textureFilter6 = anisodir_textureFilter;
    float	_textureFilterWidth6 = surface_textureFilterWidth;
    vector4	_textureBorderColor6 = { 0, 0, 0, 0 };
    int	_monoOutput6 = 1;
    int	_monoChannel6 = anisodir_monoChannel;
    vector	color6 = vector();
    float	alpha6 = 0.0;
    {
#line 6865 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result153 = (0 != 0 ? (_useBaseColor6 != 0 ? { 1, 1, 1 } : _baseColor6)
                                      : (_useBaseColor6 != 0 ? _baseColor6 : { 1, 1, 1 }));
#line 6880 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result154 = (0 != 0 ? (_usePointColor6 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor6 != 0 ? Cd : { 1, 1, 1 }));




        found12 = renderstate("packed:Cd", val12);
        if (!found12) val12 = { 1, 1, 1 };
#line 6899 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result155 = (0 != 0 ? (_usePackedColor6 != 0 ? { 1, 1, 1 } : val12)
                                      : (_usePackedColor6 != 0 ? val12 : { 1, 1, 1 }));




        vector	_uv32 = _uv31;
        vector	_duv6 = vector();
        string	_map6 = _texture10;
        int	_udim17 = _udim16;
        string	_srccolorspace6 = _textureSourceColorSpace6;
        string	_wrap6 = _textureWrap6;
        string	_filter6 = _textureFilter6;
        float	_width6 = _textureFilterWidth6;
        float	_blur6 = 0;
        float	_pixelblur6 = 0;
        vector4	_border6 = _textureBorderColor6;
        int	_extrapol6 = 1;
        int	_interp6 = 1;
        vector4	_defclr6 = { 1, 1, 1, 1 };
        string	_channel10 = "";
        int	_ptexface6 = 0;
        int	_orient6 = 0;
        vector4	clr16 = vector4();
        {


            string	_mode7 = "uv";
            vector	uv40 = vector();
            float	u7 = 0.0;
            float	v7 = 0.0;
            float	w7 = 0.0;
            {


                bool34 = (_mode7 == "st");


                bound_uv20 = isbound("uv");
                if( bound_uv20 ) {
                    uv41 = uv;
                } else {
                    uv41 = vector();
                }



                uv42 = set(s, t, 0);





                if( bound_uv20 == 0 )
                    result156 = uv42;
                else
                    result156 = uv41;


                if( bool34 == 0 )
                    result157 = result156;
                else
                    result157 = uv42;


                assign(fval133,fval233,fval333, result157);


                uv40 = result157;
                u7 = fval133;
                v7 = fval233;
                w7 = fval333;
            }


            result158 = 1 != 0 ? _uv32 : uv40;


            _uv33 = result158;


            if (_map6 != "") {



                int fptex = 0 ? _ptexface6 : getptextureid();



                string wrapmode6 = _wrap6;
                if (_orient6 & 0x02) { _uv33.y = 1 - _uv33.y; }
                if (_orient6 & 0x04) { float x = _uv33.x; _uv33.x = _uv33.y; _uv33.y = x; }
                string _map_udim6 = _map6;
                if (_udim17) { _map_udim6 = expand_udim(_uv33.x, _uv33.y, _map6); }
                if (_map_udim6 == '') { clr17 = set(_defclr6); }
                else {
                    if (_map_udim6 != _map6) {
                        _uv33.x %= 1.0; _uv33.y %= 1.0;
                        wrapmode6 = 'streak';
                    }
                    if (_orient6 & 0x01) { _uv33.x = 1 - _uv33.x; }
                    if (0 != 0) {
                        vector tduv6 = 0.5 * _duv6;
                        if (_orient6 & 0x04) { float x = tduv6.x; tduv6.x = tduv6.y; tduv6.y = x; }
                        clr17 = texture(_map_udim6,
                                 _uv33.x - tduv6.x, _uv33.y - tduv6.y,
                                 _uv33.x + tduv6.x, _uv33.y - tduv6.y,
                                 _uv33.x + tduv6.x, _uv33.y + tduv6.y,
                                 _uv33.x - tduv6.x, _uv33.y + tduv6.y,
                                "wrap", wrapmode6, "filter", _filter6,
                                "width", _width6, "border", _border6,
                                "extrapolate", _extrapol6, "lerp", _interp6,
                                "channel", _channel10, "face", fptex,
                                "blur", _blur6, "pixelblur", _pixelblur6,
                                "srccolorspace", _srccolorspace6);
                    } else {
                        clr17 = texture(_map_udim6, _uv33.x, _uv33.y, "wrap", wrapmode6,
                                "filter", _filter6, "width", _width6,
                                "border", _border6, "extrapolate", _extrapol6,
                                "channel", _channel10, "face", fptex,
                                "lerp", _interp6,
                                "blur", _blur6, "pixelblur", _pixelblur6,
                                "srccolorspace", _srccolorspace6);
                    }
                }
            } else {
               clr17 = set(_defclr6);
            }


            clr16 = clr17;
        }
#line 7042 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result159 = (0 != 0 ? (_useTexture6 != 0 ? { 1, 1, 1, 1 } : clr16)
                                      : (_useTexture6 != 0 ? clr16 : { 1, 1, 1, 1 }));




        vec13 = (vector)result159;
        fval46 = getcomp(result159, 3);


        lum10 = luminance(vec13);


        assign(fval134,fval234,fval334, vec13);


        if( _monoChannel6 == 0 )
            result160 = lum10;
        else if( _monoChannel6 == 1 )
            result160 = fval134;
        else if( _monoChannel6 == 2 )
            result160 = fval234;
        else
            result160 = fval334;


        vec14 = set(result160,result160,result160);


        if( _monoOutput6 == 0 )
            result161 = vec13;
        else
            result161 = vec14;


        clamp12 = clamp(_textureIntensity6, 0, 1);



          blend10 = lerp({ 1, 1, 1 }, result161, clamp12);





        clamp13 = clamp(_textureIntensity6, 1, 1000);


        product38 = blend10 * clamp13;


        product39 = result153 * result154 * result155 * product38;
#line 7105 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result162 = (0 != 0 ? (_usePointAlpha6 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha6 != 0 ? Alpha : 1));




        found13 = renderstate("packed:Alpha", val13);
        if (!found13) val13 = 1;
#line 7124 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result163 = (0 != 0 ? (_usePackedAlpha6 != 0 ? 1 : val13)
                                      : (_usePackedAlpha6 != 0 ? val13 : 1));




        product40 = fval46 * result162 * result163;


        color6 = product39;
        alpha6 = product40;
    }


    assign(output113,output25,output35, color6);


    output114 = set(coat,coat,coat);


    vector	_uv34 = xformuvw;
    int	_useBaseColor7 = 1;
    vector	_baseColor7 = output114;
    int	_usePointColor7 = 0;
    int	_usePointAlpha7 = 0;
    int	_usePackedColor7 = 0;
    int	_usePackedAlpha7 = 0;
    int	_useTexture7 = coat_useTexture;
    string	_texture11 = coat_texture;
    int	_udim18 = 1;
    float	_textureIntensity7 = 1;
    string	_textureWrap7 = coat_textureWrap;
    string	_textureSourceColorSpace7 = coat_textureColorSpace;
    string	_textureFilter7 = surface_textureFilter;
    float	_textureFilterWidth7 = surface_textureFilterWidth;
    vector4	_textureBorderColor7 = { 0, 0, 0, 0 };
    int	_monoOutput7 = 1;
    int	_monoChannel7 = coat_monoChannel;
    vector	color7 = vector();
    float	alpha7 = 0.0;
    {
#line 7176 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result164 = (0 != 0 ? (_useBaseColor7 != 0 ? { 1, 1, 1 } : _baseColor7)
                                      : (_useBaseColor7 != 0 ? _baseColor7 : { 1, 1, 1 }));
#line 7191 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result165 = (0 != 0 ? (_usePointColor7 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor7 != 0 ? Cd : { 1, 1, 1 }));




        found14 = renderstate("packed:Cd", val14);
        if (!found14) val14 = { 1, 1, 1 };
#line 7210 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result166 = (0 != 0 ? (_usePackedColor7 != 0 ? { 1, 1, 1 } : val14)
                                      : (_usePackedColor7 != 0 ? val14 : { 1, 1, 1 }));




        vector	_uv35 = _uv34;
        vector	_duv7 = vector();
        string	_map7 = _texture11;
        int	_udim19 = _udim18;
        string	_srccolorspace7 = _textureSourceColorSpace7;
        string	_wrap7 = _textureWrap7;
        string	_filter7 = _textureFilter7;
        float	_width7 = _textureFilterWidth7;
        float	_blur7 = 0;
        float	_pixelblur7 = 0;
        vector4	_border7 = _textureBorderColor7;
        int	_extrapol7 = 1;
        int	_interp7 = 1;
        vector4	_defclr7 = { 1, 1, 1, 1 };
        string	_channel11 = "";
        int	_ptexface7 = 0;
        int	_orient7 = 0;
        vector4	clr18 = vector4();
        {


            string	_mode8 = "uv";
            vector	uv43 = vector();
            float	u8 = 0.0;
            float	v8 = 0.0;
            float	w8 = 0.0;
            {


                bool35 = (_mode8 == "st");


                bound_uv21 = isbound("uv");
                if( bound_uv21 ) {
                    uv44 = uv;
                } else {
                    uv44 = vector();
                }



                uv45 = set(s, t, 0);





                if( bound_uv21 == 0 )
                    result167 = uv45;
                else
                    result167 = uv44;


                if( bool35 == 0 )
                    result168 = result167;
                else
                    result168 = uv45;


                assign(fval135,fval235,fval335, result168);


                uv43 = result168;
                u8 = fval135;
                v8 = fval235;
                w8 = fval335;
            }


            result169 = 1 != 0 ? _uv35 : uv43;


            _uv36 = result169;


            if (_map7 != "") {



                int fptex = 0 ? _ptexface7 : getptextureid();



                string wrapmode7 = _wrap7;
                if (_orient7 & 0x02) { _uv36.y = 1 - _uv36.y; }
                if (_orient7 & 0x04) { float x = _uv36.x; _uv36.x = _uv36.y; _uv36.y = x; }
                string _map_udim7 = _map7;
                if (_udim19) { _map_udim7 = expand_udim(_uv36.x, _uv36.y, _map7); }
                if (_map_udim7 == '') { clr19 = set(_defclr7); }
                else {
                    if (_map_udim7 != _map7) {
                        _uv36.x %= 1.0; _uv36.y %= 1.0;
                        wrapmode7 = 'streak';
                    }
                    if (_orient7 & 0x01) { _uv36.x = 1 - _uv36.x; }
                    if (0 != 0) {
                        vector tduv7 = 0.5 * _duv7;
                        if (_orient7 & 0x04) { float x = tduv7.x; tduv7.x = tduv7.y; tduv7.y = x; }
                        clr19 = texture(_map_udim7,
                                 _uv36.x - tduv7.x, _uv36.y - tduv7.y,
                                 _uv36.x + tduv7.x, _uv36.y - tduv7.y,
                                 _uv36.x + tduv7.x, _uv36.y + tduv7.y,
                                 _uv36.x - tduv7.x, _uv36.y + tduv7.y,
                                "wrap", wrapmode7, "filter", _filter7,
                                "width", _width7, "border", _border7,
                                "extrapolate", _extrapol7, "lerp", _interp7,
                                "channel", _channel11, "face", fptex,
                                "blur", _blur7, "pixelblur", _pixelblur7,
                                "srccolorspace", _srccolorspace7);
                    } else {
                        clr19 = texture(_map_udim7, _uv36.x, _uv36.y, "wrap", wrapmode7,
                                "filter", _filter7, "width", _width7,
                                "border", _border7, "extrapolate", _extrapol7,
                                "channel", _channel11, "face", fptex,
                                "lerp", _interp7,
                                "blur", _blur7, "pixelblur", _pixelblur7,
                                "srccolorspace", _srccolorspace7);
                    }
                }
            } else {
               clr19 = set(_defclr7);
            }


            clr18 = clr19;
        }
#line 7353 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result170 = (0 != 0 ? (_useTexture7 != 0 ? { 1, 1, 1, 1 } : clr18)
                                      : (_useTexture7 != 0 ? clr18 : { 1, 1, 1, 1 }));




        vec15 = (vector)result170;
        fval47 = getcomp(result170, 3);


        lum11 = luminance(vec15);


        assign(fval136,fval236,fval336, vec15);


        if( _monoChannel7 == 0 )
            result171 = lum11;
        else if( _monoChannel7 == 1 )
            result171 = fval136;
        else if( _monoChannel7 == 2 )
            result171 = fval236;
        else
            result171 = fval336;


        vec16 = set(result171,result171,result171);


        if( _monoOutput7 == 0 )
            result172 = vec15;
        else
            result172 = vec16;


        clamp14 = clamp(_textureIntensity7, 0, 1);



          blend11 = lerp({ 1, 1, 1 }, result172, clamp14);





        clamp15 = clamp(_textureIntensity7, 1, 1000);


        product41 = blend11 * clamp15;


        product42 = result164 * result165 * result166 * product41;
#line 7416 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result173 = (0 != 0 ? (_usePointAlpha7 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha7 != 0 ? Alpha : 1));




        found15 = renderstate("packed:Alpha", val15);
        if (!found15) val15 = 1;
#line 7435 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result174 = (0 != 0 ? (_usePackedAlpha7 != 0 ? 1 : val15)
                                      : (_usePackedAlpha7 != 0 ? val15 : 1));




        product43 = fval47 * result173 * result174;


        color7 = product42;
        alpha7 = product43;
    }


    assign(output115,output26,output36, color7);


    output116 = set(coatrough,coatrough,coatrough);


    vector	_uv37 = xformuvw;
    int	_useBaseColor8 = 1;
    vector	_baseColor8 = output116;
    int	_usePointColor8 = 0;
    int	_usePointAlpha8 = 0;
    int	_usePackedColor8 = 0;
    int	_usePackedAlpha8 = 0;
    int	_useTexture8 = coatrough_useTexture;
    string	_texture12 = coatrough_texture;
    int	_udim20 = 1;
    float	_textureIntensity8 = 1;
    string	_textureWrap8 = coatrough_textureWrap;
    string	_textureSourceColorSpace8 = coatrough_textureColorSpace;
    string	_textureFilter8 = surface_textureFilter;
    float	_textureFilterWidth8 = surface_textureFilterWidth;
    vector4	_textureBorderColor8 = { 0, 0, 0, 0 };
    int	_monoOutput8 = 1;
    int	_monoChannel8 = coatrough_monoChannel;
    vector	color8 = vector();
    float	alpha8 = 0.0;
    {
#line 7487 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result175 = (0 != 0 ? (_useBaseColor8 != 0 ? { 1, 1, 1 } : _baseColor8)
                                      : (_useBaseColor8 != 0 ? _baseColor8 : { 1, 1, 1 }));
#line 7502 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result176 = (0 != 0 ? (_usePointColor8 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor8 != 0 ? Cd : { 1, 1, 1 }));




        found16 = renderstate("packed:Cd", val16);
        if (!found16) val16 = { 1, 1, 1 };
#line 7521 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result177 = (0 != 0 ? (_usePackedColor8 != 0 ? { 1, 1, 1 } : val16)
                                      : (_usePackedColor8 != 0 ? val16 : { 1, 1, 1 }));




        vector	_uv38 = _uv37;
        vector	_duv8 = vector();
        string	_map8 = _texture12;
        int	_udim21 = _udim20;
        string	_srccolorspace8 = _textureSourceColorSpace8;
        string	_wrap8 = _textureWrap8;
        string	_filter8 = _textureFilter8;
        float	_width8 = _textureFilterWidth8;
        float	_blur8 = 0;
        float	_pixelblur8 = 0;
        vector4	_border8 = _textureBorderColor8;
        int	_extrapol8 = 1;
        int	_interp8 = 1;
        vector4	_defclr8 = { 1, 1, 1, 1 };
        string	_channel12 = "";
        int	_ptexface8 = 0;
        int	_orient8 = 0;
        vector4	clr20 = vector4();
        {


            string	_mode9 = "uv";
            vector	uv46 = vector();
            float	u9 = 0.0;
            float	v9 = 0.0;
            float	w9 = 0.0;
            {


                bool36 = (_mode9 == "st");


                bound_uv22 = isbound("uv");
                if( bound_uv22 ) {
                    uv47 = uv;
                } else {
                    uv47 = vector();
                }



                uv48 = set(s, t, 0);





                if( bound_uv22 == 0 )
                    result178 = uv48;
                else
                    result178 = uv47;


                if( bool36 == 0 )
                    result179 = result178;
                else
                    result179 = uv48;


                assign(fval137,fval237,fval337, result179);


                uv46 = result179;
                u9 = fval137;
                v9 = fval237;
                w9 = fval337;
            }


            result180 = 1 != 0 ? _uv38 : uv46;


            _uv39 = result180;


            if (_map8 != "") {



                int fptex = 0 ? _ptexface8 : getptextureid();



                string wrapmode8 = _wrap8;
                if (_orient8 & 0x02) { _uv39.y = 1 - _uv39.y; }
                if (_orient8 & 0x04) { float x = _uv39.x; _uv39.x = _uv39.y; _uv39.y = x; }
                string _map_udim8 = _map8;
                if (_udim21) { _map_udim8 = expand_udim(_uv39.x, _uv39.y, _map8); }
                if (_map_udim8 == '') { clr21 = set(_defclr8); }
                else {
                    if (_map_udim8 != _map8) {
                        _uv39.x %= 1.0; _uv39.y %= 1.0;
                        wrapmode8 = 'streak';
                    }
                    if (_orient8 & 0x01) { _uv39.x = 1 - _uv39.x; }
                    if (0 != 0) {
                        vector tduv8 = 0.5 * _duv8;
                        if (_orient8 & 0x04) { float x = tduv8.x; tduv8.x = tduv8.y; tduv8.y = x; }
                        clr21 = texture(_map_udim8,
                                 _uv39.x - tduv8.x, _uv39.y - tduv8.y,
                                 _uv39.x + tduv8.x, _uv39.y - tduv8.y,
                                 _uv39.x + tduv8.x, _uv39.y + tduv8.y,
                                 _uv39.x - tduv8.x, _uv39.y + tduv8.y,
                                "wrap", wrapmode8, "filter", _filter8,
                                "width", _width8, "border", _border8,
                                "extrapolate", _extrapol8, "lerp", _interp8,
                                "channel", _channel12, "face", fptex,
                                "blur", _blur8, "pixelblur", _pixelblur8,
                                "srccolorspace", _srccolorspace8);
                    } else {
                        clr21 = texture(_map_udim8, _uv39.x, _uv39.y, "wrap", wrapmode8,
                                "filter", _filter8, "width", _width8,
                                "border", _border8, "extrapolate", _extrapol8,
                                "channel", _channel12, "face", fptex,
                                "lerp", _interp8,
                                "blur", _blur8, "pixelblur", _pixelblur8,
                                "srccolorspace", _srccolorspace8);
                    }
                }
            } else {
               clr21 = set(_defclr8);
            }


            clr20 = clr21;
        }
#line 7664 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result181 = (0 != 0 ? (_useTexture8 != 0 ? { 1, 1, 1, 1 } : clr20)
                                      : (_useTexture8 != 0 ? clr20 : { 1, 1, 1, 1 }));




        vec17 = (vector)result181;
        fval48 = getcomp(result181, 3);


        lum12 = luminance(vec17);


        assign(fval138,fval238,fval338, vec17);


        if( _monoChannel8 == 0 )
            result182 = lum12;
        else if( _monoChannel8 == 1 )
            result182 = fval138;
        else if( _monoChannel8 == 2 )
            result182 = fval238;
        else
            result182 = fval338;


        vec18 = set(result182,result182,result182);


        if( _monoOutput8 == 0 )
            result183 = vec17;
        else
            result183 = vec18;


        clamp16 = clamp(_textureIntensity8, 0, 1);



          blend12 = lerp({ 1, 1, 1 }, result183, clamp16);





        clamp17 = clamp(_textureIntensity8, 1, 1000);


        product44 = blend12 * clamp17;


        product45 = result175 * result176 * result177 * product44;
#line 7727 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result184 = (0 != 0 ? (_usePointAlpha8 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha8 != 0 ? Alpha : 1));




        found17 = renderstate("packed:Alpha", val17);
        if (!found17) val17 = 1;
#line 7746 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result185 = (0 != 0 ? (_usePackedAlpha8 != 0 ? 1 : val17)
                                      : (_usePackedAlpha8 != 0 ? val17 : 1));




        product46 = fval48 * result184 * result185;


        color8 = product45;
        alpha8 = product46;
    }


    assign(output117,output27,output37, color8);


    vector	_uv40 = xformuvw;
    int	_useBaseColor9 = 1;
    vector	_baseColor9 = emitcolor;
    int	_usePointColor9 = 0;
    int	_usePointAlpha9 = 0;
    int	_usePackedColor9 = 0;
    int	_usePackedAlpha9 = 0;
    int	_useTexture9 = emitcolor_useTexture;
    string	_texture13 = emitcolor_texture;
    int	_udim22 = 1;
    float	_textureIntensity9 = emitcolor_textureIntensity;
    string	_textureWrap9 = emitcolor_textureWrap;
    string	_textureSourceColorSpace9 = emitcolor_textureColorSpace;
    string	_textureFilter9 = surface_textureFilter;
    float	_textureFilterWidth9 = surface_textureFilterWidth;
    vector4	_textureBorderColor9 = { 0, 0, 0, 0 };
    int	_monoOutput9 = 0;
    int	_monoChannel9 = 0;
    vector	color9 = vector();
    float	alpha9 = 0.0;
    {
#line 7795 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result186 = (0 != 0 ? (_useBaseColor9 != 0 ? { 1, 1, 1 } : _baseColor9)
                                      : (_useBaseColor9 != 0 ? _baseColor9 : { 1, 1, 1 }));
#line 7810 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result187 = (0 != 0 ? (_usePointColor9 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor9 != 0 ? Cd : { 1, 1, 1 }));




        found18 = renderstate("packed:Cd", val18);
        if (!found18) val18 = { 1, 1, 1 };
#line 7829 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result188 = (0 != 0 ? (_usePackedColor9 != 0 ? { 1, 1, 1 } : val18)
                                      : (_usePackedColor9 != 0 ? val18 : { 1, 1, 1 }));




        vector	_uv41 = _uv40;
        vector	_duv9 = vector();
        string	_map9 = _texture13;
        int	_udim23 = _udim22;
        string	_srccolorspace9 = _textureSourceColorSpace9;
        string	_wrap9 = _textureWrap9;
        string	_filter9 = _textureFilter9;
        float	_width9 = _textureFilterWidth9;
        float	_blur9 = 0;
        float	_pixelblur9 = 0;
        vector4	_border9 = _textureBorderColor9;
        int	_extrapol9 = 1;
        int	_interp9 = 1;
        vector4	_defclr9 = { 1, 1, 1, 1 };
        string	_channel13 = "";
        int	_ptexface9 = 0;
        int	_orient9 = 0;
        vector4	clr22 = vector4();
        {


            string	_mode10 = "uv";
            vector	uv49 = vector();
            float	u10 = 0.0;
            float	v10 = 0.0;
            float	w10 = 0.0;
            {


                bool37 = (_mode10 == "st");


                bound_uv23 = isbound("uv");
                if( bound_uv23 ) {
                    uv50 = uv;
                } else {
                    uv50 = vector();
                }



                uv51 = set(s, t, 0);





                if( bound_uv23 == 0 )
                    result189 = uv51;
                else
                    result189 = uv50;


                if( bool37 == 0 )
                    result190 = result189;
                else
                    result190 = uv51;


                assign(fval139,fval239,fval339, result190);


                uv49 = result190;
                u10 = fval139;
                v10 = fval239;
                w10 = fval339;
            }


            result191 = 1 != 0 ? _uv41 : uv49;


            _uv42 = result191;


            if (_map9 != "") {



                int fptex = 0 ? _ptexface9 : getptextureid();



                string wrapmode9 = _wrap9;
                if (_orient9 & 0x02) { _uv42.y = 1 - _uv42.y; }
                if (_orient9 & 0x04) { float x = _uv42.x; _uv42.x = _uv42.y; _uv42.y = x; }
                string _map_udim9 = _map9;
                if (_udim23) { _map_udim9 = expand_udim(_uv42.x, _uv42.y, _map9); }
                if (_map_udim9 == '') { clr23 = set(_defclr9); }
                else {
                    if (_map_udim9 != _map9) {
                        _uv42.x %= 1.0; _uv42.y %= 1.0;
                        wrapmode9 = 'streak';
                    }
                    if (_orient9 & 0x01) { _uv42.x = 1 - _uv42.x; }
                    if (0 != 0) {
                        vector tduv9 = 0.5 * _duv9;
                        if (_orient9 & 0x04) { float x = tduv9.x; tduv9.x = tduv9.y; tduv9.y = x; }
                        clr23 = texture(_map_udim9,
                                 _uv42.x - tduv9.x, _uv42.y - tduv9.y,
                                 _uv42.x + tduv9.x, _uv42.y - tduv9.y,
                                 _uv42.x + tduv9.x, _uv42.y + tduv9.y,
                                 _uv42.x - tduv9.x, _uv42.y + tduv9.y,
                                "wrap", wrapmode9, "filter", _filter9,
                                "width", _width9, "border", _border9,
                                "extrapolate", _extrapol9, "lerp", _interp9,
                                "channel", _channel13, "face", fptex,
                                "blur", _blur9, "pixelblur", _pixelblur9,
                                "srccolorspace", _srccolorspace9);
                    } else {
                        clr23 = texture(_map_udim9, _uv42.x, _uv42.y, "wrap", wrapmode9,
                                "filter", _filter9, "width", _width9,
                                "border", _border9, "extrapolate", _extrapol9,
                                "channel", _channel13, "face", fptex,
                                "lerp", _interp9,
                                "blur", _blur9, "pixelblur", _pixelblur9,
                                "srccolorspace", _srccolorspace9);
                    }
                }
            } else {
               clr23 = set(_defclr9);
            }


            clr22 = clr23;
        }
#line 7972 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result192 = (0 != 0 ? (_useTexture9 != 0 ? { 1, 1, 1, 1 } : clr22)
                                      : (_useTexture9 != 0 ? clr22 : { 1, 1, 1, 1 }));




        vec19 = (vector)result192;
        fval49 = getcomp(result192, 3);


        lum13 = luminance(vec19);


        assign(fval140,fval240,fval340, vec19);


        if( _monoChannel9 == 0 )
            result193 = lum13;
        else if( _monoChannel9 == 1 )
            result193 = fval140;
        else if( _monoChannel9 == 2 )
            result193 = fval240;
        else
            result193 = fval340;


        vec20 = set(result193,result193,result193);


        if( _monoOutput9 == 0 )
            result194 = vec19;
        else
            result194 = vec20;


        clamp18 = clamp(_textureIntensity9, 0, 1);



          blend13 = lerp({ 1, 1, 1 }, result194, clamp18);





        clamp19 = clamp(_textureIntensity9, 1, 1000);


        product47 = blend13 * clamp19;


        product48 = result186 * result187 * result188 * product47;
#line 8035 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result195 = (0 != 0 ? (_usePointAlpha9 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha9 != 0 ? Alpha : 1));




        found19 = renderstate("packed:Alpha", val19);
        if (!found19) val19 = 1;
#line 8054 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result196 = (0 != 0 ? (_usePackedAlpha9 != 0 ? 1 : val19)
                                      : (_usePackedAlpha9 != 0 ? val19 : 1));




        product49 = fval49 * result195 * result196;


        color9 = product48;
        alpha9 = product49;
    }


    product50 = color9 * emitint;


    output118 = set(sss,sss,sss);


    vector	_uv43 = xformuvw;
    int	_useBaseColor10 = 1;
    vector	_baseColor10 = output118;
    int	_usePointColor10 = 0;
    int	_usePointAlpha10 = 0;
    int	_usePackedColor10 = 0;
    int	_usePackedAlpha10 = 0;
    int	_useTexture10 = sss_useTexture;
    string	_texture14 = sss_texture;
    int	_udim24 = 1;
    float	_textureIntensity10 = 1;
    string	_textureWrap10 = sss_textureWrap;
    string	_textureSourceColorSpace10 = sss_textureColorSpace;
    string	_textureFilter10 = surface_textureFilter;
    float	_textureFilterWidth10 = surface_textureFilterWidth;
    vector4	_textureBorderColor10 = { 0, 0, 0, 0 };
    int	_monoOutput10 = 1;
    int	_monoChannel10 = sss_monoChannel;
    vector	color10 = vector();
    float	alpha10 = 0.0;
    {
#line 8106 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result197 = (0 != 0 ? (_useBaseColor10 != 0 ? { 1, 1, 1 } : _baseColor10)
                                      : (_useBaseColor10 != 0 ? _baseColor10 : { 1, 1, 1 }));
#line 8121 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result198 = (0 != 0 ? (_usePointColor10 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor10 != 0 ? Cd : { 1, 1, 1 }));




        found20 = renderstate("packed:Cd", val20);
        if (!found20) val20 = { 1, 1, 1 };
#line 8140 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result199 = (0 != 0 ? (_usePackedColor10 != 0 ? { 1, 1, 1 } : val20)
                                      : (_usePackedColor10 != 0 ? val20 : { 1, 1, 1 }));




        vector	_uv44 = _uv43;
        vector	_duv10 = vector();
        string	_map10 = _texture14;
        int	_udim25 = _udim24;
        string	_srccolorspace10 = _textureSourceColorSpace10;
        string	_wrap10 = _textureWrap10;
        string	_filter10 = _textureFilter10;
        float	_width10 = _textureFilterWidth10;
        float	_blur10 = 0;
        float	_pixelblur10 = 0;
        vector4	_border10 = _textureBorderColor10;
        int	_extrapol10 = 1;
        int	_interp10 = 1;
        vector4	_defclr10 = { 1, 1, 1, 1 };
        string	_channel14 = "";
        int	_ptexface10 = 0;
        int	_orient10 = 0;
        vector4	clr24 = vector4();
        {


            string	_mode11 = "uv";
            vector	uv52 = vector();
            float	u11 = 0.0;
            float	v11 = 0.0;
            float	w11 = 0.0;
            {


                bool38 = (_mode11 == "st");


                bound_uv24 = isbound("uv");
                if( bound_uv24 ) {
                    uv53 = uv;
                } else {
                    uv53 = vector();
                }



                uv54 = set(s, t, 0);





                if( bound_uv24 == 0 )
                    result200 = uv54;
                else
                    result200 = uv53;


                if( bool38 == 0 )
                    result201 = result200;
                else
                    result201 = uv54;


                assign(fval141,fval241,fval341, result201);


                uv52 = result201;
                u11 = fval141;
                v11 = fval241;
                w11 = fval341;
            }


            result202 = 1 != 0 ? _uv44 : uv52;


            _uv45 = result202;


            if (_map10 != "") {



                int fptex = 0 ? _ptexface10 : getptextureid();



                string wrapmode10 = _wrap10;
                if (_orient10 & 0x02) { _uv45.y = 1 - _uv45.y; }
                if (_orient10 & 0x04) { float x = _uv45.x; _uv45.x = _uv45.y; _uv45.y = x; }
                string _map_udim10 = _map10;
                if (_udim25) { _map_udim10 = expand_udim(_uv45.x, _uv45.y, _map10); }
                if (_map_udim10 == '') { clr25 = set(_defclr10); }
                else {
                    if (_map_udim10 != _map10) {
                        _uv45.x %= 1.0; _uv45.y %= 1.0;
                        wrapmode10 = 'streak';
                    }
                    if (_orient10 & 0x01) { _uv45.x = 1 - _uv45.x; }
                    if (0 != 0) {
                        vector tduv10 = 0.5 * _duv10;
                        if (_orient10 & 0x04) { float x = tduv10.x; tduv10.x = tduv10.y; tduv10.y = x; }
                        clr25 = texture(_map_udim10,
                                 _uv45.x - tduv10.x, _uv45.y - tduv10.y,
                                 _uv45.x + tduv10.x, _uv45.y - tduv10.y,
                                 _uv45.x + tduv10.x, _uv45.y + tduv10.y,
                                 _uv45.x - tduv10.x, _uv45.y + tduv10.y,
                                "wrap", wrapmode10, "filter", _filter10,
                                "width", _width10, "border", _border10,
                                "extrapolate", _extrapol10, "lerp", _interp10,
                                "channel", _channel14, "face", fptex,
                                "blur", _blur10, "pixelblur", _pixelblur10,
                                "srccolorspace", _srccolorspace10);
                    } else {
                        clr25 = texture(_map_udim10, _uv45.x, _uv45.y, "wrap", wrapmode10,
                                "filter", _filter10, "width", _width10,
                                "border", _border10, "extrapolate", _extrapol10,
                                "channel", _channel14, "face", fptex,
                                "lerp", _interp10,
                                "blur", _blur10, "pixelblur", _pixelblur10,
                                "srccolorspace", _srccolorspace10);
                    }
                }
            } else {
               clr25 = set(_defclr10);
            }


            clr24 = clr25;
        }
#line 8283 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result203 = (0 != 0 ? (_useTexture10 != 0 ? { 1, 1, 1, 1 } : clr24)
                                      : (_useTexture10 != 0 ? clr24 : { 1, 1, 1, 1 }));




        vec21 = (vector)result203;
        fval410 = getcomp(result203, 3);


        lum14 = luminance(vec21);


        assign(fval142,fval242,fval342, vec21);


        if( _monoChannel10 == 0 )
            result204 = lum14;
        else if( _monoChannel10 == 1 )
            result204 = fval142;
        else if( _monoChannel10 == 2 )
            result204 = fval242;
        else
            result204 = fval342;


        vec22 = set(result204,result204,result204);


        if( _monoOutput10 == 0 )
            result205 = vec21;
        else
            result205 = vec22;


        clamp20 = clamp(_textureIntensity10, 0, 1);



          blend14 = lerp({ 1, 1, 1 }, result205, clamp20);





        clamp21 = clamp(_textureIntensity10, 1, 1000);


        product51 = blend14 * clamp21;


        product52 = result197 * result198 * result199 * product51;
#line 8346 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result206 = (0 != 0 ? (_usePointAlpha10 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha10 != 0 ? Alpha : 1));




        found21 = renderstate("packed:Alpha", val21);
        if (!found21) val21 = 1;
#line 8365 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result207 = (0 != 0 ? (_usePackedAlpha10 != 0 ? 1 : val21)
                                      : (_usePackedAlpha10 != 0 ? val21 : 1));




        product53 = fval410 * result206 * result207;


        color10 = product52;
        alpha10 = product53;
    }


    assign(output119,output28,output38, color10);


    output120 = set(sssdist,sssdist,sssdist);


    vector	_uv46 = vector();
    int	_useBaseColor11 = 1;
    vector	_baseColor11 = output120;
    int	_usePointColor11 = 0;
    int	_usePointAlpha11 = 0;
    int	_usePackedColor11 = 0;
    int	_usePackedAlpha11 = 0;
    int	_useTexture11 = sssdist_useTexture;
    string	_texture15 = sssdist_texture;
    int	_udim26 = 1;
    float	_textureIntensity11 = 1;
    string	_textureWrap11 = sssdist_textureWrap;
    string	_textureSourceColorSpace11 = sssdist_textureColorSpace;
    string	_textureFilter11 = "catrom";
    float	_textureFilterWidth11 = 1;
    vector4	_textureBorderColor11 = { 0, 0, 0, 0 };
    int	_monoOutput11 = 1;
    int	_monoChannel11 = sssdist_monoChannel;
    vector	color11 = vector();
    float	alpha11 = 0.0;
    {
#line 8417 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result208 = (0 != 0 ? (_useBaseColor11 != 0 ? { 1, 1, 1 } : _baseColor11)
                                      : (_useBaseColor11 != 0 ? _baseColor11 : { 1, 1, 1 }));
#line 8432 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result209 = (0 != 0 ? (_usePointColor11 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor11 != 0 ? Cd : { 1, 1, 1 }));




        found22 = renderstate("packed:Cd", val22);
        if (!found22) val22 = { 1, 1, 1 };
#line 8451 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result210 = (0 != 0 ? (_usePackedColor11 != 0 ? { 1, 1, 1 } : val22)
                                      : (_usePackedColor11 != 0 ? val22 : { 1, 1, 1 }));




        vector	_uv47 = _uv46;
        vector	_duv11 = vector();
        string	_map11 = _texture15;
        int	_udim27 = _udim26;
        string	_srccolorspace11 = _textureSourceColorSpace11;
        string	_wrap11 = _textureWrap11;
        string	_filter11 = _textureFilter11;
        float	_width11 = _textureFilterWidth11;
        float	_blur11 = 0;
        float	_pixelblur11 = 0;
        vector4	_border11 = _textureBorderColor11;
        int	_extrapol11 = 1;
        int	_interp11 = 1;
        vector4	_defclr11 = { 1, 1, 1, 1 };
        string	_channel15 = "";
        int	_ptexface11 = 0;
        int	_orient11 = 0;
        vector4	clr26 = vector4();
        {


            string	_mode12 = "uv";
            vector	uv55 = vector();
            float	u12 = 0.0;
            float	v12 = 0.0;
            float	w12 = 0.0;
            {


                bool39 = (_mode12 == "st");


                bound_uv25 = isbound("uv");
                if( bound_uv25 ) {
                    uv56 = uv;
                } else {
                    uv56 = vector();
                }



                uv57 = set(s, t, 0);





                if( bound_uv25 == 0 )
                    result211 = uv57;
                else
                    result211 = uv56;


                if( bool39 == 0 )
                    result212 = result211;
                else
                    result212 = uv57;


                assign(fval143,fval243,fval343, result212);


                uv55 = result212;
                u12 = fval143;
                v12 = fval243;
                w12 = fval343;
            }


            result213 = 0 != 0 ? _uv47 : uv55;


            _uv48 = result213;


            if (_map11 != "") {



                int fptex = 0 ? _ptexface11 : getptextureid();



                string wrapmode11 = _wrap11;
                if (_orient11 & 0x02) { _uv48.y = 1 - _uv48.y; }
                if (_orient11 & 0x04) { float x = _uv48.x; _uv48.x = _uv48.y; _uv48.y = x; }
                string _map_udim11 = _map11;
                if (_udim27) { _map_udim11 = expand_udim(_uv48.x, _uv48.y, _map11); }
                if (_map_udim11 == '') { clr27 = set(_defclr11); }
                else {
                    if (_map_udim11 != _map11) {
                        _uv48.x %= 1.0; _uv48.y %= 1.0;
                        wrapmode11 = 'streak';
                    }
                    if (_orient11 & 0x01) { _uv48.x = 1 - _uv48.x; }
                    if (0 != 0) {
                        vector tduv11 = 0.5 * _duv11;
                        if (_orient11 & 0x04) { float x = tduv11.x; tduv11.x = tduv11.y; tduv11.y = x; }
                        clr27 = texture(_map_udim11,
                                 _uv48.x - tduv11.x, _uv48.y - tduv11.y,
                                 _uv48.x + tduv11.x, _uv48.y - tduv11.y,
                                 _uv48.x + tduv11.x, _uv48.y + tduv11.y,
                                 _uv48.x - tduv11.x, _uv48.y + tduv11.y,
                                "wrap", wrapmode11, "filter", _filter11,
                                "width", _width11, "border", _border11,
                                "extrapolate", _extrapol11, "lerp", _interp11,
                                "channel", _channel15, "face", fptex,
                                "blur", _blur11, "pixelblur", _pixelblur11,
                                "srccolorspace", _srccolorspace11);
                    } else {
                        clr27 = texture(_map_udim11, _uv48.x, _uv48.y, "wrap", wrapmode11,
                                "filter", _filter11, "width", _width11,
                                "border", _border11, "extrapolate", _extrapol11,
                                "channel", _channel15, "face", fptex,
                                "lerp", _interp11,
                                "blur", _blur11, "pixelblur", _pixelblur11,
                                "srccolorspace", _srccolorspace11);
                    }
                }
            } else {
               clr27 = set(_defclr11);
            }


            clr26 = clr27;
        }
#line 8594 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result214 = (0 != 0 ? (_useTexture11 != 0 ? { 1, 1, 1, 1 } : clr26)
                                      : (_useTexture11 != 0 ? clr26 : { 1, 1, 1, 1 }));




        vec23 = (vector)result214;
        fval411 = getcomp(result214, 3);


        lum15 = luminance(vec23);


        assign(fval144,fval244,fval344, vec23);


        if( _monoChannel11 == 0 )
            result215 = lum15;
        else if( _monoChannel11 == 1 )
            result215 = fval144;
        else if( _monoChannel11 == 2 )
            result215 = fval244;
        else
            result215 = fval344;


        vec24 = set(result215,result215,result215);


        if( _monoOutput11 == 0 )
            result216 = vec23;
        else
            result216 = vec24;


        clamp22 = clamp(_textureIntensity11, 0, 1);



          blend15 = lerp({ 1, 1, 1 }, result216, clamp22);





        clamp23 = clamp(_textureIntensity11, 1, 1000);


        product54 = blend15 * clamp23;


        product55 = result208 * result209 * result210 * product54;
#line 8657 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result217 = (0 != 0 ? (_usePointAlpha11 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha11 != 0 ? Alpha : 1));




        found23 = renderstate("packed:Alpha", val23);
        if (!found23) val23 = 1;
#line 8676 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result218 = (0 != 0 ? (_usePackedAlpha11 != 0 ? 1 : val23)
                                      : (_usePackedAlpha11 != 0 ? val23 : 1));




        product56 = fval411 * result217 * result218;


        color11 = product55;
        alpha11 = product56;
    }


    assign(output121,output29,output39, color11);


    vector	_uv49 = vector();
    int	_useBaseColor12 = 1;
    vector	_baseColor12 = ssscolor;
    int	_usePointColor12 = 0;
    int	_usePointAlpha12 = 0;
    int	_usePackedColor12 = 0;
    int	_usePackedAlpha12 = 0;
    int	_useTexture12 = ssscolor_useTexture;
    string	_texture16 = ssscolor_texture;
    int	_udim28 = 1;
    float	_textureIntensity12 = 1;
    string	_textureWrap12 = ssscolor_textureWrap;
    string	_textureSourceColorSpace12 = ssscolor_textureColorSpace;
    string	_textureFilter12 = "catrom";
    float	_textureFilterWidth12 = 1;
    vector4	_textureBorderColor12 = { 0, 0, 0, 0 };
    int	_monoOutput12 = 0;
    int	_monoChannel12 = 0;
    vector	color12 = vector();
    float	alpha12 = 0.0;
    {
#line 8725 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result219 = (0 != 0 ? (_useBaseColor12 != 0 ? { 1, 1, 1 } : _baseColor12)
                                      : (_useBaseColor12 != 0 ? _baseColor12 : { 1, 1, 1 }));
#line 8740 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result220 = (0 != 0 ? (_usePointColor12 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor12 != 0 ? Cd : { 1, 1, 1 }));




        found24 = renderstate("packed:Cd", val24);
        if (!found24) val24 = { 1, 1, 1 };
#line 8759 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result221 = (0 != 0 ? (_usePackedColor12 != 0 ? { 1, 1, 1 } : val24)
                                      : (_usePackedColor12 != 0 ? val24 : { 1, 1, 1 }));




        vector	_uv50 = _uv49;
        vector	_duv12 = vector();
        string	_map12 = _texture16;
        int	_udim29 = _udim28;
        string	_srccolorspace12 = _textureSourceColorSpace12;
        string	_wrap12 = _textureWrap12;
        string	_filter12 = _textureFilter12;
        float	_width12 = _textureFilterWidth12;
        float	_blur12 = 0;
        float	_pixelblur12 = 0;
        vector4	_border12 = _textureBorderColor12;
        int	_extrapol12 = 1;
        int	_interp12 = 1;
        vector4	_defclr12 = { 1, 1, 1, 1 };
        string	_channel16 = "";
        int	_ptexface12 = 0;
        int	_orient12 = 0;
        vector4	clr28 = vector4();
        {


            string	_mode13 = "uv";
            vector	uv58 = vector();
            float	u13 = 0.0;
            float	v13 = 0.0;
            float	w13 = 0.0;
            {


                bool40 = (_mode13 == "st");


                bound_uv26 = isbound("uv");
                if( bound_uv26 ) {
                    uv59 = uv;
                } else {
                    uv59 = vector();
                }



                uv60 = set(s, t, 0);





                if( bound_uv26 == 0 )
                    result222 = uv60;
                else
                    result222 = uv59;


                if( bool40 == 0 )
                    result223 = result222;
                else
                    result223 = uv60;


                assign(fval145,fval245,fval345, result223);


                uv58 = result223;
                u13 = fval145;
                v13 = fval245;
                w13 = fval345;
            }


            result224 = 0 != 0 ? _uv50 : uv58;


            _uv51 = result224;


            if (_map12 != "") {



                int fptex = 0 ? _ptexface12 : getptextureid();



                string wrapmode12 = _wrap12;
                if (_orient12 & 0x02) { _uv51.y = 1 - _uv51.y; }
                if (_orient12 & 0x04) { float x = _uv51.x; _uv51.x = _uv51.y; _uv51.y = x; }
                string _map_udim12 = _map12;
                if (_udim29) { _map_udim12 = expand_udim(_uv51.x, _uv51.y, _map12); }
                if (_map_udim12 == '') { clr29 = set(_defclr12); }
                else {
                    if (_map_udim12 != _map12) {
                        _uv51.x %= 1.0; _uv51.y %= 1.0;
                        wrapmode12 = 'streak';
                    }
                    if (_orient12 & 0x01) { _uv51.x = 1 - _uv51.x; }
                    if (0 != 0) {
                        vector tduv12 = 0.5 * _duv12;
                        if (_orient12 & 0x04) { float x = tduv12.x; tduv12.x = tduv12.y; tduv12.y = x; }
                        clr29 = texture(_map_udim12,
                                 _uv51.x - tduv12.x, _uv51.y - tduv12.y,
                                 _uv51.x + tduv12.x, _uv51.y - tduv12.y,
                                 _uv51.x + tduv12.x, _uv51.y + tduv12.y,
                                 _uv51.x - tduv12.x, _uv51.y + tduv12.y,
                                "wrap", wrapmode12, "filter", _filter12,
                                "width", _width12, "border", _border12,
                                "extrapolate", _extrapol12, "lerp", _interp12,
                                "channel", _channel16, "face", fptex,
                                "blur", _blur12, "pixelblur", _pixelblur12,
                                "srccolorspace", _srccolorspace12);
                    } else {
                        clr29 = texture(_map_udim12, _uv51.x, _uv51.y, "wrap", wrapmode12,
                                "filter", _filter12, "width", _width12,
                                "border", _border12, "extrapolate", _extrapol12,
                                "channel", _channel16, "face", fptex,
                                "lerp", _interp12,
                                "blur", _blur12, "pixelblur", _pixelblur12,
                                "srccolorspace", _srccolorspace12);
                    }
                }
            } else {
               clr29 = set(_defclr12);
            }


            clr28 = clr29;
        }
#line 8902 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result225 = (0 != 0 ? (_useTexture12 != 0 ? { 1, 1, 1, 1 } : clr28)
                                      : (_useTexture12 != 0 ? clr28 : { 1, 1, 1, 1 }));




        vec25 = (vector)result225;
        fval412 = getcomp(result225, 3);


        lum16 = luminance(vec25);


        assign(fval146,fval246,fval346, vec25);


        if( _monoChannel12 == 0 )
            result226 = lum16;
        else if( _monoChannel12 == 1 )
            result226 = fval146;
        else if( _monoChannel12 == 2 )
            result226 = fval246;
        else
            result226 = fval346;


        vec26 = set(result226,result226,result226);


        if( _monoOutput12 == 0 )
            result227 = vec25;
        else
            result227 = vec26;


        clamp24 = clamp(_textureIntensity12, 0, 1);



          blend16 = lerp({ 1, 1, 1 }, result227, clamp24);





        clamp25 = clamp(_textureIntensity12, 1, 1000);


        product57 = blend16 * clamp25;


        product58 = result219 * result220 * result221 * product57;
#line 8965 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result228 = (0 != 0 ? (_usePointAlpha12 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha12 != 0 ? Alpha : 1));




        found25 = renderstate("packed:Alpha", val25);
        if (!found25) val25 = 1;
#line 8984 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result229 = (0 != 0 ? (_usePackedAlpha12 != 0 ? 1 : val25)
                                      : (_usePackedAlpha12 != 0 ? val25 : 1));




        product59 = fval412 * result228 * result229;


        color12 = product58;
        alpha12 = product59;
    }


    output122 = set(sheen,sheen,sheen);


    vector	_uv52 = xformuvw;
    int	_useBaseColor13 = 1;
    vector	_baseColor13 = output122;
    int	_usePointColor13 = 0;
    int	_usePointAlpha13 = 0;
    int	_usePackedColor13 = 0;
    int	_usePackedAlpha13 = 0;
    int	_useTexture13 = sheen_useTexture;
    string	_texture17 = sheen_texture;
    int	_udim30 = 1;
    float	_textureIntensity13 = 1;
    string	_textureWrap13 = sheen_textureWrap;
    string	_textureSourceColorSpace13 = sheen_textureColorSpace;
    string	_textureFilter13 = surface_textureFilter;
    float	_textureFilterWidth13 = surface_textureFilterWidth;
    vector4	_textureBorderColor13 = { 0, 0, 0, 0 };
    int	_monoOutput13 = 1;
    int	_monoChannel13 = sheen_monoChannel;
    vector	color13 = vector();
    float	alpha13 = 0.0;
    {
#line 9033 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result230 = (0 != 0 ? (_useBaseColor13 != 0 ? { 1, 1, 1 } : _baseColor13)
                                      : (_useBaseColor13 != 0 ? _baseColor13 : { 1, 1, 1 }));
#line 9048 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result231 = (0 != 0 ? (_usePointColor13 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor13 != 0 ? Cd : { 1, 1, 1 }));




        found26 = renderstate("packed:Cd", val26);
        if (!found26) val26 = { 1, 1, 1 };
#line 9067 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result232 = (0 != 0 ? (_usePackedColor13 != 0 ? { 1, 1, 1 } : val26)
                                      : (_usePackedColor13 != 0 ? val26 : { 1, 1, 1 }));




        vector	_uv53 = _uv52;
        vector	_duv13 = vector();
        string	_map13 = _texture17;
        int	_udim31 = _udim30;
        string	_srccolorspace13 = _textureSourceColorSpace13;
        string	_wrap13 = _textureWrap13;
        string	_filter13 = _textureFilter13;
        float	_width13 = _textureFilterWidth13;
        float	_blur13 = 0;
        float	_pixelblur13 = 0;
        vector4	_border13 = _textureBorderColor13;
        int	_extrapol13 = 1;
        int	_interp13 = 1;
        vector4	_defclr13 = { 1, 1, 1, 1 };
        string	_channel17 = "";
        int	_ptexface13 = 0;
        int	_orient13 = 0;
        vector4	clr30 = vector4();
        {


            string	_mode14 = "uv";
            vector	uv61 = vector();
            float	u14 = 0.0;
            float	v14 = 0.0;
            float	w14 = 0.0;
            {


                bool41 = (_mode14 == "st");


                bound_uv27 = isbound("uv");
                if( bound_uv27 ) {
                    uv62 = uv;
                } else {
                    uv62 = vector();
                }



                uv63 = set(s, t, 0);





                if( bound_uv27 == 0 )
                    result233 = uv63;
                else
                    result233 = uv62;


                if( bool41 == 0 )
                    result234 = result233;
                else
                    result234 = uv63;


                assign(fval147,fval247,fval347, result234);


                uv61 = result234;
                u14 = fval147;
                v14 = fval247;
                w14 = fval347;
            }


            result235 = 1 != 0 ? _uv53 : uv61;


            _uv54 = result235;


            if (_map13 != "") {



                int fptex = 0 ? _ptexface13 : getptextureid();



                string wrapmode13 = _wrap13;
                if (_orient13 & 0x02) { _uv54.y = 1 - _uv54.y; }
                if (_orient13 & 0x04) { float x = _uv54.x; _uv54.x = _uv54.y; _uv54.y = x; }
                string _map_udim13 = _map13;
                if (_udim31) { _map_udim13 = expand_udim(_uv54.x, _uv54.y, _map13); }
                if (_map_udim13 == '') { clr31 = set(_defclr13); }
                else {
                    if (_map_udim13 != _map13) {
                        _uv54.x %= 1.0; _uv54.y %= 1.0;
                        wrapmode13 = 'streak';
                    }
                    if (_orient13 & 0x01) { _uv54.x = 1 - _uv54.x; }
                    if (0 != 0) {
                        vector tduv13 = 0.5 * _duv13;
                        if (_orient13 & 0x04) { float x = tduv13.x; tduv13.x = tduv13.y; tduv13.y = x; }
                        clr31 = texture(_map_udim13,
                                 _uv54.x - tduv13.x, _uv54.y - tduv13.y,
                                 _uv54.x + tduv13.x, _uv54.y - tduv13.y,
                                 _uv54.x + tduv13.x, _uv54.y + tduv13.y,
                                 _uv54.x - tduv13.x, _uv54.y + tduv13.y,
                                "wrap", wrapmode13, "filter", _filter13,
                                "width", _width13, "border", _border13,
                                "extrapolate", _extrapol13, "lerp", _interp13,
                                "channel", _channel17, "face", fptex,
                                "blur", _blur13, "pixelblur", _pixelblur13,
                                "srccolorspace", _srccolorspace13);
                    } else {
                        clr31 = texture(_map_udim13, _uv54.x, _uv54.y, "wrap", wrapmode13,
                                "filter", _filter13, "width", _width13,
                                "border", _border13, "extrapolate", _extrapol13,
                                "channel", _channel17, "face", fptex,
                                "lerp", _interp13,
                                "blur", _blur13, "pixelblur", _pixelblur13,
                                "srccolorspace", _srccolorspace13);
                    }
                }
            } else {
               clr31 = set(_defclr13);
            }


            clr30 = clr31;
        }
#line 9210 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result236 = (0 != 0 ? (_useTexture13 != 0 ? { 1, 1, 1, 1 } : clr30)
                                      : (_useTexture13 != 0 ? clr30 : { 1, 1, 1, 1 }));




        vec27 = (vector)result236;
        fval413 = getcomp(result236, 3);


        lum17 = luminance(vec27);


        assign(fval148,fval248,fval348, vec27);


        if( _monoChannel13 == 0 )
            result237 = lum17;
        else if( _monoChannel13 == 1 )
            result237 = fval148;
        else if( _monoChannel13 == 2 )
            result237 = fval248;
        else
            result237 = fval348;


        vec28 = set(result237,result237,result237);


        if( _monoOutput13 == 0 )
            result238 = vec27;
        else
            result238 = vec28;


        clamp26 = clamp(_textureIntensity13, 0, 1);



          blend17 = lerp({ 1, 1, 1 }, result238, clamp26);





        clamp27 = clamp(_textureIntensity13, 1, 1000);


        product60 = blend17 * clamp27;


        product61 = result230 * result231 * result232 * product60;
#line 9273 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result239 = (0 != 0 ? (_usePointAlpha13 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha13 != 0 ? Alpha : 1));




        found27 = renderstate("packed:Alpha", val27);
        if (!found27) val27 = 1;
#line 9292 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result240 = (0 != 0 ? (_usePackedAlpha13 != 0 ? 1 : val27)
                                      : (_usePackedAlpha13 != 0 ? val27 : 1));




        product62 = fval413 * result239 * result240;


        color13 = product61;
        alpha13 = product62;
    }


    assign(output123,output210,output310, color13);


    output124 = set(sheentint,sheentint,sheentint);


    vector	_uv55 = xformuvw;
    int	_useBaseColor14 = 1;
    vector	_baseColor14 = output124;
    int	_usePointColor14 = 0;
    int	_usePointAlpha14 = 0;
    int	_usePackedColor14 = 0;
    int	_usePackedAlpha14 = 0;
    int	_useTexture14 = sheentint_useTexture;
    string	_texture18 = sheentint_texture;
    int	_udim32 = 1;
    float	_textureIntensity14 = 1;
    string	_textureWrap14 = sheentint_textureWrap;
    string	_textureSourceColorSpace14 = sheentint_textureColorSpace;
    string	_textureFilter14 = surface_textureFilter;
    float	_textureFilterWidth14 = surface_textureFilterWidth;
    vector4	_textureBorderColor14 = { 0, 0, 0, 0 };
    int	_monoOutput14 = 1;
    int	_monoChannel14 = sheentint_monoChannel;
    vector	color14 = vector();
    float	alpha14 = 0.0;
    {
#line 9344 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result241 = (0 != 0 ? (_useBaseColor14 != 0 ? { 1, 1, 1 } : _baseColor14)
                                      : (_useBaseColor14 != 0 ? _baseColor14 : { 1, 1, 1 }));
#line 9359 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result242 = (0 != 0 ? (_usePointColor14 != 0 ? { 1, 1, 1 } : Cd)
                                      : (_usePointColor14 != 0 ? Cd : { 1, 1, 1 }));




        found28 = renderstate("packed:Cd", val28);
        if (!found28) val28 = { 1, 1, 1 };
#line 9378 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result243 = (0 != 0 ? (_usePackedColor14 != 0 ? { 1, 1, 1 } : val28)
                                      : (_usePackedColor14 != 0 ? val28 : { 1, 1, 1 }));




        vector	_uv56 = _uv55;
        vector	_duv14 = vector();
        string	_map14 = _texture18;
        int	_udim33 = _udim32;
        string	_srccolorspace14 = _textureSourceColorSpace14;
        string	_wrap14 = _textureWrap14;
        string	_filter14 = _textureFilter14;
        float	_width14 = _textureFilterWidth14;
        float	_blur14 = 0;
        float	_pixelblur14 = 0;
        vector4	_border14 = _textureBorderColor14;
        int	_extrapol14 = 1;
        int	_interp14 = 1;
        vector4	_defclr14 = { 1, 1, 1, 1 };
        string	_channel18 = "";
        int	_ptexface14 = 0;
        int	_orient14 = 0;
        vector4	clr32 = vector4();
        {


            string	_mode15 = "uv";
            vector	uv64 = vector();
            float	u15 = 0.0;
            float	v15 = 0.0;
            float	w15 = 0.0;
            {


                bool42 = (_mode15 == "st");


                bound_uv28 = isbound("uv");
                if( bound_uv28 ) {
                    uv65 = uv;
                } else {
                    uv65 = vector();
                }



                uv66 = set(s, t, 0);





                if( bound_uv28 == 0 )
                    result244 = uv66;
                else
                    result244 = uv65;


                if( bool42 == 0 )
                    result245 = result244;
                else
                    result245 = uv66;


                assign(fval149,fval249,fval349, result245);


                uv64 = result245;
                u15 = fval149;
                v15 = fval249;
                w15 = fval349;
            }


            result246 = 1 != 0 ? _uv56 : uv64;


            _uv57 = result246;


            if (_map14 != "") {



                int fptex = 0 ? _ptexface14 : getptextureid();



                string wrapmode14 = _wrap14;
                if (_orient14 & 0x02) { _uv57.y = 1 - _uv57.y; }
                if (_orient14 & 0x04) { float x = _uv57.x; _uv57.x = _uv57.y; _uv57.y = x; }
                string _map_udim14 = _map14;
                if (_udim33) { _map_udim14 = expand_udim(_uv57.x, _uv57.y, _map14); }
                if (_map_udim14 == '') { clr33 = set(_defclr14); }
                else {
                    if (_map_udim14 != _map14) {
                        _uv57.x %= 1.0; _uv57.y %= 1.0;
                        wrapmode14 = 'streak';
                    }
                    if (_orient14 & 0x01) { _uv57.x = 1 - _uv57.x; }
                    if (0 != 0) {
                        vector tduv14 = 0.5 * _duv14;
                        if (_orient14 & 0x04) { float x = tduv14.x; tduv14.x = tduv14.y; tduv14.y = x; }
                        clr33 = texture(_map_udim14,
                                 _uv57.x - tduv14.x, _uv57.y - tduv14.y,
                                 _uv57.x + tduv14.x, _uv57.y - tduv14.y,
                                 _uv57.x + tduv14.x, _uv57.y + tduv14.y,
                                 _uv57.x - tduv14.x, _uv57.y + tduv14.y,
                                "wrap", wrapmode14, "filter", _filter14,
                                "width", _width14, "border", _border14,
                                "extrapolate", _extrapol14, "lerp", _interp14,
                                "channel", _channel18, "face", fptex,
                                "blur", _blur14, "pixelblur", _pixelblur14,
                                "srccolorspace", _srccolorspace14);
                    } else {
                        clr33 = texture(_map_udim14, _uv57.x, _uv57.y, "wrap", wrapmode14,
                                "filter", _filter14, "width", _width14,
                                "border", _border14, "extrapolate", _extrapol14,
                                "channel", _channel18, "face", fptex,
                                "lerp", _interp14,
                                "blur", _blur14, "pixelblur", _pixelblur14,
                                "srccolorspace", _srccolorspace14);
                    }
                }
            } else {
               clr33 = set(_defclr14);
            }


            clr32 = clr33;
        }
#line 9521 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result247 = (0 != 0 ? (_useTexture14 != 0 ? { 1, 1, 1, 1 } : clr32)
                                      : (_useTexture14 != 0 ? clr32 : { 1, 1, 1, 1 }));




        vec29 = (vector)result247;
        fval414 = getcomp(result247, 3);


        lum18 = luminance(vec29);


        assign(fval150,fval250,fval350, vec29);


        if( _monoChannel14 == 0 )
            result248 = lum18;
        else if( _monoChannel14 == 1 )
            result248 = fval150;
        else if( _monoChannel14 == 2 )
            result248 = fval250;
        else
            result248 = fval350;


        vec30 = set(result248,result248,result248);


        if( _monoOutput14 == 0 )
            result249 = vec29;
        else
            result249 = vec30;


        clamp28 = clamp(_textureIntensity14, 0, 1);



          blend18 = lerp({ 1, 1, 1 }, result249, clamp28);





        clamp29 = clamp(_textureIntensity14, 1, 1000);


        product63 = blend18 * clamp29;


        product64 = result241 * result242 * result243 * product63;
#line 9584 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result250 = (0 != 0 ? (_usePointAlpha14 != 0 ? 1 : Alpha)
                                      : (_usePointAlpha14 != 0 ? Alpha : 1));




        found29 = renderstate("packed:Alpha", val29);
        if (!found29) val29 = 1;
#line 9603 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            result251 = (0 != 0 ? (_usePackedAlpha14 != 0 ? 1 : val29)
                                      : (_usePackedAlpha14 != 0 ? val29 : 1));




        product65 = fval414 * result250 * result251;


        color14 = product64;
        alpha14 = product65;
    }


    assign(output125,output211,output311, color14);


    vector	_baseN = result40;
    vector	_coatN = result80;
    vector	_utan5 = _utan4;
    vector	_basecolor = color;
    float	_roughness = output13;
    float	_reflect = export_reflect_tmp;
    float	_reflecttint = output17;
    float	_metallic = output19;
    float	_aniso = output111;
    float	_anisodir = output113;
    float	_coat = output115;
    float	_coatrough = output117;
    float	_coatlightcull = coatlightcull;
    vector	_emitcolor = product50;
    int	_emitillum = emitillum;
    string	_diffuse_label = difflabel;
    string	_reflect_label = refllabel;
    string	_coat_label = coatlabel;
    float	_sss = output119;
    float	_sssdist = output121;
    vector	_ssscolor = color12;
    string	_ssslabel = ssslabel;
    float	_sheen = output123;
    float	_sheentint = output125;
    float	_top_layer_ior = top_layer_ior;
    bsdf	F1 = bsdf();
    vector	Ce1 = vector();
    ShaderLayer	layer1 = {};
    {


        result252 = 1 != 0 ? _baseN : N;


        vector myI = 0 != 0 ? vector() : I;
        vector myN4 = 1 != 0 ? result252 : N;
        frontN = frontface(myN4, myI);
        if (1)
            frontN = normalize(frontN);



        vector tnN = 1 ? frontN : normalize(N);
        vector tnNg = dot(tnN, Ng) > 0 ? Ng : -Ng;





        float eta = 1.0/_top_layer_ior;

        if(1)
        {
            tnN = frontface(tnN, I);
            tnNg = frontface(tnNg, I);
        }

        f = 2.0*cvex_bsdf("fresneldiffuse_eval", "fresneldiffuse_sample",
                       "label", _diffuse_label,
                       "N", tnN,
                       "eta", eta
                       );

        f *= _basecolor;


        init_layer(layer2);
        layer2.F = f;



        {
           float _mfp = _sssdist;
           f1 = cvex_bsdf(
           "approxsss_eval",
           "approxsss_sample",
           "label", _ssslabel,
           "mfp", _mfp,
           "sssclr", _ssscolor
        );
        f1 *= _basecolor; }



          blend19 = lerp(f, f1, _sss);





        result253 = 1 != 0 ? _utan5 : dPds;


        vector	__basecolor = _basecolor;
        vector	result254 = vector();
        {


            lum19 = luminance(__basecolor);


            bool43 = (lum19 > 0);


            white = { 1, 1, 1 };


            div = __basecolor / lum19;


            if( bool43 == 0 )
                result255 = white;
            else
                result255 = div;


            result254 = result255;
        }



          blend20 = lerp({ 1, 1, 1 }, result254, _reflecttint);






        vector tnN1 = 1 ? frontN : normalize(N);
        vector tanu = 1 ? result253 : normalize(dPds);





        vector f0 = blend20;

        float index = 1;

        float rx = _roughness*_roughness;
        float ry = rx;

        if(_aniso!=0){
            {
                matrix3 rot = ident();

                rotate(rot, -3.1415926*(_anisodir+0.5), cross(cross(tanu, tnN1), tanu));
                tanu *= rot;
            }

            float aniso_value = _aniso*_aniso*rx;
            rx += aniso_value;
            ry -= aniso_value;
        } else {
            matrix3 to_world = dihedral({0.0,0.0,1.0}, tnN1);
            tanu = {1,0,0} * to_world;
        }

        float top_layer_eta = 1.0/_top_layer_ior;

        f2 = cvex_bsdf("mrp_ggx_eval", "mrp_ggx_sample",
                       "label", _reflect_label,
                       "bouncemasklabels", bouncemask(_reflect_label),
                       "nN", tnN1,
                       "fresnel0", f0,
                       "index", index,
                       "tangent", tanu,
                       "top_layer_eta", top_layer_eta,
                       "roughnessx", rx,
                       "roughnessy", ry);


        scaled8 = _reflect * 0.080000000000000002;


        product66 = f2 * scaled8;



        vector tnN2 = 1 ? frontN : normalize(N);
        vector tanu1 = 0 ? vector() : normalize(dPds);





        vector f01 = { 1, 1, 1 };

        float index1 = 1;

        float rx1 = 2*2;
        float ry1 = rx1;

        if(0!=0){
            {
                matrix3 rot1 = ident();

                rotate(rot1, -3.1415926*(0+0.5), cross(cross(tanu1, tnN2), tanu1));
                tanu1 *= rot1;
            }

            float aniso_value = 0*0*rx1;
            rx1 += aniso_value;
            ry1 -= aniso_value;
        } else {
            matrix3 to_world = dihedral({0.0,0.0,1.0}, tnN2);
            tanu1 = {1,0,0} * to_world;
        }

        float top_layer_eta1 = 1.0/_top_layer_ior;

        f3 = cvex_bsdf("mrp_ggx_eval", "mrp_ggx_sample",
                       "label", _diffuse_label,
                       "bouncemasklabels", bouncemask(_diffuse_label),
                       "nN", tnN2,
                       "fresnel0", f01,
                       "index", index1,
                       "tangent", tanu1,
                       "top_layer_eta", top_layer_eta1,
                       "roughnessx", rx1,
                       "roughnessy", ry1);



          blend21 = lerp({ 1, 1, 1 }, result254, _sheentint);





        product67 = f3 * _sheen * blend21 * blend21;


        sum12 = blend19 + product66 + product67;



        vector tnN3 = 1 ? frontN : normalize(N);
        vector tanu2 = 1 ? result253 : normalize(dPds);





        vector f02 = _basecolor;

        float index2 = 1;

        float rx2 = _roughness*_roughness;
        float ry2 = rx2;

        if(_aniso!=0){
            {
                matrix3 rot2 = ident();

                rotate(rot2, -3.1415926*(_anisodir+0.5), cross(cross(tanu2, tnN3), tanu2));
                tanu2 *= rot2;
            }

            float aniso_value = _aniso*_aniso*rx2;
            rx2 += aniso_value;
            ry2 -= aniso_value;
        } else {
            matrix3 to_world = dihedral({0.0,0.0,1.0}, tnN3);
            tanu2 = {1,0,0} * to_world;
        }

        float top_layer_eta2 = 1.0/_top_layer_ior;

        f4 = cvex_bsdf("mrp_ggx_eval", "mrp_ggx_sample",
                       "label", _reflect_label,
                       "bouncemasklabels", bouncemask(_reflect_label),
                       "nN", tnN3,
                       "fresnel0", f02,
                       "index", index2,
                       "tangent", tanu2,
                       "top_layer_eta", top_layer_eta2,
                       "roughnessx", rx2,
                       "roughnessy", ry2);



          blend22 = lerp(sum12, f4, _metallic);





        result256 = 1 != 0 ? _coatN : N;


        vector myI1 = 0 != 0 ? vector() : I;
        vector myN5 = 1 != 0 ? result256 : N;
        frontN1 = frontface(myN5, myI1);
        if (1)
            frontN1 = normalize(frontN1);



        vector tnN4 = 1 ? frontN1 : normalize(N);
        vector tanu3 = 0 ? vector() : normalize(dPds);





        vector f03 = { 0.05000000074505806, 0.05000000074505806, 0.05000000074505806 };

        float index3 = 1;

        float rx3 = _coatrough*_coatrough;
        float ry3 = rx3;

        if(0!=0){
            {
                matrix3 rot3 = ident();

                rotate(rot3, -3.1415926*(0+0.5), cross(cross(tanu3, tnN4), tanu3));
                tanu3 *= rot3;
            }

            float aniso_value = 0*0*rx3;
            rx3 += aniso_value;
            ry3 -= aniso_value;
        } else {
            matrix3 to_world = dihedral({0.0,0.0,1.0}, tnN4);
            tanu3 = {1,0,0} * to_world;
        }

        float top_layer_eta3 = 1.0/1;

        f5 = cvex_bsdf("mrp_ggx_eval", "mrp_ggx_sample",
                       "label", _coat_label,
                       "bouncemasklabels", bouncemask(_coat_label),
                       "nN", tnN4,
                       "fresnel0", f03,
                       "index", index3,
                       "tangent", tanu3,
                       "top_layer_eta", top_layer_eta3,
                       "roughnessx", rx3,
                       "roughnessy", ry3);


        product68 = f5 * _coat;


        int components = 0;
        if (1)
            components |= bouncemask("alldiffuse");
        if (1)
            components |= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
        if (0)
            components |= bouncemask("allvolume");

        vector ii = (0 != 0) ? vector() : normalize(I);
        albedo1 = albedo(product68, -ii, components);


        complem = -albedo1;
        complem += 1;



          blend23 = lerp({ 1, 1, 1 }, complem, _coatlightcull);





        product69 = blend22 * blend23;


        sum13 = product69 + product68;


        bsdf	_f = sum13;
        float	scale107 = 0.0;

        {


            int components1 = 0;
            if (1)
                components1 |= bouncemask("alldiffuse");
            if (1)
                components1 |= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
            if (0)
                components1 |= bouncemask("allvolume");

            vector ii1 = (0 != 0) ? vector() : normalize(I);
            albedo2 = albedo(_f, -ii1, components1);


            lum20 = luminance(albedo2);


            eps = 9.9999999999999995e-07;


            max = max( lum20 , eps );



              inverse = 1.0 / max;





            input2 = 1;


            min = min( inverse , input2 );


            product70 = _f * min;


            scale108 = min;


            _f = product70;
            scale107 = scale108;
        }


        init_layer(layer3);

        layer3.F = select(1, _f, layer3.F);
        layer3.Of = select(0, vector(), layer3.Of);
        layer3.Ce = select(0, vector(), layer3.Ce);
        layer3.P = select(0, vector(), layer3.P);
        layer3.N = select(0, vector(), layer3.N);
        layer3.masks = select(0, {}, layer3.masks);



        vector tnN5 = 0 ? nN : normalize(N);
        vector tnNg1 = normalize(Ng);
        vector tnI = 0 ? nI : normalize(I);
        vector tanu4 = 0 ? utan5 : normalize(dPds);
        vector tanv = 0 ? vtan5 : normalize(dPdt);








        if(1)
        {
            layer4 = layer3;
        }
        else
        {
            init_layer(layer4);
        }

        if(1)
            tnN5 = frontface(tnN5, tnI);

        if(dot(tnI, tnN5) < 0)
        {
            Ce2 = 1 * _emitcolor;
            Ce2 *= _emitillum || getraylevel() == 0;
            layer4.Ce = Ce2;
        }


        ShaderLayer	_layer = layer4;
        bsdf	F2 = bsdf();
        vector	Of1 = vector();
        vector	Ce3 = vector();
        vector	P1 = vector();
        vector	N1 = vector();
        float	layeralpha = 0.0;
        float	masks[] = {};
        {


            out_struct = _layer;
            out_F = out_struct.F;
            out_Of = out_struct.Of;
            out_Ce = out_struct.Ce;
            out_P = out_struct.P;
            out_N = out_struct.N;
            out_layeralpha = out_struct.layeralpha;
            out_masks = out_struct.masks;


            F2 = out_F;
            Of1 = out_Of;
            Ce3 = out_Ce;
            P1 = out_P;
            N1 = out_N;
            layeralpha = out_layeralpha;
            masks = out_masks;
        }


        F1 = F2;
        Ce1 = Ce3;
        layer1 = layer4;
    }


    ShaderLayer	_layer1 = layer1;
    bsdf	_F = bsdf();
    vector	_Of = { 1, 1, 1 };
    vector	_Ce = { 0, 0, 0 };
    vector	Cf1 = vector();
    vector	out_Of1 = vector();
    bsdf	out_F1 = bsdf();
    {


        ShaderLayer	__layer = _layer1;
        bsdf	__F = _F;
        vector	__Of = _Of;
        vector	__Ce = _Ce;
        bsdf	F3 = bsdf();
        vector	Of2 = vector();
        vector	Ce4 = vector();
        float	masks1[] = {};
        {


            connected5 = 0 ? 1 : 0;


            connected6 = 1;


            init_layer(layer5);

            layer5.F = select(0, bsdf(), layer5.F);
            layer5.Of = select(0, vector(), layer5.Of);
            layer5.Ce = select(0, vector(), layer5.Ce);
            layer5.P = select(0, vector(), layer5.P);
            layer5.N = select(0, vector(), layer5.N);
            layer5.masks = select(0, {}, layer5.masks);


            if( connected6 == 0 )
                result257 = layer5;
            else
                result257 = __layer;


            ShaderLayer	_layer2 = result257;
            bsdf	F4 = bsdf();
            vector	Of3 = vector();
            vector	Ce5 = vector();
            vector	P2 = vector();
            vector	N2 = vector();
            float	layeralpha1 = 0.0;
            float	masks2[] = {};
            {


                out_struct1 = _layer2;
                out_F2 = out_struct1.F;
                out_Of2 = out_struct1.Of;
                out_Ce1 = out_struct1.Ce;
                out_P1 = out_struct1.P;
                out_N1 = out_struct1.N;
                out_layeralpha1 = out_struct1.layeralpha;
                out_masks1 = out_struct1.masks;


                F4 = out_F2;
                Of3 = out_Of2;
                Ce5 = out_Ce1;
                P2 = out_P1;
                N2 = out_N1;
                layeralpha1 = out_layeralpha1;
                masks2 = out_masks1;
            }








            if( connected5 == 0 )
                result258 = F4;
            else
                result258 = __F;


            F5 = result258;


            connected7 = 0 ? 1 : 0;








            if( connected7 == 0 )
                result259 = Of3;
            else
                result259 = __Of;


            Of4 = result259;


            connected8 = 0 ? 1 : 0;








            if( connected8 == 0 )
                result260 = Ce5;
            else
                result260 = __Ce;


            Ce6 = result260;


            F3 = F5;
            Of2 = Of4;
            Ce4 = Ce6;
            masks1 = masks2;
        }


        ShaderLayer	_layer3 = _layer1;
        vector	_defaultvalue = { 0, 0, 0 };
        vector	exportvalue = vector();
        {


            value = _defaultvalue;





                index4 = find(_layer3.exports.names_v, "absorption");
                if(index4 >= 0)
                    value = _layer3.exports.values_v[index4];





            index4 = select(index4 >= 0, index4, -1);
            found30 = index4 >= 0;


            exportvalue = value;


            absorption = value;
        }


        ShaderLayer	_layer4 = _layer1;
        float	_defaultvalue1 = 0;
        float	exportvalue1 = 0.0;
        {


            value1 = _defaultvalue1;

                index5 = find(_layer4.exports.names_f, "ndpriority");
                if(index5 >= 0)
                    value1 = _layer4.exports.values_f[index5];
#line 10310 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            index5 = select(index5 >= 0, index5, -1);
            found31 = index5 >= 0;


            exportvalue1 = value1;


            ndpriority = value1;
        }


        output126 = (int)exportvalue1;


        ShaderLayer	_layer5 = _layer1;
        float	_defaultvalue2 = 0;
        float	exportvalue2 = 0.0;
        {


            value2 = _defaultvalue2;

                index6 = find(_layer5.exports.names_f, "ndior");
                if(index6 >= 0)
                    value2 = _layer5.exports.values_f[index6];
#line 10344 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            index6 = select(index6 >= 0, index6, -1);
            found32 = index6 >= 0;


            exportvalue2 = value2;


            ndior = value2;
        }


        pbrlighting(
        "direct", direct1,
        "indirect", indirect1,
        "all", all1,
        "indirect_emission", indirect_emission1,
        "direct_comp", direct_comp1,
        "indirect_comp", indirect_comp1,
        "all_comp", all_comp1,
        "direct_noshadow", direct_noshadow1,
        "direct_shadow", direct_shadow1,
        "indirect_noshadow", indirect_noshadow1,
        "indirect_shadow", indirect_shadow1,
        "level", level1,
        "diffuselevel", diffuselevel1,
        "specularlevel", specularlevel1,
        "volumelevel", volumelevel1,
        "direct_samples", direct_samples1,
        "indirect_samples", indirect_samples1,
        "nlights", nlights1,
        "direct_noshadow_comp", direct_noshadow_comp1,
        "indirect_noshadow_comp", indirect_noshadow_comp1,
        "inF", F3,
        "inOf", Of2,
        "use_renderstate", 1,
        "pathtype", "specular",
        "constrainmaxrough", 0,
        "raylimiteval", "none",
        "reflectratio", 0,
        "colorlimit", 10,
        "colorlimitdecay", 1,
        "colorlimitdepth", 2,
        "colorspace", "",
        "rayfilteramount", 0,
        "misbias", 0,
        "doshadow", 1,
        "multilight", 1,
        "recursive", 0,
        "absorption", exportvalue,
        "ndpriority", output126,
        "ndior", exportvalue2);


        sum14 = Ce4 + indirect_emission1;


        sum15 = sum14 + all1;


        Cf2 = sum15;


        out_Of3 = Of2;


        out_F3 = F3;


        Cf1 = Cf2;
        out_Of1 = out_Of3;
        out_F1 = out_F3;


        sum16 = direct1 + Ce4;


        direct = sum16;


        sum17 = indirect1 + indirect_emission1;


        indirect = sum17;


        Ce = Ce4;


        direct_emission = Ce4;


        all_emission = sum14;


        all = all1;


        indirect_emission = indirect_emission1;


        direct_comp = direct_comp1;


        indirect_comp = indirect_comp1;


        all_comp = all_comp1;


        direct_noshadow = direct_noshadow1;


        direct_shadow = direct_shadow1;


        indirect_noshadow = indirect_noshadow1;


        indirect_shadow = indirect_shadow1;


        level = level1;


        diffuselevel = diffuselevel1;


        specularlevel = specularlevel1;


        volumelevel = volumelevel1;


        direct_samples = direct_samples1;


        indirect_samples = indirect_samples1;


        nlights = nlights1;


        direct_noshadow_comp = direct_noshadow_comp1;


        indirect_noshadow_comp = indirect_noshadow_comp1;


        ShaderLayer	_layer6 = _layer1;
        float	_defaultvalue3 = 0;
        float	exportvalue3 = 0.0;
        {


            value3 = _defaultvalue3;

                index7 = find(_layer6.exports.names_f, "dispersion");
                if(index7 >= 0)
                    value3 = _layer6.exports.values_f[index7];
#line 10512 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
            index7 = select(index7 >= 0, index7, -1);
            found33 = index7 >= 0;


            exportvalue3 = value3;


            nddispersion = value3;
        }
    }


    clamp30 = clamp(color4, { 0, 0, 0 }, { 1, 1, 1 });


    complem1 = -clamp30;
    complem1 += 1;


    product71 = color * complem1;


    export_diffcolor = product71;
    export_diffcolor_tmp = export_diffcolor;


    lum21 = luminance(color);


    div1 = color / lum21;


    assign(output127,output212,output312, color3);



      blend24 = lerp({ 1, 1, 1 }, div1, output127);





    assign(output128,output213,output313, clamp30);



      blend25 = lerp(blend24, color, output128);





    export_speccolor = blend25;
    export_speccolor_tmp = export_speccolor;


    assign(output129,output214,output314, color4);


    export_metallic = output129;
    export_metallic_tmp = export_metallic;


    export_basecolor = color;
    export_basecolor_tmp = export_basecolor;


    assign(output130,output215,output315, color3);


    export_reflecttint = output130;
    export_reflecttint_tmp = export_reflecttint;


    assign(output131,output216,output316, color1);


    export_specrough = output131;
    export_specrough_tmp = export_specrough;


    assign(output132,output217,output317, color5);


    export_aniso = output132;
    export_aniso_tmp = export_aniso;


    assign(output133,output218,output318, color6);


    export_anisodir = output133;
    export_anisodir_tmp = export_anisodir;


    assign(output134,output219,output319, color10);


    export_sss = output134;
    export_sss_tmp = export_sss;


    assign(output135,output220,output320, color11);


    export_sssdist = output135;
    export_sssdist_tmp = export_sssdist;


    export_ssscolor = color12;
    export_ssscolor_tmp = export_ssscolor;


    assign(output136,output221,output321, color13);


    export_sheen = output136;
    export_sheen_tmp = export_sheen;


    assign(output137,output222,output322, color14);


    export_sheentint = output137;
    export_sheentint_tmp = export_sheentint;


    assign(output138,output223,output323, color8);


    export_coatrough = output138;
    export_coatrough_tmp = export_coatrough;


    assign(output139,output224,output324, color7);


    export_coat = output139;
    export_coat_tmp = export_coat;


    export_emitcolor = color9;
    export_emitcolor_tmp = export_emitcolor;


    export_emitint = emitint;
    export_emitint_tmp = export_emitint;


    export_uv = xformuvw;


    outlayer = layer1;
    outexport_diffcolor = export_diffcolor_tmp;
    outexport_speccolor = export_speccolor_tmp;
    outexport_metallic = export_metallic_tmp;
    outexport_basecolor = export_basecolor_tmp;
    outexport_reflect = export_reflect_tmp;
    outexport_reflecttint = export_reflecttint_tmp;
    outexport_specrough = export_specrough_tmp;
    outexport_aniso = export_aniso_tmp;
    outexport_anisodir = export_anisodir_tmp;
    outexport_sss = export_sss_tmp;
    outexport_sssdist = export_sssdist_tmp;
    outexport_ssscolor = export_ssscolor_tmp;
    outexport_sheen = export_sheen_tmp;
    outexport_sheentint = export_sheentint_tmp;
    outexport_coatrough = export_coatrough_tmp;
    outexport_coat = export_coat_tmp;
    outexport_emitcolor = export_emitcolor_tmp;
    outexport_emitint = export_emitint_tmp;
    outexport_uv = export_uv;

    _mat_materialbuilder1_principledshader1_add_layer_exports(outlayer, outexport_diffcolor, outexport_speccolor, outexport_metallic, outexport_basecolor, outexport_reflect, outexport_reflecttint, outexport_specrough, outexport_aniso, outexport_anisodir, outexport_sss, outexport_sssdist, outexport_ssscolor, outexport_sheen, outexport_sheentint, outexport_coatrough, outexport_coat, outexport_emitcolor, outexport_emitint, outexport_uv);


    layer = outlayer;


    vector	_uv58 = export_uv;
    vector	_N13 = result40;
    {


        found34 = renderstate("global:bake_samples", val30);
        if (!found34) val30 = 16;


        samples = val30;


        Oc1 = 0;
        gather(P, normalize(N),
               "angle", radians(90.0),
               "samples", samples)
        {
            Oc1 += 1;
        }
        Oc1 = 1 - Oc1 / samples;


        found35 = renderstate("global:bake_occlusionbias", val31);
        if (!found35) val31 = 0.5;


        occlusionbias = val31;
#line 10740 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
           bias = vop_bias(Oc1, occlusionbias);




        vec31 = set(bias,bias,bias);


        Oc = vec31;


        found36 = renderstate("global:bake_cavitydistance", val32);
        if (!found36) val32 = 1;


        cavitydistance = val32;


        Cv1 = 0;
        gather(P, -normalize(N),
               "angle", radians(90.0),
               "samples", samples,
               "maxdist", cavitydistance,
               "scope", "scope:default")
        {
            Cv1 += 1;
        }
        Cv1 = 1.0 - Cv1 / samples;


        found37 = renderstate("global:bake_cavitybias", val33);
        if (!found37) val33 = 0.5;


        cavitybias = val33;
#line 10797 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
           bias1 = vop_bias(Cv1, cavitybias);




        vec32 = set(bias1,bias1,bias1);


        Cv = vec32;


        Cf3 = {0,0,0};

        float th = 0;
        float rl = 0;
        gather(P, -normalize(N),
               "angle", radians(90.0),
               "samples", samples,
               "scope", "scope:default",
               "ray:length", rl)
        {
            th += rl;
        }
        th *= 1.0 / samples;
        Cf3 = th;



        Th = Cf3;



          blend26 = lerp({ 0, 0, 0 }, { 1, 1, 1 }, 0.5);





        Ab = blend26;


        found38 = renderstate("global:bake_curvaturescale", val34);
        if (!found38) val34 = 1;


        curvaturescale = val34;


        found39 = renderstate("global:bake_curvaturebias", val35);
        if (!found39) val35 = 0.5;


        curvaturebias = val35;


        found40 = renderstate("global:bake_curvatureocc", val36);
        if (!found40) val36 = 0;


        curvatureOcc = val36;


        found41 = renderstate("global:bake_curvaturesdist", val37);
        if (!found41) val37 = 0.10000000000000001;


        curvatureSDist = val37;


        float convex = 0;
        float concave = 0;

        if (curvatureOcc)
        {


            vector dir = normalize(N);



            vector off = dir * curvatureSDist * 0.02;
            float raylen;
            gather(P-off, -dir,
                   "angle", radians(90.0),
                   "samples", samples,
                   "distribution", "uniform",
                   "scope", "scope:default",
                   "maxdist", curvatureSDist,
                   "ray:length", raylen
                   )
            {
                convex += 1.0 - raylen/curvatureSDist;
            }
            convex *= curvaturescale / samples;

            gather(P+off, dir,
                   "angle", radians(90.0),
                   "samples", samples,
                   "distribution", "uniform",
                   "scope", "scope:default",
                   "maxdist", curvatureSDist,
                   "ray:length", raylen
                   )
            {
                concave += 1.0 - raylen/curvatureSDist;
            }
            concave *= curvaturescale / samples;
        }
        else
        {
            vector localCurvature = getlocalcurvature(s, t);

            convex = (localCurvature.x + curvatureConvex) * curvaturescale * 0.01;
            concave = (localCurvature.y + curvatureConcave) * curvaturescale * 0.01;
        }

        K = (vop_bias(convex, curvaturebias) - vop_bias(concave, curvaturebias)) * 0.5 + 0.5;


        vec33 = set(K,K,K);


        Cu = vec33;


        vector ray_org_l = 0;
        getsamplestore("uvlens_ray_org_l", Eye, ray_org_l);
        vector ray_org_h = 0;
        getsamplestore("uvlens_ray_org_h", Eye, ray_org_h);
        Vd1 = ray_org_h - ray_org_l;



        Vd = Vd1;


        found42 = renderstate("global:bake_usemikkt", val38);
        if (!found42) val38 = 0;


        usemikkt = val38;


        found43 = renderstate("global:bake_tangentnormalflipx", val39);
        if (!found43) val39 = 0;


        ntflipx = val39;


        found44 = renderstate("global:bake_tangentnormalflipy", val40);
        if (!found44) val40 = 0;


        ntflipy = val40;


        found45 = renderstate("global:bake_tangentnormalincludedisp", val41);
        if (!found45) val41 = 1;


        ntincludedisp = val41;


        isuvrender = isuvrendering();
        renderstate("renderer:uvcurrentuvobject", uvobject);
        renderstate("renderer:uvcurrenthiresobject", uvhiresobject);



        nvec20 = normalize(N);


        string	_tstyle5 = "uv";
        vector	_uv59 = vector();
        vector	_N14 = nvec20;
        vector	_utan6 = vector();
        vector	_vtan5 = vector();
        float	_angle5 = 0.0;
        {


            connected9 = 0 ? 1 : 0;


            result261 = 1 != 0 ? _N14 : N;


            nvec21 = normalize(result261);


            quat9 = quaternion(_angle5, nvec21);


            tstyle5 = _tstyle5;


            in_utan5 = _utan6;


            in_vtan5 = _vtan5;


            nml5 = nvec21;


            bound_uv29 = isbound("uv");
            if( bound_uv29 ) {
                uv67 = uv;
            } else {
                uv67 = set(s, t, .5);
            }


            result262 = 0 != 0 ? _uv59 : uv67;


            uv68 = result262;


            vop_computeTangents(tstyle5, nml5, uv68, in_utan5, in_vtan5, utan6, vtan6);


            result263 = qrotate(quat9, utan6);
#line 11032 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                result264 = (0 != 0 ? (connected9 != 0 ? utan6 : result263)
                                          : (connected9 != 0 ? result263 : utan6));




            result265 = qrotate(quat9, vtan6);
#line 11050 "/mat/materialbuilder1/principledshader1/SurfaceVexCode"
                result266 = (0 != 0 ? (connected9 != 0 ? vtan6 : result265)
                                          : (connected9 != 0 ? result265 : vtan6));




            _utan6 = result264;
            _vtan5 = result266;
        }


        found46 = renderstate("global:uv_unwrap_method", val42);
        if (!found46) val42 = 0;


        unwrapmethod = val42;


        found47 = renderstate("global:uv_flip_normal", val43);
        if (!found47) val43 = 0;


        flipnormal = val43;


        found48 = renderstate("global:bake_normalsfaceforward", val44);
        if (!found48) val44 = 1;


        faceforward = val44;


        vector	__uv = _uv58;
        int	_usemikkt = usemikkt;
        int	_ntflipx = ntflipx;
        int	_ntflipy = ntflipy;
        int	_ntincludedisp = ntincludedisp;
        vector	__N = _N13;
        string	_uvobject = uvobject;
        string	_uvhiresobject = uvhiresobject;
        vector	__utan = _utan6;
        vector	__vtan = _vtan5;
        int	_unwrapmethod = unwrapmethod;
        int	_flipnormal = flipnormal;
        int	_faceforward = faceforward;
        vector	tangentN = vector();
        {


            Ni = {0, 0, 0};


            vector Ni_p;
            int Ni_f = dimport("pre_disp_N", Ni_p);

            vector nn_p;
            vector utan_p;
            vector vtan_p;
            int nn_f = dimport("pre_disp_N", nn_p);
            int utan_f = dimport("pre_disp_utan", utan_p);
            int vtan_f = dimport("pre_disp_vtan", vtan_p);

            if (_uvhiresobject == "")
            {
                Ni = __N;
            }
            else
            {
                if (!_ntincludedisp && Ni_f)
                {
                    Ni = __N * dihedral(normalize(N), nn_p);
                }
                else
                {
                    Ni = __N;
                }
            }




            nn = {0, 0, 0};
            utan7 = {0, 0, 0};
            vtan7 = {0, 0, 0};


            vector nn_p1;
            vector utan_p1;
            vector vtan_p1;
            int nn_f1 = dimport("pre_disp_N", nn_p1);
            int utan_f1 = dimport("pre_disp_utan", utan_p1);
            int vtan_f1 = dimport("pre_disp_vtan", vtan_p1);

            if (_usemikkt)
            {
                vector mikkN = 0;
                vector mikkT = 0;
                vector mikkB = 0;
                getsamplestore("uvlens_mikkt_n", Eye, mikkN);
                getsamplestore("uvlens_mikkt_u", Eye, mikkT);
                getsamplestore("uvlens_mikkt_v", Eye, mikkB);

                utan7 = cross(mikkB, mikkN);
                vtan7 = cross(mikkN, mikkT);
                nn = cross(mikkT, mikkB);
                if (dot(mikkT, utan7) < 0)
                {
                    nn *= -1;
                    utan7 *= -1;
                    vtan7 *= -1;
                }
            }
            else if (_uvhiresobject == "")
            {
                if (_ntincludedisp && nn_f1 && utan_f1 && vtan_f1)
                {
                    nn = nn_p1;
                    utan7 = utan_p1;
                    vtan7 = vtan_p1;
                }
                else
                {
                    nn = normalize(N);
                    utan7 = __utan;
                    vtan7 = __vtan;
                }
            }
            else
            {
                nn = normalize(-I);
                vector resultn;
                getuvtangents(_uvobject, Eye, nn, utan7, vtan7, resultn);
                nn = resultn;
            }




            if (dot(Ni,nn) < 0)
                Nf4 = -Ni;
            else
                Nf4 = Ni;


            if( _faceforward == 0 )
                result267 = Ni;
            else
                result267 = Nf4;


            vector nn0 = (1 != 0) ? nn : normalize(N);
            vector ut = 0;
            vector vt = 0;
            vop_computeTangents("inputs", nn0, vector(), utan7, vtan7, ut, vt);
            tangentN1 = vop_tangentNormal(result267, nn0, ut, vt, 1, _ntflipx, _ntflipy, 1);


            tangentN = tangentN1;
        }


        Nt = tangentN;


        Ds1 = 0;


        vector ref_P = 0;
        vector ref_N = 0;
        int found_P = dimport("pre_disp_P", ref_P);
        int found_N = dimport("pre_disp_N", ref_N);

        if (uvhiresobject != "")
        {
            vector ray_org_l1 = 0;
            if (getsamplestore("uvlens_ray_org_l", Eye, ray_org_l1))
            {
                Ds1 = dot(normalize(I), ray_org_l1-P);
                Ds1 *= select(unwrapmethod == 0 && flipnormal, -1, 1);
            }
            else
                Ds1 = length(I) * (dot(normalize(I), normalize(N)) < 0 ? 1.0 : -1.0);
        }
        else if (found_P && found_N)
        {

            vector pd = ref_P - P;
            float sgn = (dot(ref_N, normalize(pd)) > 0) ? -1 : 1;
            Ds1 = length(pd) * sgn;
        }




        Ds = Ds1;


        string	_uvobject1 = uvobject;
        string	_uvhiresobject1 = uvhiresobject;
        int	_ntincludedisp1 = ntincludedisp;
        vector	__utan1 = _utan6;
        vector	__vtan1 = _vtan5;
        vector	utan8 = vector();
        vector	vtan8 = vector();
        vector	nn1 = vector();
        {


            nn2 = {0, 0, 0};
            utan9 = {0, 0, 0};
            vtan9 = {0, 0, 0};


            vector nn_p2;
            vector utan_p2;
            vector vtan_p2;
            int nn_f2 = dimport("pre_disp_N", nn_p2);
            int utan_f2 = dimport("pre_disp_utan", utan_p2);
            int vtan_f2 = dimport("pre_disp_vtan", vtan_p2);

            if (_uvhiresobject1 == "")
            {
                if (_ntincludedisp1 && nn_f2 && utan_f2 && vtan_f2)
                {
                    nn2 = nn_p2;
                    utan9 = utan_p2;
                    vtan9 = vtan_p2;
                }
                else
                {
                    nn2 = normalize(N);
                    utan9 = __utan1;
                    vtan9 = __vtan1;
                }
            }
            else
            {
                vector ray_org_l2 = 0;
                getsamplestore("uvlens_ray_org_l", Eye, ray_org_l2);
                vector dir1 = normalize(-I);
                getuvtangents(_uvobject1, ray_org_l2, dir1, utan9, vtan9, nn2);
            }




            utan8 = utan9;
            vtan8 = vtan9;
            nn1 = nn2;
        }


        matx4 = set(utan8, vtan8, nn1);





          inverse1 = invert(matx4);



        product72 = Vd1 * inverse1;


        Vdt = product72;
    }


    int components2 = 0;
    if (1)
        components2 |= bouncemask("alldiffuse");
    if (1)
        components2 |= (bouncemask("all") & ~(bouncemask("alldiffuse")|bouncemask("allvolume")|bouncemask("allsss")));
    if (0)
        components2 |= bouncemask("allvolume");

    vector ii2 = (0 != 0) ? vector() : normalize(I);
    albedo3 = albedo(out_F1, -ii2, components2);


    albedo = albedo3;


    vector tempCf = Cf1;
    vector tempOf = out_Of1;
    bsdf tempF = out_F1;
    Cf = tempCf;
    Of = tempOf;
    F = tempF;
}
